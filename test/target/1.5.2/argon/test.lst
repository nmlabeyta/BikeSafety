
c:/Users/nmlab/Documents/IoT/ClassAssignments/BikeSafety/test/target/1.5.2/argon/test.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  000d4000  000d4000  00004000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .dynalib      00000004  000d4018  000d4018  00004018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00006ed4  000d401c  000d401c  0000401c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .backup       00000004  2003f400  000daef0  0000f400  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         000000c0  20034980  000daef4  00014980  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00009db0  20034a40  20034a40  00024a40  2**2
                  ALLOC
  6 .module_info_suffix 00000028  000dafb4  000dafb4  0001afb4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .module_info_crc 00000004  000dafdc  000dafdc  0001afdc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .debug_info   001c50c9  00000000  00000000  0001afe0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0002236e  00000000  00000000  001e00a9  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0003066d  00000000  00000000  00202417  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00003520  00000000  00000000  00232a84  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00006478  00000000  00000000  00235fa4  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00050746  00000000  00000000  0023c41c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00059981  00000000  00000000  0028cb62  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00115b53  00000000  00000000  002e64e3  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  0001016c  00000000  00000000  003fc038  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

000d401c <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
   d401c:	4809      	ldr	r0, [pc, #36]	; (d4044 <link_dynalib_end+0x28>)
   d401e:	490a      	ldr	r1, [pc, #40]	; (d4048 <link_dynalib_end+0x2c>)
   d4020:	4288      	cmp	r0, r1
extern constructor_ptr_t link_constructors_end;

/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {
   d4022:	b508      	push	{r3, lr}

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
   d4024:	d005      	beq.n	d4032 <module_user_pre_init+0x16>
   d4026:	4a09      	ldr	r2, [pc, #36]	; (d404c <link_dynalib_end+0x30>)
   d4028:	4282      	cmp	r2, r0
   d402a:	d002      	beq.n	d4032 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
   d402c:	1a12      	subs	r2, r2, r0
   d402e:	f004 f80d 	bl	d804c <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
   d4032:	4807      	ldr	r0, [pc, #28]	; (d4050 <link_dynalib_end+0x34>)
   d4034:	4a07      	ldr	r2, [pc, #28]	; (d4054 <link_dynalib_end+0x38>)
   d4036:	2100      	movs	r1, #0
   d4038:	1a12      	subs	r2, r2, r0
   d403a:	f004 f812 	bl	d8062 <memset>
    return &link_global_data_start;
}
   d403e:	4801      	ldr	r0, [pc, #4]	; (d4044 <link_dynalib_end+0x28>)
   d4040:	bd08      	pop	{r3, pc}
   d4042:	bf00      	nop
   d4044:	20034980 	.word	0x20034980
   d4048:	000daef4 	.word	0x000daef4
   d404c:	20034a40 	.word	0x20034a40
   d4050:	20034a40 	.word	0x20034a40
   d4054:	2003e7f0 	.word	0x2003e7f0

000d4058 <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
   d4058:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
   d405a:	f002 fe05 	bl	d6c68 <module_user_init_hook>
   d405e:	4c07      	ldr	r4, [pc, #28]	; (d407c <module_user_init+0x24>)
   d4060:	4b07      	ldr	r3, [pc, #28]	; (d4080 <module_user_init+0x28>)
   d4062:	1ae4      	subs	r4, r4, r3
   d4064:	08a4      	lsrs	r4, r4, #2

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
   d4066:	2500      	movs	r5, #0
   d4068:	461e      	mov	r6, r3
   d406a:	42a5      	cmp	r5, r4
   d406c:	d004      	beq.n	d4078 <module_user_init+0x20>
    {
        link_constructors_location[ctor_num]();
   d406e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   d4072:	4798      	blx	r3
{
    module_user_init_hook();

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
   d4074:	3501      	adds	r5, #1
   d4076:	e7f8      	b.n	d406a <module_user_init+0x12>
    {
        link_constructors_location[ctor_num]();
    }
}
   d4078:	bd70      	pop	{r4, r5, r6, pc}
   d407a:	bf00      	nop
   d407c:	000daee8 	.word	0x000daee8
   d4080:	000dae68 	.word	0x000dae68

000d4084 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
   d4084:	f000 bd90 	b.w	d4ba8 <setup>

000d4088 <module_user_loop>:
}

void module_user_loop() {
   d4088:	b508      	push	{r3, lr}
    loop();
   d408a:	f000 fe19 	bl	d4cc0 <loop>
    _post_loop();
}
   d408e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    setup();
}

void module_user_loop() {
    loop();
    _post_loop();
   d4092:	f002 bdab 	b.w	d6bec <_post_loop>

000d4096 <_Znwj>:
   d4096:	f002 b825 	b.w	d60e4 <malloc>

000d409a <_ZdlPv>:
   d409a:	f002 b82b 	b.w	d60f4 <free>

000d409e <_ZdaPv>:
	free(p);
}

void operator delete[](void *p)
{
	free(p);
   d409e:	f002 b829 	b.w	d60f4 <free>
	...

000d40a4 <__cxa_pure_virtual>:
char* strerror(int errnum) {
    return (char*)"";
}

/* Default implementation for call made to pure virtual function. */
void __cxa_pure_virtual() {
   d40a4:	b508      	push	{r3, lr}
  PANIC(PureVirtualCall,"Call on pure virtual");
   d40a6:	4a03      	ldr	r2, [pc, #12]	; (d40b4 <__cxa_pure_virtual+0x10>)
   d40a8:	2100      	movs	r1, #0
   d40aa:	200c      	movs	r0, #12
   d40ac:	f001 ff46 	bl	d5f3c <panic_>
   d40b0:	e7fe      	b.n	d40b0 <__cxa_pure_virtual+0xc>
   d40b2:	bf00      	nop
   d40b4:	000d5c4d 	.word	0x000d5c4d

000d40b8 <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
   d40b8:	7800      	ldrb	r0, [r0, #0]
   d40ba:	fab0 f080 	clz	r0, r0
   d40be:	0940      	lsrs	r0, r0, #5
   d40c0:	4770      	bx	lr

000d40c2 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
   d40c2:	2301      	movs	r3, #1
   d40c4:	7003      	strb	r3, [r0, #0]
   d40c6:	4770      	bx	lr

000d40c8 <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
   d40c8:	4770      	bx	lr
	...

000d40cc <_Z17setSnapshotTarget6String>:
  }
  return 0;
}

int setSnapshotTarget(String target)
{
   d40cc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   d40ce:	4604      	mov	r4, r0
  if (target.equalsIgnoreCase("tcp"))
   d40d0:	490b      	ldr	r1, [pc, #44]	; (d4100 <_Z17setSnapshotTarget6String+0x34>)
   d40d2:	4668      	mov	r0, sp
   d40d4:	f002 f919 	bl	d630a <_ZN6StringC1EPK19__FlashStringHelper>
   d40d8:	4669      	mov	r1, sp
   d40da:	4620      	mov	r0, r4
   d40dc:	f002 f975 	bl	d63ca <_ZNK6String16equalsIgnoreCaseERKS_>
   d40e0:	4604      	mov	r4, r0
   d40e2:	4668      	mov	r0, sp
   d40e4:	f002 f8ca 	bl	d627c <_ZN6StringD1Ev>
   d40e8:	4b06      	ldr	r3, [pc, #24]	; (d4104 <_Z17setSnapshotTarget6String+0x38>)
   d40ea:	b11c      	cbz	r4, d40f4 <_Z17setSnapshotTarget6String+0x28>
  {
    snapTarget = callbackTCP;
   d40ec:	4a06      	ldr	r2, [pc, #24]	; (d4108 <_Z17setSnapshotTarget6String+0x3c>)
   d40ee:	601a      	str	r2, [r3, #0]
    return 1;
   d40f0:	2001      	movs	r0, #1
   d40f2:	e002      	b.n	d40fa <_Z17setSnapshotTarget6String+0x2e>
  }
  else 
    snapTarget = callbackSerial;                            // default to Serial
   d40f4:	4a05      	ldr	r2, [pc, #20]	; (d410c <_Z17setSnapshotTarget6String+0x40>)
   d40f6:	601a      	str	r2, [r3, #0]
    
  return 0;
   d40f8:	4620      	mov	r0, r4
}
   d40fa:	b004      	add	sp, #16
   d40fc:	bd10      	pop	{r4, pc}
   d40fe:	bf00      	nop
   d4100:	000da159 	.word	0x000da159
   d4104:	20034980 	.word	0x20034980
   d4108:	000d4285 	.word	0x000d4285
   d410c:	000d4259 	.word	0x000d4259

000d4110 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.4.constprop.16>:
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
   d4110:	b510      	push	{r4, lr}
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
   d4112:	6803      	ldr	r3, [r0, #0]
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
   d4114:	4604      	mov	r4, r0
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
   d4116:	689b      	ldr	r3, [r3, #8]
   d4118:	4798      	blx	r3
          if (--_M_weak_count == 0)
   d411a:	68a3      	ldr	r3, [r4, #8]
   d411c:	3b01      	subs	r3, #1
   d411e:	60a3      	str	r3, [r4, #8]
   d4120:	b92b      	cbnz	r3, d412e <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.4.constprop.16+0x1e>
            _M_destroy();
   d4122:	6823      	ldr	r3, [r4, #0]
   d4124:	4620      	mov	r0, r4
   d4126:	68db      	ldr	r3, [r3, #12]
        }
    }
   d4128:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
   d412c:	4718      	bx	r3
   d412e:	bd10      	pop	{r4, pc}

000d4130 <_ZN9WebServer5writeEh>:
{
  m_urlPathCmd = cmd;
}

size_t WebServer::write(uint8_t ch)
{
   d4130:	b510      	push	{r4, lr}
  m_buffer[m_bufFill++] = ch;
   d4132:	f890 3124 	ldrb.w	r3, [r0, #292]	; 0x124
   d4136:	1c5a      	adds	r2, r3, #1
   d4138:	b2d2      	uxtb	r2, r2
   d413a:	4403      	add	r3, r0

  if(m_bufFill == sizeof(m_buffer))
   d413c:	2a20      	cmp	r2, #32
  m_urlPathCmd = cmd;
}

size_t WebServer::write(uint8_t ch)
{
  m_buffer[m_bufFill++] = ch;
   d413e:	f880 2124 	strb.w	r2, [r0, #292]	; 0x124
{
  m_urlPathCmd = cmd;
}

size_t WebServer::write(uint8_t ch)
{
   d4142:	4604      	mov	r4, r0
  m_buffer[m_bufFill++] = ch;
   d4144:	f883 1104 	strb.w	r1, [r3, #260]	; 0x104

  if(m_bufFill == sizeof(m_buffer))
   d4148:	d107      	bne.n	d415a <_ZN9WebServer5writeEh+0x2a>
  {
    m_client.write(m_buffer, sizeof(m_buffer));
   d414a:	f500 7182 	add.w	r1, r0, #260	; 0x104
   d414e:	3038      	adds	r0, #56	; 0x38
   d4150:	f003 f88f 	bl	d7272 <_ZN9TCPClient5writeEPKhj>
    m_bufFill = 0;
   d4154:	2300      	movs	r3, #0
   d4156:	f884 3124 	strb.w	r3, [r4, #292]	; 0x124
  }

  return sizeof(ch);
}
   d415a:	2001      	movs	r0, #1
   d415c:	bd10      	pop	{r4, pc}

000d415e <_ZN9IPAddressD0Ev>:
   d415e:	b510      	push	{r4, lr}
   d4160:	2118      	movs	r1, #24
   d4162:	4604      	mov	r4, r0
   d4164:	f003 fcd0 	bl	d7b08 <_ZdlPvj>
   d4168:	4620      	mov	r0, r4
   d416a:	bd10      	pop	{r4, pc}

000d416c <_ZN9TCPClientD1Ev>:
class TCPClient : public Client {

public:
    TCPClient();
    TCPClient(sock_handle_t sock);
    virtual ~TCPClient() {};
   d416c:	b510      	push	{r4, lr}
   d416e:	4b06      	ldr	r3, [pc, #24]	; (d4188 <_ZN9TCPClientD1Ev+0x1c>)
   d4170:	6003      	str	r3, [r0, #0]
   d4172:	4604      	mov	r4, r0
      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
   d4174:	6980      	ldr	r0, [r0, #24]
   d4176:	b128      	cbz	r0, d4184 <_ZN9TCPClientD1Ev+0x18>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
   d4178:	6843      	ldr	r3, [r0, #4]
   d417a:	3b01      	subs	r3, #1
   d417c:	6043      	str	r3, [r0, #4]
   d417e:	b90b      	cbnz	r3, d4184 <_ZN9TCPClientD1Ev+0x18>
   d4180:	f7ff ffc6 	bl	d4110 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.4.constprop.16>
   d4184:	4620      	mov	r0, r4
   d4186:	bd10      	pop	{r4, pc}
   d4188:	000da8c4 	.word	0x000da8c4

000d418c <_ZN9WebServerD1Ev>:
                       URLPARAM_VALUE_OFLO,
                       URLPARAM_BOTH_OFLO,
                       URLPARAM_EOS         // No params left
};

class WebServer: public Print
   d418c:	4b09      	ldr	r3, [pc, #36]	; (d41b4 <_ZN9WebServerD1Ev+0x28>)
   d418e:	b510      	push	{r4, lr}
   d4190:	4604      	mov	r4, r0
   d4192:	f840 3b38 	str.w	r3, [r0], #56
   d4196:	f7ff ffe9 	bl	d416c <_ZN9TCPClientD1Ev>
    sock_handle_t _sock;
    TCPClient _client;

public:
    TCPServer(uint16_t, network_interface_t nif=0);
    ~TCPServer() { stop(); }
   d419a:	4620      	mov	r0, r4
   d419c:	4b06      	ldr	r3, [pc, #24]	; (d41b8 <_ZN9WebServerD1Ev+0x2c>)
   d419e:	f840 3f08 	str.w	r3, [r0, #8]!
   d41a2:	f002 fbb9 	bl	d6918 <_ZN9TCPServer4stopEv>
   d41a6:	f104 001c 	add.w	r0, r4, #28
   d41aa:	f7ff ffdf 	bl	d416c <_ZN9TCPClientD1Ev>
   d41ae:	4620      	mov	r0, r4
   d41b0:	bd10      	pop	{r4, pc}
   d41b2:	bf00      	nop
   d41b4:	000d9794 	.word	0x000d9794
   d41b8:	000da7b4 	.word	0x000da7b4

000d41bc <_ZN9WebServerD0Ev>:
   d41bc:	b510      	push	{r4, lr}
   d41be:	4604      	mov	r4, r0
   d41c0:	f7ff ffe4 	bl	d418c <_ZN9WebServerD1Ev>
   d41c4:	4620      	mov	r0, r4
   d41c6:	f44f 7194 	mov.w	r1, #296	; 0x128
   d41ca:	f003 fc9d 	bl	d7b08 <_ZdlPvj>
   d41ce:	4620      	mov	r0, r4
   d41d0:	bd10      	pop	{r4, pc}
	...

000d41d4 <_ZN10TCPClientXD1Ev>:
#pragma once

#include <Particle.h>

class TCPClientX : public TCPClient {
   d41d4:	b510      	push	{r4, lr}
   d41d6:	4b03      	ldr	r3, [pc, #12]	; (d41e4 <_ZN10TCPClientXD1Ev+0x10>)
   d41d8:	6003      	str	r3, [r0, #0]
   d41da:	4604      	mov	r4, r0
   d41dc:	f7ff ffc6 	bl	d416c <_ZN9TCPClientD1Ev>
   d41e0:	4620      	mov	r0, r4
   d41e2:	bd10      	pop	{r4, pc}
   d41e4:	000da444 	.word	0x000da444

000d41e8 <_ZN9TCPClientD0Ev>:
   d41e8:	b510      	push	{r4, lr}
   d41ea:	4604      	mov	r4, r0
   d41ec:	f7ff ffbe 	bl	d416c <_ZN9TCPClientD1Ev>
   d41f0:	4620      	mov	r0, r4
   d41f2:	211c      	movs	r1, #28
   d41f4:	f003 fc88 	bl	d7b08 <_ZdlPvj>
   d41f8:	4620      	mov	r0, r4
   d41fa:	bd10      	pop	{r4, pc}

000d41fc <_ZNK5spark6Logger5traceEPKcz>:
// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
}

inline void spark::Logger::trace(const char *fmt, ...) const {
   d41fc:	b40e      	push	{r1, r2, r3}
   d41fe:	b500      	push	{lr}
   d4200:	b08c      	sub	sp, #48	; 0x30
   d4202:	aa0d      	add	r2, sp, #52	; 0x34
    va_end(args);
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
   d4204:	2320      	movs	r3, #32
// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
}

inline void spark::Logger::trace(const char *fmt, ...) const {
   d4206:	f852 1b04 	ldr.w	r1, [r2], #4
    va_list args;
    va_start(args, fmt);
   d420a:	9203      	str	r2, [sp, #12]

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
    attr.flags = 0;
    log_message_v(level, name_, &attr, nullptr, fmt, args);
   d420c:	e88d 0006 	stmia.w	sp, {r1, r2}
    va_end(args);
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
   d4210:	9304      	str	r3, [sp, #16]
    attr.flags = 0;
    log_message_v(level, name_, &attr, nullptr, fmt, args);
   d4212:	6801      	ldr	r1, [r0, #0]
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
    attr.flags = 0;
   d4214:	2300      	movs	r3, #0
    log_message_v(level, name_, &attr, nullptr, fmt, args);
   d4216:	aa04      	add	r2, sp, #16
   d4218:	2001      	movs	r0, #1
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
    attr.flags = 0;
   d421a:	9305      	str	r3, [sp, #20]
    log_message_v(level, name_, &attr, nullptr, fmt, args);
   d421c:	f001 fe9e 	bl	d5f5c <log_message_v>
inline void spark::Logger::trace(const char *fmt, ...) const {
    va_list args;
    va_start(args, fmt);
    log(LOG_LEVEL_TRACE, fmt, args);
    va_end(args);
}
   d4220:	b00c      	add	sp, #48	; 0x30
   d4222:	f85d eb04 	ldr.w	lr, [sp], #4
   d4226:	b003      	add	sp, #12
   d4228:	4770      	bx	lr

000d422a <_ZNK5spark6Logger4infoEPKcz>:

inline void spark::Logger::info(const char *fmt, ...) const {
   d422a:	b40e      	push	{r1, r2, r3}
   d422c:	b500      	push	{lr}
   d422e:	b08c      	sub	sp, #48	; 0x30
   d4230:	aa0d      	add	r2, sp, #52	; 0x34
    va_end(args);
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
   d4232:	2320      	movs	r3, #32
    va_start(args, fmt);
    log(LOG_LEVEL_TRACE, fmt, args);
    va_end(args);
}

inline void spark::Logger::info(const char *fmt, ...) const {
   d4234:	f852 1b04 	ldr.w	r1, [r2], #4
    va_list args;
    va_start(args, fmt);
   d4238:	9203      	str	r2, [sp, #12]

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
    attr.flags = 0;
    log_message_v(level, name_, &attr, nullptr, fmt, args);
   d423a:	e88d 0006 	stmia.w	sp, {r1, r2}
    va_end(args);
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
   d423e:	9304      	str	r3, [sp, #16]
    attr.flags = 0;
    log_message_v(level, name_, &attr, nullptr, fmt, args);
   d4240:	6801      	ldr	r1, [r0, #0]
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
    attr.flags = 0;
   d4242:	2300      	movs	r3, #0
    log_message_v(level, name_, &attr, nullptr, fmt, args);
   d4244:	aa04      	add	r2, sp, #16
   d4246:	201e      	movs	r0, #30
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
    attr.flags = 0;
   d4248:	9305      	str	r3, [sp, #20]
    log_message_v(level, name_, &attr, nullptr, fmt, args);
   d424a:	f001 fe87 	bl	d5f5c <log_message_v>
inline void spark::Logger::info(const char *fmt, ...) const {
    va_list args;
    va_start(args, fmt);
    log(LOG_LEVEL_INFO, fmt, args);
    va_end(args);
}
   d424e:	b00c      	add	sp, #48	; 0x30
   d4250:	f85d eb04 	ldr.w	lr, [sp], #4
   d4254:	b003      	add	sp, #12
   d4256:	4770      	bx	lr

000d4258 <_Z14callbackSerialPhii>:
  
  return retVal;
}

int callbackSerial(uint8_t *buf, int len, int id)
{
   d4258:	b570      	push	{r4, r5, r6, lr}
  Log.info("Package %d (%d Byte) -> Serial", id, len);
   d425a:	460b      	mov	r3, r1
  
  return retVal;
}

int callbackSerial(uint8_t *buf, int len, int id)
{
   d425c:	4605      	mov	r5, r0
   d425e:	460c      	mov	r4, r1
  Log.info("Package %d (%d Byte) -> Serial", id, len);
   d4260:	4806      	ldr	r0, [pc, #24]	; (d427c <_Z14callbackSerialPhii+0x24>)
   d4262:	4907      	ldr	r1, [pc, #28]	; (d4280 <_Z14callbackSerialPhii+0x28>)
   d4264:	f7ff ffe1 	bl	d422a <_ZNK5spark6Logger4infoEPKcz>
  
  return Serial.write(buf, len);
   d4268:	f002 fe44 	bl	d6ef4 <_Z16_fetch_usbserialv>
   d426c:	6803      	ldr	r3, [r0, #0]
   d426e:	4622      	mov	r2, r4
   d4270:	4629      	mov	r1, r5
   d4272:	68db      	ldr	r3, [r3, #12]
}
   d4274:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

int callbackSerial(uint8_t *buf, int len, int id)
{
  Log.info("Package %d (%d Byte) -> Serial", id, len);
  
  return Serial.write(buf, len);
   d4278:	4718      	bx	r3
   d427a:	bf00      	nop
   d427c:	2003e2b0 	.word	0x2003e2b0
   d4280:	000da15d 	.word	0x000da15d

000d4284 <_Z11callbackTCPPhii>:
}

int callbackTCP(uint8_t *buf, int len, int id)
{
   d4284:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  Log.info("Package %d (%d Byte) -> TCP %s:%d", id, len, (const char*)serverAddr.toString(), serverPort);
   d4288:	4e19      	ldr	r6, [pc, #100]	; (d42f0 <_Z11callbackTCPPhii+0x6c>)
  
  return Serial.write(buf, len);
}

int callbackTCP(uint8_t *buf, int len, int id)
{
   d428a:	b088      	sub	sp, #32
   d428c:	460f      	mov	r7, r1
   d428e:	4680      	mov	r8, r0

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }

    String toString() const { return String(*this); }
   d4290:	4918      	ldr	r1, [pc, #96]	; (d42f4 <_Z11callbackTCPPhii+0x70>)
   d4292:	a802      	add	r0, sp, #8
   d4294:	4614      	mov	r4, r2
   d4296:	f002 f8b3 	bl	d6400 <_ZN6StringC1ERK9Printable>
  Log.info("Package %d (%d Byte) -> TCP %s:%d", id, len, (const char*)serverAddr.toString(), serverPort);
   d429a:	6833      	ldr	r3, [r6, #0]
   d429c:	9301      	str	r3, [sp, #4]
   d429e:	9b02      	ldr	r3, [sp, #8]
   d42a0:	9300      	str	r3, [sp, #0]
   d42a2:	4622      	mov	r2, r4
   d42a4:	463b      	mov	r3, r7
   d42a6:	4914      	ldr	r1, [pc, #80]	; (d42f8 <_Z11callbackTCPPhii+0x74>)
   d42a8:	4814      	ldr	r0, [pc, #80]	; (d42fc <_Z11callbackTCPPhii+0x78>)
   d42aa:	f7ff ffbe 	bl	d422a <_ZNK5spark6Logger4infoEPKcz>
   d42ae:	a802      	add	r0, sp, #8
   d42b0:	f001 ffe4 	bl	d627c <_ZN6StringD1Ev>

  if (serverPort)
   d42b4:	6830      	ldr	r0, [r6, #0]
   d42b6:	b1b8      	cbz	r0, d42e8 <_Z11callbackTCPPhii+0x64>
  {
    if (!client.connected()) 
   d42b8:	4811      	ldr	r0, [pc, #68]	; (d4300 <_Z11callbackTCPPhii+0x7c>)
   d42ba:	f002 fff0 	bl	d729e <_ZN9TCPClient9connectedEv>
   d42be:	4686      	mov	lr, r0
   d42c0:	b968      	cbnz	r0, d42de <_Z11callbackTCPPhii+0x5a>

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
   d42c2:	4d10      	ldr	r5, [pc, #64]	; (d4304 <_Z11callbackTCPPhii+0x80>)
   d42c4:	4b10      	ldr	r3, [pc, #64]	; (d4308 <_Z11callbackTCPPhii+0x84>)
   d42c6:	9302      	str	r3, [sp, #8]
   d42c8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   d42ca:	ac03      	add	r4, sp, #12
   d42cc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   d42ce:	682b      	ldr	r3, [r5, #0]
   d42d0:	7023      	strb	r3, [r4, #0]
      client.connect(serverAddr, serverPort);
   d42d2:	8832      	ldrh	r2, [r6, #0]
   d42d4:	480a      	ldr	r0, [pc, #40]	; (d4300 <_Z11callbackTCPPhii+0x7c>)
   d42d6:	4673      	mov	r3, lr
   d42d8:	a902      	add	r1, sp, #8
   d42da:	f003 f939 	bl	d7550 <_ZN9TCPClient7connectE9IPAddresstm>
    return client.write(buf, len);
   d42de:	463a      	mov	r2, r7
   d42e0:	4641      	mov	r1, r8
   d42e2:	4807      	ldr	r0, [pc, #28]	; (d4300 <_Z11callbackTCPPhii+0x7c>)
   d42e4:	f001 f9dc 	bl	d56a0 <_ZN10TCPClientX5writeEPKhj>
  }
  
  return 0;
}
   d42e8:	b008      	add	sp, #32
   d42ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   d42ee:	bf00      	nop
   d42f0:	20034bc4 	.word	0x20034bc4
   d42f4:	2003e27c 	.word	0x2003e27c
   d42f8:	000da17c 	.word	0x000da17c
   d42fc:	2003e2b0 	.word	0x2003e2b0
   d4300:	20034b90 	.word	0x20034b90
   d4304:	2003e280 	.word	0x2003e280
   d4308:	000da7d8 	.word	0x000da7d8

000d430c <_Z14devicesHandler6String>:
  webserver.processConnection(buff, &len);
#endif
}

int devicesHandler(String data) 
{
   d430c:	b5f0      	push	{r4, r5, r6, r7, lr}
   d430e:	4604      	mov	r4, r0
   d4310:	b08f      	sub	sp, #60	; 0x3c
  Log.trace(__FUNCTION__); 
   d4312:	491f      	ldr	r1, [pc, #124]	; (d4390 <_Z14devicesHandler6String+0x84>)
   d4314:	481f      	ldr	r0, [pc, #124]	; (d4394 <_Z14devicesHandler6String+0x88>)

  int addr[4];
  Log.trace("devicesHandler data=%s", data.c_str());

                                                                                        // nonce optional
  if (sscanf(data, "%u.%u.%u.%u:%u,%32s", &addr[0], &addr[1], &addr[2], &addr[3], &serverPort, nonce) >= 5) {
   d4316:	4f20      	ldr	r7, [pc, #128]	; (d4398 <_Z14devicesHandler6String+0x8c>)
   d4318:	4e20      	ldr	r6, [pc, #128]	; (d439c <_Z14devicesHandler6String+0x90>)
#endif
}

int devicesHandler(String data) 
{
  Log.trace(__FUNCTION__); 
   d431a:	f7ff ff6f 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>

  int addr[4];
  Log.trace("devicesHandler data=%s", data.c_str());
   d431e:	6822      	ldr	r2, [r4, #0]
   d4320:	491f      	ldr	r1, [pc, #124]	; (d43a0 <_Z14devicesHandler6String+0x94>)
   d4322:	481c      	ldr	r0, [pc, #112]	; (d4394 <_Z14devicesHandler6String+0x88>)
   d4324:	f7ff ff6a 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>

                                                                                        // nonce optional
  if (sscanf(data, "%u.%u.%u.%u:%u,%32s", &addr[0], &addr[1], &addr[2], &addr[3], &serverPort, nonce) >= 5) {
   d4328:	ab07      	add	r3, sp, #28
   d432a:	9301      	str	r3, [sp, #4]
   d432c:	ab06      	add	r3, sp, #24
   d432e:	9300      	str	r3, [sp, #0]
   d4330:	9703      	str	r7, [sp, #12]
   d4332:	9602      	str	r6, [sp, #8]
   d4334:	ab05      	add	r3, sp, #20
   d4336:	aa04      	add	r2, sp, #16
   d4338:	491a      	ldr	r1, [pc, #104]	; (d43a4 <_Z14devicesHandler6String+0x98>)
   d433a:	6820      	ldr	r0, [r4, #0]
   d433c:	f001 fef2 	bl	d6124 <sscanf>
   d4340:	2804      	cmp	r0, #4
   d4342:	dd22      	ble.n	d438a <_Z14devicesHandler6String+0x7e>
	serverAddr = IPAddress(addr[0], addr[1], addr[2], addr[3]);
   d4344:	f89d 001c 	ldrb.w	r0, [sp, #28]
   d4348:	f89d 3018 	ldrb.w	r3, [sp, #24]
   d434c:	f89d 2014 	ldrb.w	r2, [sp, #20]
   d4350:	f89d 1010 	ldrb.w	r1, [sp, #16]
   d4354:	9000      	str	r0, [sp, #0]
   d4356:	ad09      	add	r5, sp, #36	; 0x24
   d4358:	a808      	add	r0, sp, #32
   d435a:	f002 fd55 	bl	d6e08 <_ZN9IPAddressC1Ehhhh>
   d435e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   d4360:	4c11      	ldr	r4, [pc, #68]	; (d43a8 <_Z14devicesHandler6String+0x9c>)
   d4362:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   d4364:	4621      	mov	r1, r4
   d4366:	682b      	ldr	r3, [r5, #0]
   d4368:	f801 3914 	strb.w	r3, [r1], #-20

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }

    String toString() const { return String(*this); }
   d436c:	a808      	add	r0, sp, #32
   d436e:	f002 f847 	bl	d6400 <_ZN6StringC1ERK9Printable>
	Log.info("serverAddr=%s serverPort=%u nonce=%s", (const char*)serverAddr.toString(), serverPort, nonce);
   d4372:	6833      	ldr	r3, [r6, #0]
   d4374:	9a08      	ldr	r2, [sp, #32]
   d4376:	490d      	ldr	r1, [pc, #52]	; (d43ac <_Z14devicesHandler6String+0xa0>)
   d4378:	4806      	ldr	r0, [pc, #24]	; (d4394 <_Z14devicesHandler6String+0x88>)
   d437a:	9700      	str	r7, [sp, #0]
   d437c:	f7ff ff55 	bl	d422a <_ZNK5spark6Logger4infoEPKcz>
   d4380:	a808      	add	r0, sp, #32
   d4382:	f001 ff7b 	bl	d627c <_ZN6StringD1Ev>
	return serverPort;
   d4386:	6830      	ldr	r0, [r6, #0]
   d4388:	e000      	b.n	d438c <_Z14devicesHandler6String+0x80>
  }
  return 0;
   d438a:	2000      	movs	r0, #0
}
   d438c:	b00f      	add	sp, #60	; 0x3c
   d438e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   d4390:	000d9597 	.word	0x000d9597
   d4394:	2003e2b0 	.word	0x2003e2b0
   d4398:	2003e258 	.word	0x2003e258
   d439c:	20034bc4 	.word	0x20034bc4
   d43a0:	000da19e 	.word	0x000da19e
   d43a4:	000da1b5 	.word	0x000da1b5
   d43a8:	2003e280 	.word	0x2003e280
   d43ac:	000da1c9 	.word	0x000da1c9

000d43b0 <_ZN9WebServerC1EPKct>:

/********************************************************************
 * IMPLEMENTATION
 ********************************************************************/

WebServer::WebServer(const char *urlPrefix, uint16_t port) :
   d43b0:	b570      	push	{r4, r5, r6, lr}
  m_contentLength(0),
  m_failureCmd(&defaultFailCmd),
  m_defaultCmd(&defaultFailCmd),
  m_cmdCount(0),
  m_urlPathCmd(NULL),
  m_bufFill(0)
   d43b2:	4b10      	ldr	r3, [pc, #64]	; (d43f4 <_ZN9WebServerC1EPKct+0x44>)
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
   d43b4:	2500      	movs	r5, #0

/********************************************************************
 * IMPLEMENTATION
 ********************************************************************/

WebServer::WebServer(const char *urlPrefix, uint16_t port) :
   d43b6:	4604      	mov	r4, r0
   d43b8:	460e      	mov	r6, r1
   d43ba:	6045      	str	r5, [r0, #4]
   d43bc:	4611      	mov	r1, r2
  m_contentLength(0),
  m_failureCmd(&defaultFailCmd),
  m_defaultCmd(&defaultFailCmd),
  m_cmdCount(0),
  m_urlPathCmd(NULL),
  m_bufFill(0)
   d43be:	f840 3b08 	str.w	r3, [r0], #8
   d43c2:	462a      	mov	r2, r5
   d43c4:	f002 fa7e 	bl	d68c4 <_ZN9TCPServerC1Etm>
   d43c8:	f104 0038 	add.w	r0, r4, #56	; 0x38
   d43cc:	f003 f9ee 	bl	d77ac <_ZN9TCPClientC1Ev>
   d43d0:	4b09      	ldr	r3, [pc, #36]	; (d43f8 <_ZN9WebServerC1EPKct+0x48>)
   d43d2:	6566      	str	r6, [r4, #84]	; 0x54
   d43d4:	f884 5078 	strb.w	r5, [r4, #120]	; 0x78
   d43d8:	67e5      	str	r5, [r4, #124]	; 0x7c
   d43da:	f8c4 30b4 	str.w	r3, [r4, #180]	; 0xb4
   d43de:	f8c4 30b8 	str.w	r3, [r4, #184]	; 0xb8
   d43e2:	f884 50fc 	strb.w	r5, [r4, #252]	; 0xfc
   d43e6:	f8c4 5100 	str.w	r5, [r4, #256]	; 0x100
   d43ea:	f884 5124 	strb.w	r5, [r4, #292]	; 0x124
{
}
   d43ee:	4620      	mov	r0, r4
   d43f0:	bd70      	pop	{r4, r5, r6, pc}
   d43f2:	bf00      	nop
   d43f4:	000d9794 	.word	0x000d9794
   d43f8:	000d460d 	.word	0x000d460d

000d43fc <_ZN9WebServer10addCommandEPKcPFvRS_NS_14ConnectionTypeEPcbE>:
  m_failureCmd = cmd;
}

void WebServer::addCommand(const char *verb, Command *cmd)
{
  if (m_cmdCount < SIZE(m_commands))
   d43fc:	f890 30fc 	ldrb.w	r3, [r0, #252]	; 0xfc
   d4400:	2b07      	cmp	r3, #7
{
  m_failureCmd = cmd;
}

void WebServer::addCommand(const char *verb, Command *cmd)
{
   d4402:	b510      	push	{r4, lr}
  if (m_cmdCount < SIZE(m_commands))
   d4404:	d808      	bhi.n	d4418 <_ZN9WebServer10addCommandEPKcPFvRS_NS_14ConnectionTypeEPcbE+0x1c>
   d4406:	eb00 04c3 	add.w	r4, r0, r3, lsl #3
  {
    m_commands[m_cmdCount].verb = verb;
    m_commands[m_cmdCount++].cmd = cmd;
   d440a:	3301      	adds	r3, #1

void WebServer::addCommand(const char *verb, Command *cmd)
{
  if (m_cmdCount < SIZE(m_commands))
  {
    m_commands[m_cmdCount].verb = verb;
   d440c:	f8c4 10bc 	str.w	r1, [r4, #188]	; 0xbc
    m_commands[m_cmdCount++].cmd = cmd;
   d4410:	f880 30fc 	strb.w	r3, [r0, #252]	; 0xfc
   d4414:	f8c4 20c0 	str.w	r2, [r4, #192]	; 0xc0
   d4418:	bd10      	pop	{r4, pc}

000d441a <_ZN9WebServer8flushBufEv>:
  fixmedelay();
  return m_client.write(buffer, size);
}

void WebServer::flushBuf()
{
   d441a:	b510      	push	{r4, lr}
  if(m_bufFill > 0)
   d441c:	f890 3124 	ldrb.w	r3, [r0, #292]	; 0x124
  fixmedelay();
  return m_client.write(buffer, size);
}

void WebServer::flushBuf()
{
   d4420:	4604      	mov	r4, r0
  if(m_bufFill > 0)
   d4422:	b16b      	cbz	r3, d4440 <_ZN9WebServer8flushBufEv+0x26>
  {
    SERIAL_DUMP(m_buffer, m_bufFill);
    fixmedelay();    
   d4424:	2014      	movs	r0, #20
   d4426:	f002 f9b3 	bl	d6790 <delay>
    m_client.write(m_buffer, m_bufFill);
   d442a:	f894 2124 	ldrb.w	r2, [r4, #292]	; 0x124
   d442e:	f504 7182 	add.w	r1, r4, #260	; 0x104
   d4432:	f104 0038 	add.w	r0, r4, #56	; 0x38
   d4436:	f002 ff1c 	bl	d7272 <_ZN9TCPClient5writeEPKhj>
    m_bufFill = 0;
   d443a:	2300      	movs	r3, #0
   d443c:	f884 3124 	strb.w	r3, [r4, #292]	; 0x124
   d4440:	bd10      	pop	{r4, pc}

000d4442 <_ZN9WebServer5writeEPKhj>:

  return sizeof(ch);
}

size_t WebServer::write(const uint8_t *buffer, size_t size)
{
   d4442:	b570      	push	{r4, r5, r6, lr}
   d4444:	4604      	mov	r4, r0
   d4446:	460d      	mov	r5, r1
   d4448:	4616      	mov	r6, r2
  flushBuf(); //Flush any buffered output
   d444a:	f7ff ffe6 	bl	d441a <_ZN9WebServer8flushBufEv>
  SERIAL_DUMP(buffer, size);
  fixmedelay();
   d444e:	2014      	movs	r0, #20
   d4450:	f002 f99e 	bl	d6790 <delay>
  return m_client.write(buffer, size);
   d4454:	4632      	mov	r2, r6
   d4456:	4629      	mov	r1, r5
   d4458:	f104 0038 	add.w	r0, r4, #56	; 0x38
}
   d445c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
size_t WebServer::write(const uint8_t *buffer, size_t size)
{
  flushBuf(); //Flush any buffered output
  SERIAL_DUMP(buffer, size);
  fixmedelay();
  return m_client.write(buffer, size);
   d4460:	f002 bf07 	b.w	d7272 <_ZN9TCPClient5writeEPKhj>

000d4464 <_Z17callbackWebServerPhii>:
// ------------------------------------------------------------------------------------------------------------------------
#if Wiring_WiFi // ---------------------------  only available for WiFi devices -------------------------------------------

int callbackWebServer(uint8_t *buf, int len, int id) 
{
  return webserver.write(buf, len);
   d4464:	460a      	mov	r2, r1
   d4466:	4601      	mov	r1, r0
   d4468:	4801      	ldr	r0, [pc, #4]	; (d4470 <_Z17callbackWebServerPhii+0xc>)
   d446a:	f7ff bfea 	b.w	d4442 <_ZN9WebServer5writeEPKhj>
   d446e:	bf00      	nop
   d4470:	20034a48 	.word	0x20034a48

000d4474 <_ZN9WebServer6writePEPKhj>:
    m_bufFill = 0;
  }
}

void WebServer::writeP(const unsigned char *data, size_t length)
{
   d4474:	b570      	push	{r4, r5, r6, lr}
   d4476:	4604      	mov	r4, r0
  // copy data out of program memory into local storage
#ifdef SPARK_CORE
    fixmedelay();    
   d4478:	2014      	movs	r0, #20
    m_bufFill = 0;
  }
}

void WebServer::writeP(const unsigned char *data, size_t length)
{
   d447a:	460d      	mov	r5, r1
   d447c:	4616      	mov	r6, r2
  // copy data out of program memory into local storage
#ifdef SPARK_CORE
    fixmedelay();    
   d447e:	f002 f987 	bl	d6790 <delay>
   write(data, length);
   d4482:	6823      	ldr	r3, [r4, #0]
   d4484:	4632      	mov	r2, r6
   d4486:	4629      	mov	r1, r5
   d4488:	4620      	mov	r0, r4
   d448a:	68db      	ldr	r3, [r3, #12]
  while (length--)
  {
    write(pgm_read_byte(data++));
  }
#endif  
}
   d448c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
void WebServer::writeP(const unsigned char *data, size_t length)
{
  // copy data out of program memory into local storage
#ifdef SPARK_CORE
    fixmedelay();    
   write(data, length);
   d4490:	4718      	bx	r3

000d4492 <_ZN9WebServer6printPEPKh>:
  }
#endif  
}

void WebServer::printP(const unsigned char *str)
{
   d4492:	b570      	push	{r4, r5, r6, lr}
   d4494:	460d      	mov	r5, r1
   d4496:	4604      	mov	r4, r0
  // copy data out of program memory into local storage
#ifdef SPARK_CORE
    fixmedelay();
   d4498:	2014      	movs	r0, #20
   d449a:	f002 f979 	bl	d6790 <delay>
    write((const uint8_t*)str, strlen((const char*)str));
   d449e:	4628      	mov	r0, r5
   d44a0:	f004 fb44 	bl	d8b2c <strlen>
   d44a4:	6823      	ldr	r3, [r4, #0]
   d44a6:	4602      	mov	r2, r0
   d44a8:	4629      	mov	r1, r5
   d44aa:	4620      	mov	r0, r4
   d44ac:	68db      	ldr	r3, [r3, #12]
  while (uint8_t value = pgm_read_byte(str++))
  {
    write(value);
  }
#endif  
}
   d44ae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
void WebServer::printP(const unsigned char *str)
{
  // copy data out of program memory into local storage
#ifdef SPARK_CORE
    fixmedelay();
    write((const uint8_t*)str, strlen((const char*)str));
   d44b2:	4718      	bx	r3

000d44b4 <_ZN9WebServer9printCRLFEv>:
#endif  
}

void WebServer::printCRLF()
{
  print(CRLF);
   d44b4:	4901      	ldr	r1, [pc, #4]	; (d44bc <_ZN9WebServer9printCRLFEv+0x8>)
   d44b6:	f001 bfef 	b.w	d6498 <_ZN5Print5printEPKc>
   d44ba:	bf00      	nop
   d44bc:	000da273 	.word	0x000da273

000d44c0 <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb>:
}
#endif

bool WebServer::dispatchCommand(ConnectionType requestType, char *verb,
        bool tail_complete)
{
   d44c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  // if there is no URL, i.e. we have a prefix and it's requested without a
  // trailing slash or if the URL is just the slash
  if ((verb[0] == 0) || ((verb[0] == '/') && (verb[1] == 0)))
   d44c4:	7814      	ldrb	r4, [r2, #0]
}
#endif

bool WebServer::dispatchCommand(ConnectionType requestType, char *verb,
        bool tail_complete)
{
   d44c6:	b08d      	sub	sp, #52	; 0x34
   d44c8:	4606      	mov	r6, r0
   d44ca:	460f      	mov	r7, r1
   d44cc:	4698      	mov	r8, r3
  // if there is no URL, i.e. we have a prefix and it's requested without a
  // trailing slash or if the URL is just the slash
  if ((verb[0] == 0) || ((verb[0] == '/') && (verb[1] == 0)))
   d44ce:	b11c      	cbz	r4, d44d8 <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0x18>
   d44d0:	2c2f      	cmp	r4, #47	; 0x2f
   d44d2:	d17f      	bne.n	d45d4 <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0x114>
   d44d4:	7854      	ldrb	r4, [r2, #1]
   d44d6:	b934      	cbnz	r4, d44e6 <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0x26>
  {
    m_defaultCmd(*this, requestType, (char*)"", tail_complete);
   d44d8:	f8d6 40b8 	ldr.w	r4, [r6, #184]	; 0xb8
   d44dc:	4a3f      	ldr	r2, [pc, #252]	; (d45dc <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0x11c>)
   d44de:	4643      	mov	r3, r8
   d44e0:	4639      	mov	r1, r7
   d44e2:	4630      	mov	r0, r6
   d44e4:	e004      	b.n	d44f0 <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0x30>
    return true;
  }
  // if the URL is just a slash followed by a question mark
  // we're looking at the default command with GET parameters passed
  if ((verb[0] == '/') && (verb[1] == '?'))
   d44e6:	2c3f      	cmp	r4, #63	; 0x3f
   d44e8:	d104      	bne.n	d44f4 <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0x34>
  {
    verb+=2; // skip over the "/?" part of the url
    m_defaultCmd(*this, requestType, verb, tail_complete);
   d44ea:	f8d0 40b8 	ldr.w	r4, [r0, #184]	; 0xb8
   d44ee:	3202      	adds	r2, #2
   d44f0:	47a0      	blx	r4
   d44f2:	e06d      	b.n	d45d0 <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0x110>
    char *qm_loc;
    uint16_t verb_len;
    uint8_t qm_offset;
    // Skip over the leading "/",  because it makes the code more
    // efficient and easier to understand.
    verb++;
   d44f4:	1c54      	adds	r4, r2, #1
    // Look for a "?" separating the filename part of the URL from the
    // parameters.  If it's not there, compare to the whole URL.
    qm_loc = strchr(verb, '?');
   d44f6:	213f      	movs	r1, #63	; 0x3f
   d44f8:	4620      	mov	r0, r4
   d44fa:	f003 fde3 	bl	d80c4 <strchr>
    verb_len = (qm_loc == NULL) ? strlen(verb) : (qm_loc - verb);
   d44fe:	4681      	mov	r9, r0
   d4500:	b920      	cbnz	r0, d450c <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0x4c>
   d4502:	4620      	mov	r0, r4
   d4504:	f004 fb12 	bl	d8b2c <strlen>
   d4508:	b285      	uxth	r5, r0
   d450a:	e001      	b.n	d4510 <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0x50>
   d450c:	1b05      	subs	r5, r0, r4
   d450e:	b2ad      	uxth	r5, r5
    qm_offset = (qm_loc == NULL) ? 0 : 1;
   d4510:	f119 0900 	adds.w	r9, r9, #0
    for (i = 0; i < m_cmdCount; ++i)
   d4514:	f896 b0fc 	ldrb.w	fp, [r6, #252]	; 0xfc
    verb++;
    // Look for a "?" separating the filename part of the URL from the
    // parameters.  If it's not there, compare to the whole URL.
    qm_loc = strchr(verb, '?');
    verb_len = (qm_loc == NULL) ? strlen(verb) : (qm_loc - verb);
    qm_offset = (qm_loc == NULL) ? 0 : 1;
   d4518:	bf18      	it	ne
   d451a:	f04f 0901 	movne.w	r9, #1
    for (i = 0; i < m_cmdCount; ++i)
   d451e:	f04f 0a00 	mov.w	sl, #0
   d4522:	fa5f f38a 	uxtb.w	r3, sl
   d4526:	459b      	cmp	fp, r3
   d4528:	d91e      	bls.n	d4568 <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0xa8>
    {
      if ((verb_len == strlen(m_commands[i].verb))
   d452a:	eb06 03ca 	add.w	r3, r6, sl, lsl #3
   d452e:	f8d3 10bc 	ldr.w	r1, [r3, #188]	; 0xbc
   d4532:	9103      	str	r1, [sp, #12]
   d4534:	4608      	mov	r0, r1
   d4536:	f004 faf9 	bl	d8b2c <strlen>
   d453a:	4285      	cmp	r5, r0
   d453c:	9903      	ldr	r1, [sp, #12]
   d453e:	d110      	bne.n	d4562 <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0xa2>
          && (strncmp(verb, m_commands[i].verb, verb_len) == 0))
   d4540:	462a      	mov	r2, r5
   d4542:	4620      	mov	r0, r4
   d4544:	f004 fafa 	bl	d8b3c <strncmp>
   d4548:	b958      	cbnz	r0, d4562 <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0xa2>
      {
        // Skip over the "verb" part of the URL (and the question
        // mark, if present) when passing it to the "action" routine
        m_commands[i].cmd(*this, requestType,
   d454a:	eb06 0aca 	add.w	sl, r6, sl, lsl #3
        verb + verb_len + qm_offset,
        tail_complete);
   d454e:	eb09 0205 	add.w	r2, r9, r5
   d4552:	4643      	mov	r3, r8
   d4554:	f8da 50c0 	ldr.w	r5, [sl, #192]	; 0xc0
   d4558:	4422      	add	r2, r4
   d455a:	4639      	mov	r1, r7
   d455c:	4630      	mov	r0, r6
   d455e:	47a8      	blx	r5
   d4560:	e036      	b.n	d45d0 <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0x110>
   d4562:	f10a 0a01 	add.w	sl, sl, #1
   d4566:	e7dc      	b.n	d4522 <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0x62>
        return true;
      }
    }
    // Check if UrlPathCommand is assigned.
    if (m_urlPathCmd != NULL)
   d4568:	f8d6 0100 	ldr.w	r0, [r6, #256]	; 0x100
   d456c:	b398      	cbz	r0, d45d6 <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0x116>
    {
      // Initialize with null bytes, so number of parts can be determined.
      char *url_path[WEBDUINO_URL_PATH_COMMAND_LENGTH] = {0};
   d456e:	2220      	movs	r2, #32
   d4570:	2100      	movs	r1, #0
   d4572:	a804      	add	r0, sp, #16
   d4574:	f003 fd75 	bl	d8062 <memset>
      uint8_t part = 0;

      // URL path should be terminated with null byte.
      *(verb + verb_len) = 0;
   d4578:	2200      	movs	r2, #0
   d457a:	5562      	strb	r2, [r4, r5]
   d457c:	eb04 0e05 	add.w	lr, r4, r5

      // First URL path part is at the start of verb.
      url_path[part++] = verb;
   d4580:	9404      	str	r4, [sp, #16]
   d4582:	4621      	mov	r1, r4
   d4584:	2301      	movs	r3, #1
      // with a null byte).
      for (char * p = verb; p < verb + verb_len; p++)
      {
        if (*p == '/' && *(p+1))        // keep the last path component so we know it's a directory
        {
          *p = 0;
   d4586:	4610      	mov	r0, r2
      url_path[part++] = verb;
      // Replace all slashes ('/') with a null byte so every part of the URL
      // path is a seperate string. Add every char following a '/' as a new
      // part of the URL, even if that char is a '/' (which will be replaced
      // with a null byte).
      for (char * p = verb; p < verb + verb_len; p++)
   d4588:	458e      	cmp	lr, r1
   d458a:	460a      	mov	r2, r1
   d458c:	d915      	bls.n	d45ba <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0xfa>
      {
        if (*p == '/' && *(p+1))        // keep the last path component so we know it's a directory
   d458e:	7812      	ldrb	r2, [r2, #0]
   d4590:	2a2f      	cmp	r2, #47	; 0x2f
   d4592:	f101 0101 	add.w	r1, r1, #1
   d4596:	d1f7      	bne.n	d4588 <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0xc8>
   d4598:	780a      	ldrb	r2, [r1, #0]
   d459a:	2a00      	cmp	r2, #0
   d459c:	d0f4      	beq.n	d4588 <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0xc8>
        {
          *p = 0;
          url_path[part++] = p + 1;
   d459e:	1c5a      	adds	r2, r3, #1
   d45a0:	f10d 0c30 	add.w	ip, sp, #48	; 0x30
   d45a4:	b2d2      	uxtb	r2, r2
   d45a6:	eb0c 0383 	add.w	r3, ip, r3, lsl #2
          // Don't try to assign out of array bounds.
          if (part == WEBDUINO_URL_PATH_COMMAND_LENGTH) break;
   d45aa:	2a08      	cmp	r2, #8
      // with a null byte).
      for (char * p = verb; p < verb + verb_len; p++)
      {
        if (*p == '/' && *(p+1))        // keep the last path component so we know it's a directory
        {
          *p = 0;
   d45ac:	f801 0c01 	strb.w	r0, [r1, #-1]
          url_path[part++] = p + 1;
   d45b0:	f843 1c20 	str.w	r1, [r3, #-32]
          // Don't try to assign out of array bounds.
          if (part == WEBDUINO_URL_PATH_COMMAND_LENGTH) break;
   d45b4:	d001      	beq.n	d45ba <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0xfa>
   d45b6:	4613      	mov	r3, r2
   d45b8:	e7e6      	b.n	d4588 <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0xc8>
        }
      }
      m_urlPathCmd(*this, requestType, url_path,
                   verb + verb_len + qm_offset, tail_complete);
   d45ba:	eb09 0305 	add.w	r3, r9, r5
   d45be:	f8cd 8000 	str.w	r8, [sp]
   d45c2:	f8d6 5100 	ldr.w	r5, [r6, #256]	; 0x100
   d45c6:	4423      	add	r3, r4
   d45c8:	aa04      	add	r2, sp, #16
   d45ca:	4639      	mov	r1, r7
   d45cc:	4630      	mov	r0, r6
   d45ce:	47a8      	blx	r5
      return true;
   d45d0:	2001      	movs	r0, #1
   d45d2:	e000      	b.n	d45d6 <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb+0x116>
    }
  }
  return false;
   d45d4:	2000      	movs	r0, #0
}
   d45d6:	b00d      	add	sp, #52	; 0x34
   d45d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   d45dc:	000da275 	.word	0x000da275

000d45e0 <_ZN9WebServer8httpFailEv>:
     (0 == strcmp(authCredentials, m_authCredentials + 6))) return true;
  return false;
}

void WebServer::httpFail()
{
   d45e0:	b510      	push	{r4, lr}
  P(failMsg1) = "HTTP/1.0 400 Bad Request" CRLF;
  printP(failMsg1);
   d45e2:	4907      	ldr	r1, [pc, #28]	; (d4600 <_ZN9WebServer8httpFailEv+0x20>)
     (0 == strcmp(authCredentials, m_authCredentials + 6))) return true;
  return false;
}

void WebServer::httpFail()
{
   d45e4:	4604      	mov	r4, r0
  P(failMsg1) = "HTTP/1.0 400 Bad Request" CRLF;
  printP(failMsg1);
   d45e6:	f7ff ff54 	bl	d4492 <_ZN9WebServer6printPEPKh>

#ifndef WEBDUINO_SUPRESS_SERVER_HEADER
  printP(webServerHeader);
   d45ea:	4620      	mov	r0, r4
   d45ec:	4905      	ldr	r1, [pc, #20]	; (d4604 <_ZN9WebServer8httpFailEv+0x24>)
   d45ee:	f7ff ff50 	bl	d4492 <_ZN9WebServer6printPEPKh>
  P(failMsg2) = 
    "Content-Type: text/html" CRLF
    CRLF
    WEBDUINO_FAIL_MESSAGE;

  printP(failMsg2);
   d45f2:	4620      	mov	r0, r4
   d45f4:	4904      	ldr	r1, [pc, #16]	; (d4608 <_ZN9WebServer8httpFailEv+0x28>)
}
   d45f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  P(failMsg2) = 
    "Content-Type: text/html" CRLF
    CRLF
    WEBDUINO_FAIL_MESSAGE;

  printP(failMsg2);
   d45fa:	f7ff bf4a 	b.w	d4492 <_ZN9WebServer6printPEPKh>
   d45fe:	bf00      	nop
   d4600:	000d944b 	.word	0x000d944b
   d4604:	000d9761 	.word	0x000d9761
   d4608:	000d95cc 	.word	0x000d95cc

000d460c <_ZN9WebServer14defaultFailCmdERS_NS_14ConnectionTypeEPcb>:
void WebServer::defaultFailCmd(WebServer &server,
                               WebServer::ConnectionType type,
                               char *url_tail,
                               bool tail_complete)
{
  server.httpFail();
   d460c:	f7ff bfe8 	b.w	d45e0 <_ZN9WebServer8httpFailEv>

000d4610 <_ZN9WebServer11httpSuccessEPKcS1_>:
  printP(noContentMsg2);
}

void WebServer::httpSuccess(const char *contentType,
                            const char *extraHeaders)
{
   d4610:	b570      	push	{r4, r5, r6, lr}
   d4612:	4604      	mov	r4, r0
   d4614:	460e      	mov	r6, r1
  P(successMsg1) = "HTTP/1.0 200 OK" CRLF;
  printP(successMsg1);
   d4616:	4910      	ldr	r1, [pc, #64]	; (d4658 <_ZN9WebServer11httpSuccessEPKcS1_+0x48>)
  printP(noContentMsg2);
}

void WebServer::httpSuccess(const char *contentType,
                            const char *extraHeaders)
{
   d4618:	4615      	mov	r5, r2
  P(successMsg1) = "HTTP/1.0 200 OK" CRLF;
  printP(successMsg1);
   d461a:	f7ff ff3a 	bl	d4492 <_ZN9WebServer6printPEPKh>

#ifndef WEBDUINO_SUPRESS_SERVER_HEADER
  printP(webServerHeader);
   d461e:	490f      	ldr	r1, [pc, #60]	; (d465c <_ZN9WebServer11httpSuccessEPKcS1_+0x4c>)
   d4620:	4620      	mov	r0, r4
   d4622:	f7ff ff36 	bl	d4492 <_ZN9WebServer6printPEPKh>
  
  P(successMsg2) = 
    "Access-Control-Allow-Origin: *" CRLF
    "Content-Type: ";

  printP(successMsg2); 
   d4626:	490e      	ldr	r1, [pc, #56]	; (d4660 <_ZN9WebServer11httpSuccessEPKcS1_+0x50>)
   d4628:	4620      	mov	r0, r4
   d462a:	f7ff ff32 	bl	d4492 <_ZN9WebServer6printPEPKh>
  print(contentType);
   d462e:	4631      	mov	r1, r6
   d4630:	4620      	mov	r0, r4
   d4632:	f001 ff31 	bl	d6498 <_ZN5Print5printEPKc>
  printCRLF();
   d4636:	4620      	mov	r0, r4
   d4638:	f7ff ff3c 	bl	d44b4 <_ZN9WebServer9printCRLFEv>
  if (extraHeaders) {
   d463c:	b135      	cbz	r5, d464c <_ZN9WebServer11httpSuccessEPKcS1_+0x3c>
    print(extraHeaders);
   d463e:	4629      	mov	r1, r5
   d4640:	4620      	mov	r0, r4
   d4642:	f001 ff29 	bl	d6498 <_ZN5Print5printEPKc>
    printCRLF();    
   d4646:	4620      	mov	r0, r4
   d4648:	f7ff ff34 	bl	d44b4 <_ZN9WebServer9printCRLFEv>
  }
  printCRLF();   // blank line starts body
   d464c:	4620      	mov	r0, r4
}
   d464e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  printCRLF();
  if (extraHeaders) {
    print(extraHeaders);
    printCRLF();    
  }
  printCRLF();   // blank line starts body
   d4652:	f7ff bf2f 	b.w	d44b4 <_ZN9WebServer9printCRLFEv>
   d4656:	bf00      	nop
   d4658:	000d97b1 	.word	0x000d97b1
   d465c:	000d9761 	.word	0x000d9761
   d4660:	000d97c3 	.word	0x000d97c3

000d4664 <_ZN9WebServer8noRobotsENS_14ConnectionTypeE>:
{
  server.httpFail();
}

void WebServer::noRobots(ConnectionType type)
{
   d4664:	b538      	push	{r3, r4, r5, lr}
  httpSuccess("text/plain");
   d4666:	2200      	movs	r2, #0
{
  server.httpFail();
}

void WebServer::noRobots(ConnectionType type)
{
   d4668:	460d      	mov	r5, r1
  httpSuccess("text/plain");
   d466a:	4906      	ldr	r1, [pc, #24]	; (d4684 <_ZN9WebServer8noRobotsENS_14ConnectionTypeE+0x20>)
{
  server.httpFail();
}

void WebServer::noRobots(ConnectionType type)
{
   d466c:	4604      	mov	r4, r0
  httpSuccess("text/plain");
   d466e:	f7ff ffcf 	bl	d4610 <_ZN9WebServer11httpSuccessEPKcS1_>
  if (type != HEAD)
   d4672:	2d02      	cmp	r5, #2
   d4674:	d005      	beq.n	d4682 <_ZN9WebServer8noRobotsENS_14ConnectionTypeE+0x1e>
  {
    P(allowNoneMsg) = "User-agent: *" CRLF "Disallow: /" CRLF;
    printP(allowNoneMsg);
   d4676:	4620      	mov	r0, r4
   d4678:	4903      	ldr	r1, [pc, #12]	; (d4688 <_ZN9WebServer8noRobotsENS_14ConnectionTypeE+0x24>)
  }
}
   d467a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
{
  httpSuccess("text/plain");
  if (type != HEAD)
  {
    P(allowNoneMsg) = "User-agent: *" CRLF "Disallow: /" CRLF;
    printP(allowNoneMsg);
   d467e:	f7ff bf08 	b.w	d4492 <_ZN9WebServer6printPEPKh>
   d4682:	bd38      	pop	{r3, r4, r5, pc}
   d4684:	000da1f5 	.word	0x000da1f5
   d4688:	000d95af 	.word	0x000d95af

000d468c <_ZN9WebServer7faviconENS_14ConnectionTypeE>:
  }
}

void WebServer::favicon(ConnectionType type)
{
   d468c:	b538      	push	{r3, r4, r5, lr}
  httpSuccess("image/x-icon","Cache-Control: max-age=31536000");
   d468e:	4a08      	ldr	r2, [pc, #32]	; (d46b0 <_ZN9WebServer7faviconENS_14ConnectionTypeE+0x24>)
    printP(allowNoneMsg);
  }
}

void WebServer::favicon(ConnectionType type)
{
   d4690:	460d      	mov	r5, r1
  httpSuccess("image/x-icon","Cache-Control: max-age=31536000");
   d4692:	4908      	ldr	r1, [pc, #32]	; (d46b4 <_ZN9WebServer7faviconENS_14ConnectionTypeE+0x28>)
    printP(allowNoneMsg);
  }
}

void WebServer::favicon(ConnectionType type)
{
   d4694:	4604      	mov	r4, r0
  httpSuccess("image/x-icon","Cache-Control: max-age=31536000");
   d4696:	f7ff ffbb 	bl	d4610 <_ZN9WebServer11httpSuccessEPKcS1_>
  if (type != HEAD)
   d469a:	2d02      	cmp	r5, #2
   d469c:	d006      	beq.n	d46ac <_ZN9WebServer7faviconENS_14ConnectionTypeE+0x20>
  {
    P(faviconIco) = WEBDUINO_FAVICON_DATA;
    writeP(faviconIco, sizeof(faviconIco));
   d469e:	4620      	mov	r0, r4
   d46a0:	22c6      	movs	r2, #198	; 0xc6
   d46a2:	4905      	ldr	r1, [pc, #20]	; (d46b8 <_ZN9WebServer7faviconENS_14ConnectionTypeE+0x2c>)
  }
}
   d46a4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
{
  httpSuccess("image/x-icon","Cache-Control: max-age=31536000");
  if (type != HEAD)
  {
    P(faviconIco) = WEBDUINO_FAVICON_DATA;
    writeP(faviconIco, sizeof(faviconIco));
   d46a8:	f7ff bee4 	b.w	d4474 <_ZN9WebServer6writePEPKhj>
   d46ac:	bd38      	pop	{r3, r4, r5, pc}
   d46ae:	bf00      	nop
   d46b0:	000da200 	.word	0x000da200
   d46b4:	000da220 	.word	0x000da220
   d46b8:	000d94d1 	.word	0x000d94d1

000d46bc <_ZN9WebServer4pushEi>:
}

void WebServer::push(int ch)
{
  // don't allow pushing EOF
  if (ch == -1)
   d46bc:	1c4b      	adds	r3, r1, #1
   d46be:	d00e      	beq.n	d46de <_ZN9WebServer4pushEi+0x22>
    return;

  m_pushback[m_pushbackDepth++] = ch;
   d46c0:	f890 2078 	ldrb.w	r2, [r0, #120]	; 0x78
   d46c4:	1c53      	adds	r3, r2, #1
   d46c6:	b2db      	uxtb	r3, r3
  // can't raise error here, so just replace last char over and over
  if (m_pushbackDepth == SIZE(m_pushback))
   d46c8:	2b20      	cmp	r3, #32
{
  // don't allow pushing EOF
  if (ch == -1)
    return;

  m_pushback[m_pushbackDepth++] = ch;
   d46ca:	4402      	add	r2, r0
   d46cc:	f880 3078 	strb.w	r3, [r0, #120]	; 0x78
  // can't raise error here, so just replace last char over and over
  if (m_pushbackDepth == SIZE(m_pushback))
    m_pushbackDepth = SIZE(m_pushback) - 1;
   d46d0:	bf08      	it	eq
   d46d2:	231f      	moveq	r3, #31
{
  // don't allow pushing EOF
  if (ch == -1)
    return;

  m_pushback[m_pushbackDepth++] = ch;
   d46d4:	f882 1058 	strb.w	r1, [r2, #88]	; 0x58
  // can't raise error here, so just replace last char over and over
  if (m_pushbackDepth == SIZE(m_pushback))
    m_pushbackDepth = SIZE(m_pushback) - 1;
   d46d8:	bf08      	it	eq
   d46da:	f880 3078 	strbeq.w	r3, [r0, #120]	; 0x78
   d46de:	4770      	bx	lr

000d46e0 <_ZN9WebServer5resetEv>:
}

void WebServer::reset()
{
   d46e0:	b510      	push	{r4, lr}
  m_pushbackDepth = 0;
   d46e2:	2300      	movs	r3, #0
  m_client.flush();
   d46e4:	f100 0438 	add.w	r4, r0, #56	; 0x38
    m_pushbackDepth = SIZE(m_pushback) - 1;
}

void WebServer::reset()
{
  m_pushbackDepth = 0;
   d46e8:	f880 3078 	strb.w	r3, [r0, #120]	; 0x78
  m_client.flush();
   d46ec:	4620      	mov	r0, r4
   d46ee:	f002 fdd5 	bl	d729c <_ZN9TCPClient5flushEv>
  m_client.stop();
   d46f2:	4620      	mov	r0, r4
}
   d46f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void WebServer::reset()
{
  m_pushbackDepth = 0;
  m_client.flush();
  m_client.stop();
   d46f8:	f002 bfa4 	b.w	d7644 <_ZN9TCPClient4stopEv>

000d46fc <_ZN9WebServer4readEv>:
  printCRLF();
  printCRLF();
}

int WebServer::read()
{
   d46fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (!m_client)
   d46fe:	f100 0638 	add.w	r6, r0, #56	; 0x38
  printCRLF();
  printCRLF();
}

int WebServer::read()
{
   d4702:	4605      	mov	r5, r0
  if (!m_client)
   d4704:	4630      	mov	r0, r6
   d4706:	f002 fde6 	bl	d72d6 <_ZN9TCPClientcvbEv>
   d470a:	b910      	cbnz	r0, d4712 <_ZN9WebServer4readEv+0x16>
    return -1;
   d470c:	f04f 30ff 	mov.w	r0, #4294967295
   d4710:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  if (m_pushbackDepth == 0)
   d4712:	f895 3078 	ldrb.w	r3, [r5, #120]	; 0x78
   d4716:	bb1b      	cbnz	r3, d4760 <_ZN9WebServer4readEv+0x64>

#ifdef __cplusplus
extern "C" {
#endif

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
   d4718:	f001 faa0 	bl	d5c5c <HAL_Timer_Get_Milli_Seconds>
  {
    unsigned long timeoutTime = millis() + WEBDUINO_READ_TIMEOUT_IN_MS;
   d471c:	f500 777a 	add.w	r7, r0, #1000	; 0x3e8

    while (m_client.connected())
   d4720:	4630      	mov	r0, r6
   d4722:	f002 fdbc 	bl	d729e <_ZN9TCPClient9connectedEv>
   d4726:	2800      	cmp	r0, #0
   d4728:	d0f0      	beq.n	d470c <_ZN9WebServer4readEv+0x10>
    {
      // stop reading the socket early if we get to content-length
      // characters in the POST.  This is because some clients leave
      // the socket open because they assume HTTP keep-alive.
      if (m_readingContent)
   d472a:	f895 30b3 	ldrb.w	r3, [r5, #179]	; 0xb3
   d472e:	b113      	cbz	r3, d4736 <_ZN9WebServer4readEv+0x3a>
      {
        if (m_contentLength == 0)
   d4730:	6feb      	ldr	r3, [r5, #124]	; 0x7c
   d4732:	2b00      	cmp	r3, #0
   d4734:	d0ea      	beq.n	d470c <_ZN9WebServer4readEv+0x10>
#endif
          return -1;
        }
      }

      int ch = m_client.read();
   d4736:	4630      	mov	r0, r6
   d4738:	f002 fe45 	bl	d73c6 <_ZN9TCPClient4readEv>

      // if we get a character, return it, otherwise continue in while
      // loop, checking connection status
      if (ch != -1)
   d473c:	1c43      	adds	r3, r0, #1
#endif
          return -1;
        }
      }

      int ch = m_client.read();
   d473e:	4604      	mov	r4, r0

      // if we get a character, return it, otherwise continue in while
      // loop, checking connection status
      if (ch != -1)
   d4740:	d006      	beq.n	d4750 <_ZN9WebServer4readEv+0x54>
      {
        // count character against content-length
        if (m_readingContent)
   d4742:	f895 30b3 	ldrb.w	r3, [r5, #179]	; 0xb3
   d4746:	b19b      	cbz	r3, d4770 <_ZN9WebServer4readEv+0x74>
        {
          --m_contentLength;
   d4748:	6feb      	ldr	r3, [r5, #124]	; 0x7c
   d474a:	3b01      	subs	r3, #1
   d474c:	67eb      	str	r3, [r5, #124]	; 0x7c
   d474e:	e00f      	b.n	d4770 <_ZN9WebServer4readEv+0x74>
   d4750:	f001 fa84 	bl	d5c5c <HAL_Timer_Get_Milli_Seconds>
        return ch;
      }
      else
      {
        unsigned long now = millis();
        if (now > timeoutTime)
   d4754:	42b8      	cmp	r0, r7
   d4756:	d9e3      	bls.n	d4720 <_ZN9WebServer4readEv+0x24>
        {
          // connection timed out, destroy client, return EOF
#if WEBDUINO_SERIAL_DEBUGGING
          Serial.println("*** Connection timed out");
#endif
          reset();
   d4758:	4628      	mov	r0, r5
   d475a:	f7ff ffc1 	bl	d46e0 <_ZN9WebServer5resetEv>
   d475e:	e007      	b.n	d4770 <_ZN9WebServer4readEv+0x74>
    Serial.println("*** Connection lost");
#endif
    return -1;
  }
  else
    return m_pushback[--m_pushbackDepth];
   d4760:	3b01      	subs	r3, #1
   d4762:	b2db      	uxtb	r3, r3
   d4764:	f885 3078 	strb.w	r3, [r5, #120]	; 0x78
   d4768:	441d      	add	r5, r3
   d476a:	f895 0058 	ldrb.w	r0, [r5, #88]	; 0x58
   d476e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
#endif
          return -1;
        }
      }

      int ch = m_client.read();
   d4770:	4620      	mov	r0, r4
#endif
    return -1;
  }
  else
    return m_pushback[--m_pushbackDepth];
}
   d4772:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000d4774 <_ZN9WebServer6expectEPKc>:
  m_client.flush();
  m_client.stop();
}

bool WebServer::expect(const char *str)
{
   d4774:	b570      	push	{r4, r5, r6, lr}
   d4776:	4605      	mov	r5, r0
   d4778:	460e      	mov	r6, r1
  const char *curr = str;
   d477a:	460c      	mov	r4, r1
  while (*curr != 0)
   d477c:	7823      	ldrb	r3, [r4, #0]
   d477e:	b19b      	cbz	r3, d47a8 <_ZN9WebServer6expectEPKc+0x34>
  {
    int ch = read();
   d4780:	4628      	mov	r0, r5
   d4782:	f7ff ffbb 	bl	d46fc <_ZN9WebServer4readEv>
    if (ch != *curr++)
   d4786:	f814 3b01 	ldrb.w	r3, [r4], #1
   d478a:	4298      	cmp	r0, r3
bool WebServer::expect(const char *str)
{
  const char *curr = str;
  while (*curr != 0)
  {
    int ch = read();
   d478c:	4601      	mov	r1, r0
    if (ch != *curr++)
   d478e:	d0f5      	beq.n	d477c <_ZN9WebServer6expectEPKc+0x8>
    {
      // push back ch and the characters we accepted
      push(ch);
   d4790:	4628      	mov	r0, r5
   d4792:	f7ff ff93 	bl	d46bc <_ZN9WebServer4pushEi>
   d4796:	3c01      	subs	r4, #1
      while (--curr != str)
   d4798:	42b4      	cmp	r4, r6
   d479a:	d007      	beq.n	d47ac <_ZN9WebServer6expectEPKc+0x38>
        push(curr[-1]);
   d479c:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
   d47a0:	4628      	mov	r0, r5
   d47a2:	f7ff ff8b 	bl	d46bc <_ZN9WebServer4pushEi>
    int ch = read();
    if (ch != *curr++)
    {
      // push back ch and the characters we accepted
      push(ch);
      while (--curr != str)
   d47a6:	e7f7      	b.n	d4798 <_ZN9WebServer6expectEPKc+0x24>
        push(curr[-1]);
      return false;
    }
  }
  return true;
   d47a8:	2001      	movs	r0, #1
   d47aa:	bd70      	pop	{r4, r5, r6, pc}
    {
      // push back ch and the characters we accepted
      push(ch);
      while (--curr != str)
        push(curr[-1]);
      return false;
   d47ac:	2000      	movs	r0, #0
    }
  }
  return true;
}
   d47ae:	bd70      	pop	{r4, r5, r6, pc}

000d47b0 <_ZN9WebServer7readIntERi>:
bool WebServer::readInt(int &number)
{
  bool negate = false;
  bool gotNumber = false;
  int ch;
  number = 0;
   d47b0:	2300      	movs	r3, #0
  }
  return true;
}

bool WebServer::readInt(int &number)
{
   d47b2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   d47b6:	4605      	mov	r5, r0
   d47b8:	460c      	mov	r4, r1
  bool negate = false;
  bool gotNumber = false;
  int ch;
  number = 0;
   d47ba:	600b      	str	r3, [r1, #0]

  // absorb whitespace
  do
  {
    ch = read();
   d47bc:	4628      	mov	r0, r5
   d47be:	f7ff ff9d 	bl	d46fc <_ZN9WebServer4readEv>
  } while (ch == ' ' || ch == '\t');
   d47c2:	2820      	cmp	r0, #32
   d47c4:	d0fa      	beq.n	d47bc <_ZN9WebServer7readIntERi+0xc>
   d47c6:	2809      	cmp	r0, #9
   d47c8:	d0f8      	beq.n	d47bc <_ZN9WebServer7readIntERi+0xc>

  // check for leading minus sign
  if (ch == '-')
   d47ca:	282d      	cmp	r0, #45	; 0x2d
   d47cc:	d104      	bne.n	d47d8 <_ZN9WebServer7readIntERi+0x28>
  {
    negate = true;
    ch = read();
   d47ce:	4628      	mov	r0, r5
   d47d0:	f7ff ff94 	bl	d46fc <_ZN9WebServer4readEv>
  } while (ch == ' ' || ch == '\t');

  // check for leading minus sign
  if (ch == '-')
  {
    negate = true;
   d47d4:	2701      	movs	r7, #1
   d47d6:	e000      	b.n	d47da <_ZN9WebServer7readIntERi+0x2a>
  return true;
}

bool WebServer::readInt(int &number)
{
  bool negate = false;
   d47d8:	2700      	movs	r7, #0
  } while (ch == ' ' || ch == '\t');

  // check for leading minus sign
  if (ch == '-')
  {
    negate = true;
   d47da:	2600      	movs	r6, #0

  // read digits to update number, exit when we find non-digit
  while (ch >= '0' && ch <= '9')
  {
    gotNumber = true;
    number = number * 10 + ch - '0';
   d47dc:	f04f 080a 	mov.w	r8, #10
    negate = true;
    ch = read();
  }

  // read digits to update number, exit when we find non-digit
  while (ch >= '0' && ch <= '9')
   d47e0:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
   d47e4:	2b09      	cmp	r3, #9
   d47e6:	d809      	bhi.n	d47fc <_ZN9WebServer7readIntERi+0x4c>
  {
    gotNumber = true;
    number = number * 10 + ch - '0';
   d47e8:	6823      	ldr	r3, [r4, #0]
   d47ea:	fb08 0003 	mla	r0, r8, r3, r0
   d47ee:	3830      	subs	r0, #48	; 0x30
   d47f0:	6020      	str	r0, [r4, #0]
    ch = read();
   d47f2:	4628      	mov	r0, r5
   d47f4:	f7ff ff82 	bl	d46fc <_ZN9WebServer4readEv>
  }

  // read digits to update number, exit when we find non-digit
  while (ch >= '0' && ch <= '9')
  {
    gotNumber = true;
   d47f8:	2601      	movs	r6, #1
    negate = true;
    ch = read();
  }

  // read digits to update number, exit when we find non-digit
  while (ch >= '0' && ch <= '9')
   d47fa:	e7f1      	b.n	d47e0 <_ZN9WebServer7readIntERi+0x30>
    gotNumber = true;
    number = number * 10 + ch - '0';
    ch = read();
  }

  push(ch);
   d47fc:	4601      	mov	r1, r0
   d47fe:	4628      	mov	r0, r5
   d4800:	f7ff ff5c 	bl	d46bc <_ZN9WebServer4pushEi>
  if (negate)
   d4804:	b117      	cbz	r7, d480c <_ZN9WebServer7readIntERi+0x5c>
    number = -number;
   d4806:	6823      	ldr	r3, [r4, #0]
   d4808:	425b      	negs	r3, r3
   d480a:	6023      	str	r3, [r4, #0]
  return gotNumber;
}
   d480c:	4630      	mov	r0, r6
   d480e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000d4812 <_ZN9WebServer10readHeaderEPci>:

void WebServer::readHeader(char *value, int valueLen)
{
   d4812:	b570      	push	{r4, r5, r6, lr}
   d4814:	460d      	mov	r5, r1
   d4816:	4606      	mov	r6, r0
  int ch;
  memset(value, 0, valueLen);
   d4818:	2100      	movs	r1, #0
   d481a:	4628      	mov	r0, r5
    number = -number;
  return gotNumber;
}

void WebServer::readHeader(char *value, int valueLen)
{
   d481c:	4614      	mov	r4, r2
  int ch;
  memset(value, 0, valueLen);
   d481e:	f003 fc20 	bl	d8062 <memset>
  --valueLen;
   d4822:	3c01      	subs	r4, #1

  // absorb whitespace
  do
  {
    ch = read();
   d4824:	4630      	mov	r0, r6
   d4826:	f7ff ff69 	bl	d46fc <_ZN9WebServer4readEv>
  } while (ch == ' ' || ch == '\t');
   d482a:	2820      	cmp	r0, #32
   d482c:	d0fa      	beq.n	d4824 <_ZN9WebServer10readHeaderEPci+0x12>
   d482e:	2809      	cmp	r0, #9
   d4830:	d0f8      	beq.n	d4824 <_ZN9WebServer10readHeaderEPci+0x12>

  // read rest of line
  do
  {
    if (valueLen > 1)
   d4832:	2c01      	cmp	r4, #1
    {
      *value++=ch;
   d4834:	bfc8      	it	gt
   d4836:	7028      	strbgt	r0, [r5, #0]
      --valueLen;
    }
    ch = read();
   d4838:	4630      	mov	r0, r6
  do
  {
    if (valueLen > 1)
    {
      *value++=ch;
      --valueLen;
   d483a:	bfc4      	itt	gt
   d483c:	f104 34ff 	addgt.w	r4, r4, #4294967295
  // read rest of line
  do
  {
    if (valueLen > 1)
    {
      *value++=ch;
   d4840:	3501      	addgt	r5, #1
      --valueLen;
    }
    ch = read();
   d4842:	f7ff ff5b 	bl	d46fc <_ZN9WebServer4readEv>
  } while (ch != '\r');
   d4846:	280d      	cmp	r0, #13
   d4848:	d1f3      	bne.n	d4832 <_ZN9WebServer10readHeaderEPci+0x20>
  push(ch);
   d484a:	4601      	mov	r1, r0
   d484c:	4630      	mov	r0, r6
}
   d484e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      *value++=ch;
      --valueLen;
    }
    ch = read();
  } while (ch != '\r');
  push(ch);
   d4852:	f7ff bf33 	b.w	d46bc <_ZN9WebServer4pushEi>

000d4856 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i>:
/* Retrieve a parameter that was encoded as part of the URL, stored in
 * the buffer pointed to by *tail.  tail is updated to point just past
 * the last character read from the buffer. */
URLPARAM_RESULT WebServer::nextURLparam(char **tail, char *name, int nameLen,
                                        char *value, int valueLen)
{
   d4856:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   d485a:	b085      	sub	sp, #20
   d485c:	4691      	mov	r9, r2
   d485e:	9f0e      	ldr	r7, [sp, #56]	; 0x38
   d4860:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
  // assume name is at current place in stream
  char ch, hex[3];
  URLPARAM_RESULT result = URLPARAM_OK;
  char *s = *tail;
   d4864:	680d      	ldr	r5, [r1, #0]
  bool keep_scanning = true;
  bool need_value = true;

  // clear out name and value so they'll be NUL terminated
  memset(name, 0, nameLen);
   d4866:	461a      	mov	r2, r3
/* Retrieve a parameter that was encoded as part of the URL, stored in
 * the buffer pointed to by *tail.  tail is updated to point just past
 * the last character read from the buffer. */
URLPARAM_RESULT WebServer::nextURLparam(char **tail, char *name, int nameLen,
                                        char *value, int valueLen)
{
   d4868:	468a      	mov	sl, r1
  char *s = *tail;
  bool keep_scanning = true;
  bool need_value = true;

  // clear out name and value so they'll be NUL terminated
  memset(name, 0, nameLen);
   d486a:	4648      	mov	r0, r9
   d486c:	2100      	movs	r1, #0
/* Retrieve a parameter that was encoded as part of the URL, stored in
 * the buffer pointed to by *tail.  tail is updated to point just past
 * the last character read from the buffer. */
URLPARAM_RESULT WebServer::nextURLparam(char **tail, char *name, int nameLen,
                                        char *value, int valueLen)
{
   d486e:	469b      	mov	fp, r3
  char *s = *tail;
  bool keep_scanning = true;
  bool need_value = true;

  // clear out name and value so they'll be NUL terminated
  memset(name, 0, nameLen);
   d4870:	f003 fbf7 	bl	d8062 <memset>
  memset(value, 0, valueLen);
   d4874:	4642      	mov	r2, r8
   d4876:	2100      	movs	r1, #0
   d4878:	4638      	mov	r0, r7
   d487a:	f003 fbf2 	bl	d8062 <memset>

  if (*s == 0)
   d487e:	782b      	ldrb	r3, [r5, #0]
   d4880:	2b00      	cmp	r3, #0
   d4882:	d054      	beq.n	d492e <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xd8>
   d4884:	2600      	movs	r6, #0
          keep_scanning = false;
          need_value = false;
        }
        else
        {
          hex[2] = 0;
   d4886:	4633      	mov	r3, r6
  if (*s == 0)
    return URLPARAM_EOS;
  // Read the keyword name
  while (keep_scanning)
  {
    ch = *s++;
   d4888:	7828      	ldrb	r0, [r5, #0]
    switch (ch)
   d488a:	2826      	cmp	r0, #38	; 0x26
  if (*s == 0)
    return URLPARAM_EOS;
  // Read the keyword name
  while (keep_scanning)
  {
    ch = *s++;
   d488c:	f105 0401 	add.w	r4, r5, #1
    switch (ch)
   d4890:	d049      	beq.n	d4926 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xd0>
   d4892:	d804      	bhi.n	d489e <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0x48>
   d4894:	2800      	cmp	r0, #0
   d4896:	d045      	beq.n	d4924 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xce>
   d4898:	2825      	cmp	r0, #37	; 0x25
   d489a:	d005      	beq.n	d48a8 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0x52>
   d489c:	e04a      	b.n	d4934 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xde>
   d489e:	282b      	cmp	r0, #43	; 0x2b
   d48a0:	d047      	beq.n	d4932 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xdc>
   d48a2:	283d      	cmp	r0, #61	; 0x3d
   d48a4:	d017      	beq.n	d48d6 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0x80>
   d48a6:	e045      	b.n	d4934 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xde>
      ch = ' ';
      break;
    case '%':
      /* handle URL encoded characters by converting back
       * to original form */
      if ((hex[0] = *s++) == 0)
   d48a8:	786a      	ldrb	r2, [r5, #1]
   d48aa:	f88d 200c 	strb.w	r2, [sp, #12]
   d48ae:	2a00      	cmp	r2, #0
   d48b0:	d039      	beq.n	d4926 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xd0>
        keep_scanning = false;
        need_value = false;
      }
      else
      {
        if ((hex[1] = *s++) == 0)
   d48b2:	78aa      	ldrb	r2, [r5, #2]
   d48b4:	f88d 200d 	strb.w	r2, [sp, #13]
   d48b8:	b90a      	cbnz	r2, d48be <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0x68>
        {
          s--;  // Back up to NUL
   d48ba:	1cac      	adds	r4, r5, #2
   d48bc:	e033      	b.n	d4926 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xd0>
          need_value = false;
        }
        else
        {
          hex[2] = 0;
          ch = strtoul(hex, NULL, 16);
   d48be:	2210      	movs	r2, #16
   d48c0:	2100      	movs	r1, #0
   d48c2:	a803      	add	r0, sp, #12
          keep_scanning = false;
          need_value = false;
        }
        else
        {
          hex[2] = 0;
   d48c4:	f88d 300e 	strb.w	r3, [sp, #14]
   d48c8:	9301      	str	r3, [sp, #4]
          ch = strtoul(hex, NULL, 16);
   d48ca:	f004 fa6d 	bl	d8da8 <strtoul>
        keep_scanning = false;
        need_value = false;
      }
      else
      {
        if ((hex[1] = *s++) == 0)
   d48ce:	1cec      	adds	r4, r5, #3
          need_value = false;
        }
        else
        {
          hex[2] = 0;
          ch = strtoul(hex, NULL, 16);
   d48d0:	b2c0      	uxtb	r0, r0
   d48d2:	9b01      	ldr	r3, [sp, #4]
   d48d4:	e02e      	b.n	d4934 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xde>
    }
    else if(keep_scanning)
      result = URLPARAM_NAME_OFLO;
  }

  if (need_value && (*s != 0))
   d48d6:	786b      	ldrb	r3, [r5, #1]
   d48d8:	b32b      	cbz	r3, d4926 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xd0>
   d48da:	4623      	mov	r3, r4
            keep_scanning = false;
            need_value = false;
          }
          else
          {
            hex[2] = 0;
   d48dc:	2500      	movs	r5, #0
  if (need_value && (*s != 0))
  {
    keep_scanning = true;
    while (keep_scanning)
    {
      ch = *s++;
   d48de:	7818      	ldrb	r0, [r3, #0]
      switch (ch)
   d48e0:	2825      	cmp	r0, #37	; 0x25
  if (need_value && (*s != 0))
  {
    keep_scanning = true;
    while (keep_scanning)
    {
      ch = *s++;
   d48e2:	f104 0401 	add.w	r4, r4, #1
      switch (ch)
   d48e6:	d009      	beq.n	d48fc <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xa6>
   d48e8:	d802      	bhi.n	d48f0 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0x9a>
   d48ea:	bb78      	cbnz	r0, d494c <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xf6>
   d48ec:	461c      	mov	r4, r3
   d48ee:	e01a      	b.n	d4926 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xd0>
   d48f0:	2826      	cmp	r0, #38	; 0x26
   d48f2:	d018      	beq.n	d4926 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xd0>
        /* that's end of pair, go away */
        keep_scanning = false;
        need_value = false;
        break;
      case '+':
        ch = ' ';
   d48f4:	282b      	cmp	r0, #43	; 0x2b
   d48f6:	bf08      	it	eq
   d48f8:	2020      	moveq	r0, #32
   d48fa:	e027      	b.n	d494c <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xf6>
        break;
      case '%':
        /* handle URL encoded characters by converting back to original form */
        if ((hex[0] = *s++) == 0)
   d48fc:	785a      	ldrb	r2, [r3, #1]
   d48fe:	f88d 200c 	strb.w	r2, [sp, #12]
   d4902:	b182      	cbz	r2, d4926 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xd0>
          keep_scanning = false;
          need_value = false;
        }
        else
        {
          if ((hex[1] = *s++) == 0)
   d4904:	789a      	ldrb	r2, [r3, #2]
   d4906:	f88d 200d 	strb.w	r2, [sp, #13]
   d490a:	b90a      	cbnz	r2, d4910 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xba>
          {
            s--;  // Back up to NUL
   d490c:	1c9c      	adds	r4, r3, #2
   d490e:	e00a      	b.n	d4926 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xd0>
            need_value = false;
          }
          else
          {
            hex[2] = 0;
            ch = strtoul(hex, NULL, 16);
   d4910:	2210      	movs	r2, #16
   d4912:	2100      	movs	r1, #0
   d4914:	a803      	add	r0, sp, #12
          keep_scanning = false;
          need_value = false;
        }
        else
        {
          if ((hex[1] = *s++) == 0)
   d4916:	1cdc      	adds	r4, r3, #3
            keep_scanning = false;
            need_value = false;
          }
          else
          {
            hex[2] = 0;
   d4918:	f88d 500e 	strb.w	r5, [sp, #14]
            ch = strtoul(hex, NULL, 16);
   d491c:	f004 fa44 	bl	d8da8 <strtoul>
   d4920:	b2c0      	uxtb	r0, r0
   d4922:	e013      	b.n	d494c <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xf6>
    return URLPARAM_EOS;
  // Read the keyword name
  while (keep_scanning)
  {
    ch = *s++;
    switch (ch)
   d4924:	462c      	mov	r4, r5
        result = (result == URLPARAM_OK) ?
          URLPARAM_VALUE_OFLO :
          URLPARAM_BOTH_OFLO;
    }
  }
  *tail = s;
   d4926:	f8ca 4000 	str.w	r4, [sl]
  return result;
   d492a:	4630      	mov	r0, r6
   d492c:	e01f      	b.n	d496e <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0x118>
  // clear out name and value so they'll be NUL terminated
  memset(name, 0, nameLen);
  memset(value, 0, valueLen);

  if (*s == 0)
    return URLPARAM_EOS;
   d492e:	2004      	movs	r0, #4
   d4930:	e01d      	b.n	d496e <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0x118>
      /* that's end of pair, go away */
      keep_scanning = false;
      need_value = false;
      break;
    case '+':
      ch = ' ';
   d4932:	2020      	movs	r0, #32
      break;
    }


    // check against 1 so we don't overwrite the final NUL
    if (keep_scanning && (nameLen > 1))
   d4934:	f1bb 0f01 	cmp.w	fp, #1
   d4938:	dd06      	ble.n	d4948 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0xf2>
    {
      *name++ = ch;
   d493a:	f889 0000 	strb.w	r0, [r9]
      --nameLen;
   d493e:	f10b 3bff 	add.w	fp, fp, #4294967295


    // check against 1 so we don't overwrite the final NUL
    if (keep_scanning && (nameLen > 1))
    {
      *name++ = ch;
   d4942:	f109 0901 	add.w	r9, r9, #1
      --nameLen;
   d4946:	e00e      	b.n	d4966 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0x110>
    }
    else if(keep_scanning)
      result = URLPARAM_NAME_OFLO;
   d4948:	2601      	movs	r6, #1
   d494a:	e00c      	b.n	d4966 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0x110>
        break;
      }


      // check against 1 so we don't overwrite the final NUL
      if (keep_scanning && (valueLen > 1))
   d494c:	f1b8 0f01 	cmp.w	r8, #1
   d4950:	dd04      	ble.n	d495c <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0x106>
      {
        *value++ = ch;
   d4952:	7038      	strb	r0, [r7, #0]
        --valueLen;
   d4954:	f108 38ff 	add.w	r8, r8, #4294967295


      // check against 1 so we don't overwrite the final NUL
      if (keep_scanning && (valueLen > 1))
      {
        *value++ = ch;
   d4958:	3701      	adds	r7, #1
        --valueLen;
   d495a:	e006      	b.n	d496a <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0x114>
      }
      else if(keep_scanning)
        result = (result == URLPARAM_OK) ?
          URLPARAM_VALUE_OFLO :
          URLPARAM_BOTH_OFLO;
   d495c:	2e00      	cmp	r6, #0
   d495e:	bf0c      	ite	eq
   d4960:	2602      	moveq	r6, #2
   d4962:	2603      	movne	r6, #3
   d4964:	e001      	b.n	d496a <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0x114>
   d4966:	4625      	mov	r5, r4
   d4968:	e78e      	b.n	d4888 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0x32>
    }
    else if(keep_scanning)
      result = URLPARAM_NAME_OFLO;
  }

  if (need_value && (*s != 0))
   d496a:	4623      	mov	r3, r4
   d496c:	e7b7      	b.n	d48de <_ZN9WebServer12nextURLparamEPPcS0_iS0_i+0x88>
          URLPARAM_BOTH_OFLO;
    }
  }
  *tail = s;
  return result;
}
   d496e:	b005      	add	sp, #20
   d4970:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000d4974 <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi>:
// less than 0,  the URL was longer than the buffer,  and part of it had to
// be discarded.

void WebServer::getRequest(WebServer::ConnectionType &type,
                           char *request, int *length)
{
   d4974:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   d4976:	461e      	mov	r6, r3
  --*length; // save room for NUL
   d4978:	681b      	ldr	r3, [r3, #0]
   d497a:	3b01      	subs	r3, #1
   d497c:	6033      	str	r3, [r6, #0]

  type = INVALID;
   d497e:	2300      	movs	r3, #0
// less than 0,  the URL was longer than the buffer,  and part of it had to
// be discarded.

void WebServer::getRequest(WebServer::ConnectionType &type,
                           char *request, int *length)
{
   d4980:	460c      	mov	r4, r1
  --*length; // save room for NUL

  type = INVALID;
   d4982:	700b      	strb	r3, [r1, #0]

  // store the HTTP method line of the request
  if (expect("GET "))
   d4984:	4922      	ldr	r1, [pc, #136]	; (d4a10 <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0x9c>)
// less than 0,  the URL was longer than the buffer,  and part of it had to
// be discarded.

void WebServer::getRequest(WebServer::ConnectionType &type,
                           char *request, int *length)
{
   d4986:	4605      	mov	r5, r0
   d4988:	4617      	mov	r7, r2
  --*length; // save room for NUL

  type = INVALID;

  // store the HTTP method line of the request
  if (expect("GET "))
   d498a:	f7ff fef3 	bl	d4774 <_ZN9WebServer6expectEPKc>
   d498e:	b108      	cbz	r0, d4994 <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0x20>
    type = GET;
   d4990:	2301      	movs	r3, #1
   d4992:	e00c      	b.n	d49ae <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0x3a>
  else if (expect("HEAD "))
   d4994:	491f      	ldr	r1, [pc, #124]	; (d4a14 <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0xa0>)
   d4996:	4628      	mov	r0, r5
   d4998:	f7ff feec 	bl	d4774 <_ZN9WebServer6expectEPKc>
   d499c:	b108      	cbz	r0, d49a2 <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0x2e>
    type = HEAD;
   d499e:	2302      	movs	r3, #2
   d49a0:	e005      	b.n	d49ae <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0x3a>
  else if (expect("POST "))
   d49a2:	491d      	ldr	r1, [pc, #116]	; (d4a18 <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0xa4>)
   d49a4:	4628      	mov	r0, r5
   d49a6:	f7ff fee5 	bl	d4774 <_ZN9WebServer6expectEPKc>
   d49aa:	b120      	cbz	r0, d49b6 <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0x42>
    type = POST;
   d49ac:	2303      	movs	r3, #3
   d49ae:	7023      	strb	r3, [r4, #0]
  // so just get out of here
  else
    return;

  int ch;
  while ((ch = read()) != -1)
   d49b0:	f644 0401 	movw	r4, #18433	; 0x4801
   d49b4:	e020      	b.n	d49f8 <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0x84>
    type = GET;
  else if (expect("HEAD "))
    type = HEAD;
  else if (expect("POST "))
    type = POST;
  else if (expect("PUT "))
   d49b6:	4919      	ldr	r1, [pc, #100]	; (d4a1c <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0xa8>)
   d49b8:	4628      	mov	r0, r5
   d49ba:	f7ff fedb 	bl	d4774 <_ZN9WebServer6expectEPKc>
   d49be:	b108      	cbz	r0, d49c4 <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0x50>
    type = PUT;
   d49c0:	2304      	movs	r3, #4
   d49c2:	e7f4      	b.n	d49ae <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0x3a>
  else if (expect("DELETE "))
   d49c4:	4916      	ldr	r1, [pc, #88]	; (d4a20 <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0xac>)
   d49c6:	4628      	mov	r0, r5
   d49c8:	f7ff fed4 	bl	d4774 <_ZN9WebServer6expectEPKc>
   d49cc:	b108      	cbz	r0, d49d2 <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0x5e>
    type = DELETE;
   d49ce:	2305      	movs	r3, #5
   d49d0:	e7ed      	b.n	d49ae <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0x3a>
  else if (expect("PATCH "))
   d49d2:	4914      	ldr	r1, [pc, #80]	; (d4a24 <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0xb0>)
   d49d4:	4628      	mov	r0, r5
   d49d6:	f7ff fecd 	bl	d4774 <_ZN9WebServer6expectEPKc>
   d49da:	b1c0      	cbz	r0, d4a0e <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0x9a>
    type = PATCH;
   d49dc:	2306      	movs	r3, #6
   d49de:	e7e6      	b.n	d49ae <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0x3a>
  // so just get out of here
  else
    return;

  int ch;
  while ((ch = read()) != -1)
   d49e0:	fa24 f303 	lsr.w	r3, r4, r3
   d49e4:	07db      	lsls	r3, r3, #31
   d49e6:	d40f      	bmi.n	d4a08 <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0x94>
    // stop storing at first space or end of line
    if (ch == ' ' || ch == '\n' || ch == '\r')
    {
      break;
    }
    if (*length > 0)
   d49e8:	6833      	ldr	r3, [r6, #0]
   d49ea:	2b00      	cmp	r3, #0
    {
      *request = ch;
   d49ec:	bfc8      	it	gt
   d49ee:	f807 0b01 	strbgt.w	r0, [r7], #1
      ++request;
    }
    --*length;
   d49f2:	6833      	ldr	r3, [r6, #0]
   d49f4:	3b01      	subs	r3, #1
   d49f6:	6033      	str	r3, [r6, #0]
  // so just get out of here
  else
    return;

  int ch;
  while ((ch = read()) != -1)
   d49f8:	4628      	mov	r0, r5
   d49fa:	f7ff fe7f 	bl	d46fc <_ZN9WebServer4readEv>
   d49fe:	1c43      	adds	r3, r0, #1
   d4a00:	2b0e      	cmp	r3, #14
   d4a02:	d9ed      	bls.n	d49e0 <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0x6c>
  {
    // stop storing at first space or end of line
    if (ch == ' ' || ch == '\n' || ch == '\r')
   d4a04:	2820      	cmp	r0, #32
   d4a06:	d1ef      	bne.n	d49e8 <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi+0x74>
      ++request;
    }
    --*length;
  }
  // NUL terminate
  *request = 0;
   d4a08:	2300      	movs	r3, #0
   d4a0a:	703b      	strb	r3, [r7, #0]
   d4a0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   d4a0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   d4a10:	000da22d 	.word	0x000da22d
   d4a14:	000da232 	.word	0x000da232
   d4a18:	000da238 	.word	0x000da238
   d4a1c:	000da23e 	.word	0x000da23e
   d4a20:	000da243 	.word	0x000da243
   d4a24:	000da24b 	.word	0x000da24b

000d4a28 <_ZN9WebServer14processHeadersEv>:
  // header, and the double-CRLF that ends the headers.

  // empty the m_authCredentials before every run of this function.
  // otherwise users who don't send an Authorization header would be treated
  // like the last user who tried to authenticate (possibly successful)
  m_authCredentials[0]=0;
   d4a28:	2300      	movs	r3, #0
  // NUL terminate
  *request = 0;
}

void WebServer::processHeaders()
{
   d4a2a:	b510      	push	{r4, lr}
   d4a2c:	4604      	mov	r4, r0
  // header, and the double-CRLF that ends the headers.

  // empty the m_authCredentials before every run of this function.
  // otherwise users who don't send an Authorization header would be treated
  // like the last user who tried to authenticate (possibly successful)
  m_authCredentials[0]=0;
   d4a2e:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80

  while (1)
  {
    if (expect("Content-Length:"))
   d4a32:	4913      	ldr	r1, [pc, #76]	; (d4a80 <_ZN9WebServer14processHeadersEv+0x58>)
   d4a34:	4620      	mov	r0, r4
   d4a36:	f7ff fe9d 	bl	d4774 <_ZN9WebServer6expectEPKc>
   d4a3a:	b128      	cbz	r0, d4a48 <_ZN9WebServer14processHeadersEv+0x20>
    {
      readInt(m_contentLength);
   d4a3c:	f104 017c 	add.w	r1, r4, #124	; 0x7c
   d4a40:	4620      	mov	r0, r4
   d4a42:	f7ff feb5 	bl	d47b0 <_ZN9WebServer7readIntERi>
#if WEBDUINO_SERIAL_DEBUGGING > 1
      Serial.print("\n*** got Content-Length of ");
      Serial.print(m_contentLength);
      Serial.print(" ***");
#endif
      continue;
   d4a46:	e7f4      	b.n	d4a32 <_ZN9WebServer14processHeadersEv+0xa>
    }

    if (expect("Authorization:"))
   d4a48:	490e      	ldr	r1, [pc, #56]	; (d4a84 <_ZN9WebServer14processHeadersEv+0x5c>)
   d4a4a:	4620      	mov	r0, r4
   d4a4c:	f7ff fe92 	bl	d4774 <_ZN9WebServer6expectEPKc>
   d4a50:	b130      	cbz	r0, d4a60 <_ZN9WebServer14processHeadersEv+0x38>
    {
      readHeader(m_authCredentials,51);
   d4a52:	2233      	movs	r2, #51	; 0x33
   d4a54:	f104 0180 	add.w	r1, r4, #128	; 0x80
   d4a58:	4620      	mov	r0, r4
   d4a5a:	f7ff feda 	bl	d4812 <_ZN9WebServer10readHeaderEPci>
#if WEBDUINO_SERIAL_DEBUGGING > 1
      Serial.print("\n*** got Authorization: of ");
      Serial.print(m_authCredentials);
      Serial.print(" ***");
#endif
      continue;
   d4a5e:	e7e8      	b.n	d4a32 <_ZN9WebServer14processHeadersEv+0xa>
    }

    if (expect(CRLF CRLF))
   d4a60:	4909      	ldr	r1, [pc, #36]	; (d4a88 <_ZN9WebServer14processHeadersEv+0x60>)
   d4a62:	4620      	mov	r0, r4
   d4a64:	f7ff fe86 	bl	d4774 <_ZN9WebServer6expectEPKc>
   d4a68:	b118      	cbz	r0, d4a72 <_ZN9WebServer14processHeadersEv+0x4a>
    {
      m_readingContent = true;
   d4a6a:	2301      	movs	r3, #1
   d4a6c:	f884 30b3 	strb.w	r3, [r4, #179]	; 0xb3
      return;
   d4a70:	bd10      	pop	{r4, pc}
    }

    // no expect checks hit, so just absorb a character and try again
    if (read() == -1)
   d4a72:	4620      	mov	r0, r4
   d4a74:	f7ff fe42 	bl	d46fc <_ZN9WebServer4readEv>
   d4a78:	3001      	adds	r0, #1
   d4a7a:	d1da      	bne.n	d4a32 <_ZN9WebServer14processHeadersEv+0xa>
   d4a7c:	bd10      	pop	{r4, pc}
   d4a7e:	bf00      	nop
   d4a80:	000da252 	.word	0x000da252
   d4a84:	000da262 	.word	0x000da262
   d4a88:	000da271 	.word	0x000da271

000d4a8c <_ZN9WebServer17processConnectionEPcPi>:
  int  request_len = WEBDUINO_DEFAULT_REQUEST_LENGTH;
  processConnection(request, &request_len);
}

void WebServer::processConnection(char *buff, int *bufflen)
{
   d4a8c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   d4a90:	4604      	mov	r4, r0
   d4a92:	b089      	sub	sp, #36	; 0x24
  int urlPrefixLen = strlen(m_urlPrefix);
   d4a94:	6d40      	ldr	r0, [r0, #84]	; 0x54
  int  request_len = WEBDUINO_DEFAULT_REQUEST_LENGTH;
  processConnection(request, &request_len);
}

void WebServer::processConnection(char *buff, int *bufflen)
{
   d4a96:	460d      	mov	r5, r1
   d4a98:	4617      	mov	r7, r2
  int urlPrefixLen = strlen(m_urlPrefix);
   d4a9a:	f004 f847 	bl	d8b2c <strlen>

  m_client = m_server.available();
   d4a9e:	f104 0108 	add.w	r1, r4, #8
  processConnection(request, &request_len);
}

void WebServer::processConnection(char *buff, int *bufflen)
{
  int urlPrefixLen = strlen(m_urlPrefix);
   d4aa2:	4680      	mov	r8, r0

  m_client = m_server.available();
   d4aa4:	a801      	add	r0, sp, #4
   d4aa6:	f002 f807 	bl	d6ab8 <_ZN9TCPServer9availableEv>
const unsigned char BIN = 2;

class String;
class __FlashStringHelper;

class Print
   d4aaa:	9b02      	ldr	r3, [sp, #8]
   d4aac:	63e3      	str	r3, [r4, #60]	; 0x3c
#define   getFloat(skipChar)  parseFloat(skipChar)
#define   getString( pre_string, post_string, buffer, length)
readBytesBetween( pre_string, terminator, buffer, length)
*/

class Stream : public Print
   d4aae:	9b03      	ldr	r3, [sp, #12]
   d4ab0:	6423      	str	r3, [r4, #64]	; 0x40
   d4ab2:	9b04      	ldr	r3, [sp, #16]
   d4ab4:	6463      	str	r3, [r4, #68]	; 0x44
#include "system_network.h"
#include "spark_wiring_print.h"
#include "spark_wiring_stream.h"
#include "spark_wiring_ipaddress.h"

class Client : public Stream {
   d4ab6:	9b05      	ldr	r3, [sp, #20]
   d4ab8:	64a3      	str	r3, [r4, #72]	; 0x48
    __enable_shared_from_this_helper(const __shared_count<_Lp>&, ...) noexcept
    { }


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
   d4aba:	9b06      	ldr	r3, [sp, #24]
   d4abc:	64e3      	str	r3, [r4, #76]	; 0x4c
      }

      __shared_count&
      operator=(const __shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
   d4abe:	9e07      	ldr	r6, [sp, #28]
	if (__tmp != _M_pi)
   d4ac0:	6d23      	ldr	r3, [r4, #80]	; 0x50
   d4ac2:	429e      	cmp	r6, r3
   d4ac4:	f104 0938 	add.w	r9, r4, #56	; 0x38
   d4ac8:	d00c      	beq.n	d4ae4 <_ZN9WebServer17processConnectionEPcPi+0x58>
	  {
	    if (__tmp != 0)
   d4aca:	b116      	cbz	r6, d4ad2 <_ZN9WebServer17processConnectionEPcPi+0x46>
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }
   d4acc:	6873      	ldr	r3, [r6, #4]
   d4ace:	3301      	adds	r3, #1
   d4ad0:	6073      	str	r3, [r6, #4]
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	if (__tmp != _M_pi)
	  {
	    if (__tmp != 0)
	      __tmp->_M_add_ref_copy();
	    if (_M_pi != 0)
   d4ad2:	6d20      	ldr	r0, [r4, #80]	; 0x50
   d4ad4:	b128      	cbz	r0, d4ae2 <_ZN9WebServer17processConnectionEPcPi+0x56>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
   d4ad6:	6843      	ldr	r3, [r0, #4]
   d4ad8:	3b01      	subs	r3, #1
   d4ada:	6043      	str	r3, [r0, #4]
   d4adc:	b90b      	cbnz	r3, d4ae2 <_ZN9WebServer17processConnectionEPcPi+0x56>
   d4ade:	f7ff fb17 	bl	d4110 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.4.constprop.16>
	  {
	    if (__tmp != 0)
	      __tmp->_M_add_ref_copy();
	    if (_M_pi != 0)
	      _M_pi->_M_release();
	    _M_pi = __tmp;
   d4ae2:	6526      	str	r6, [r4, #80]	; 0x50
   d4ae4:	a801      	add	r0, sp, #4
   d4ae6:	f7ff fb41 	bl	d416c <_ZN9TCPClientD1Ev>

  if (m_client) {
   d4aea:	4648      	mov	r0, r9
   d4aec:	f002 fbf3 	bl	d72d6 <_ZN9TCPClientcvbEv>
   d4af0:	2800      	cmp	r0, #0
   d4af2:	d051      	beq.n	d4b98 <_ZN9WebServer17processConnectionEPcPi+0x10c>
    m_readingContent = false;
   d4af4:	2300      	movs	r3, #0
   d4af6:	f884 30b3 	strb.w	r3, [r4, #179]	; 0xb3
    buff[0] = 0;
    ConnectionType requestType = INVALID;
   d4afa:	f88d 3004 	strb.w	r3, [sp, #4]

  m_client = m_server.available();

  if (m_client) {
    m_readingContent = false;
    buff[0] = 0;
   d4afe:	702b      	strb	r3, [r5, #0]
    ConnectionType requestType = INVALID;
#if WEBDUINO_SERIAL_DEBUGGING > 1
    Serial.println("*** checking request ***");
#endif
    getRequest(requestType, buff, bufflen);
   d4b00:	462a      	mov	r2, r5
   d4b02:	463b      	mov	r3, r7
   d4b04:	a901      	add	r1, sp, #4
   d4b06:	4620      	mov	r0, r4
   d4b08:	f7ff ff34 	bl	d4974 <_ZN9WebServer10getRequestERNS_14ConnectionTypeEPcPi>
    // - when there are illegal requests,
    // - when someone contacts it through telnet rather than proper HTTP,
    // - etc.
    // Only try to dispatch command if request type and prefix are correct.
    // Fix by quarencia.
    if (requestType == INVALID ||
   d4b0c:	f89d 6004 	ldrb.w	r6, [sp, #4]
   d4b10:	b12e      	cbz	r6, d4b1e <_ZN9WebServer17processConnectionEPcPi+0x92>
        strncmp(buff, m_urlPrefix, urlPrefixLen) != 0)
   d4b12:	4642      	mov	r2, r8
   d4b14:	6d61      	ldr	r1, [r4, #84]	; 0x54
   d4b16:	4628      	mov	r0, r5
   d4b18:	f004 f810 	bl	d8b3c <strncmp>
    // - when there are illegal requests,
    // - when someone contacts it through telnet rather than proper HTTP,
    // - etc.
    // Only try to dispatch command if request type and prefix are correct.
    // Fix by quarencia.
    if (requestType == INVALID ||
   d4b1c:	b148      	cbz	r0, d4b32 <_ZN9WebServer17processConnectionEPcPi+0xa6>
        strncmp(buff, m_urlPrefix, urlPrefixLen) != 0)
    {
      m_failureCmd(*this, requestType, buff, (*bufflen) >= 0);
   d4b1e:	683b      	ldr	r3, [r7, #0]
   d4b20:	f8d4 70b4 	ldr.w	r7, [r4, #180]	; 0xb4
   d4b24:	43db      	mvns	r3, r3
   d4b26:	0fdb      	lsrs	r3, r3, #31
   d4b28:	462a      	mov	r2, r5
   d4b2a:	4631      	mov	r1, r6
   d4b2c:	4620      	mov	r0, r4
   d4b2e:	47b8      	blx	r7
   d4b30:	e02c      	b.n	d4b8c <_ZN9WebServer17processConnectionEPcPi+0x100>
    }
    else
    {
      processHeaders();
   d4b32:	4620      	mov	r0, r4
   d4b34:	f7ff ff78 	bl	d4a28 <_ZN9WebServer14processHeadersEv>
#if WEBDUINO_SERIAL_DEBUGGING > 1
      Serial.println("*** headers complete ***");
#endif

      if (strcmp(buff, "/robots.txt") == 0)
   d4b38:	4919      	ldr	r1, [pc, #100]	; (d4ba0 <_ZN9WebServer17processConnectionEPcPi+0x114>)
   d4b3a:	4628      	mov	r0, r5
   d4b3c:	f003 fad0 	bl	d80e0 <strcmp>
   d4b40:	f89d 6004 	ldrb.w	r6, [sp, #4]
   d4b44:	b920      	cbnz	r0, d4b50 <_ZN9WebServer17processConnectionEPcPi+0xc4>
      {
        noRobots(requestType);
   d4b46:	4631      	mov	r1, r6
   d4b48:	4620      	mov	r0, r4
   d4b4a:	f7ff fd8b 	bl	d4664 <_ZN9WebServer8noRobotsENS_14ConnectionTypeE>
   d4b4e:	e01d      	b.n	d4b8c <_ZN9WebServer17processConnectionEPcPi+0x100>
      }
      else if (strcmp(buff, "/favicon.ico") == 0)
   d4b50:	4914      	ldr	r1, [pc, #80]	; (d4ba4 <_ZN9WebServer17processConnectionEPcPi+0x118>)
   d4b52:	4628      	mov	r0, r5
   d4b54:	f003 fac4 	bl	d80e0 <strcmp>
   d4b58:	b920      	cbnz	r0, d4b64 <_ZN9WebServer17processConnectionEPcPi+0xd8>
      {
        favicon(requestType);
   d4b5a:	4631      	mov	r1, r6
   d4b5c:	4620      	mov	r0, r4
   d4b5e:	f7ff fd95 	bl	d468c <_ZN9WebServer7faviconENS_14ConnectionTypeE>
   d4b62:	e013      	b.n	d4b8c <_ZN9WebServer17processConnectionEPcPi+0x100>
      }
      else if (!dispatchCommand(requestType, buff + urlPrefixLen,
   d4b64:	683b      	ldr	r3, [r7, #0]
   d4b66:	43db      	mvns	r3, r3
   d4b68:	0fdb      	lsrs	r3, r3, #31
   d4b6a:	eb05 0208 	add.w	r2, r5, r8
   d4b6e:	4631      	mov	r1, r6
   d4b70:	4620      	mov	r0, r4
   d4b72:	f7ff fca5 	bl	d44c0 <_ZN9WebServer15dispatchCommandENS_14ConnectionTypeEPcb>
   d4b76:	b948      	cbnz	r0, d4b8c <_ZN9WebServer17processConnectionEPcPi+0x100>
             (*bufflen) >= 0))
      {
        m_failureCmd(*this, requestType, buff, (*bufflen) >= 0);
   d4b78:	683b      	ldr	r3, [r7, #0]
   d4b7a:	f8d4 60b4 	ldr.w	r6, [r4, #180]	; 0xb4
   d4b7e:	f89d 1004 	ldrb.w	r1, [sp, #4]
   d4b82:	43db      	mvns	r3, r3
   d4b84:	0fdb      	lsrs	r3, r3, #31
   d4b86:	462a      	mov	r2, r5
   d4b88:	4620      	mov	r0, r4
   d4b8a:	47b0      	blx	r6
      }
    }
    
    flushBuf();
   d4b8c:	4620      	mov	r0, r4
   d4b8e:	f7ff fc44 	bl	d441a <_ZN9WebServer8flushBufEv>

#if WEBDUINO_SERIAL_DEBUGGING > 1
    Serial.println("*** stopping connection ***");
#endif
    reset();
   d4b92:	4620      	mov	r0, r4
   d4b94:	f7ff fda4 	bl	d46e0 <_ZN9WebServer5resetEv>
  }
}
   d4b98:	b009      	add	sp, #36	; 0x24
   d4b9a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   d4b9e:	bf00      	nop
   d4ba0:	000da276 	.word	0x000da276
   d4ba4:	000da282 	.word	0x000da282

000d4ba8 <setup>:
uCamIII_callback snapTarget = callbackSerial;

int         sendImageTCP(const uint8_t *buf, int len, int chunkSize = 512, uint32_t flushTime = 100);
int         bmpHeader(uint8_t *buf, int len, int width, int height, int bits, int encoding = 0, int padding = 0);

void setup() {
   d4ba8:	b510      	push	{r4, lr}
        return _function(name, args...);
    }

    static bool _function(const char *funcKey, user_function_int_str_t* func)
    {
        return register_function(call_raw_user_function, (void*)func, funcKey);
   d4baa:	4c32      	ldr	r4, [pc, #200]	; (d4c74 <setup+0xcc>)
   d4bac:	b08a      	sub	sp, #40	; 0x28
  Time.zone(+2.0);
   d4bae:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   d4bb2:	f001 fce9 	bl	d6588 <_ZN9TimeClass4zoneEf>
   d4bb6:	4a30      	ldr	r2, [pc, #192]	; (d4c78 <setup+0xd0>)
   d4bb8:	4930      	ldr	r1, [pc, #192]	; (d4c7c <setup+0xd4>)
   d4bba:	4620      	mov	r0, r4
   d4bbc:	f002 f896 	bl	d6cec <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
   d4bc0:	4a2f      	ldr	r2, [pc, #188]	; (d4c80 <setup+0xd8>)
   d4bc2:	4930      	ldr	r1, [pc, #192]	; (d4c84 <setup+0xdc>)
   d4bc4:	4620      	mov	r0, r4
   d4bc6:	f002 f891 	bl	d6cec <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
   d4bca:	4a2f      	ldr	r2, [pc, #188]	; (d4c88 <setup+0xe0>)
   d4bcc:	492f      	ldr	r1, [pc, #188]	; (d4c8c <setup+0xe4>)
   d4bce:	4620      	mov	r0, r4
   d4bd0:	f002 f88c 	bl	d6cec <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
  uCamIII(serial *camera, int resetPin = -1, uint32_t timeout = 500) 
  : uCamIII_Base(*camera, resetPin, timeout), _cameraInterface(*camera) { } 

  long init(int baudrate = 9600) { 
    Log.trace("uCAMIII: %s", __FUNCTION__);
    _cameraInterface.end();
   d4bd4:	4c2e      	ldr	r4, [pc, #184]	; (d4c90 <setup+0xe8>)
    
  Particle.function("setServer", devicesHandler);
  Particle.function("setTarget", setSnapshotTarget);
  Particle.function("snap", takeSnapshot);

  pinMode(D7, OUTPUT);
   d4bd6:	2101      	movs	r1, #1
   d4bd8:	2007      	movs	r0, #7
   d4bda:	f002 ff1d 	bl	d7a18 <pinMode>
  : uCamIII_Base(camera, resetPin, timeout), _cameraInterface(camera) { } 
  uCamIII(serial *camera, int resetPin = -1, uint32_t timeout = 500) 
  : uCamIII_Base(*camera, resetPin, timeout), _cameraInterface(*camera) { } 

  long init(int baudrate = 9600) { 
    Log.trace("uCAMIII: %s", __FUNCTION__);
   d4bde:	4a2d      	ldr	r2, [pc, #180]	; (d4c94 <setup+0xec>)
   d4be0:	492d      	ldr	r1, [pc, #180]	; (d4c98 <setup+0xf0>)
   d4be2:	482e      	ldr	r0, [pc, #184]	; (d4c9c <setup+0xf4>)
   d4be4:	f7ff fb0a 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>
    _cameraInterface.end();
   d4be8:	69a0      	ldr	r0, [r4, #24]
   d4bea:	f002 fa08 	bl	d6ffe <_ZN11USARTSerial3endEv>
    delay(100);
   d4bee:	2064      	movs	r0, #100	; 0x64
   d4bf0:	f001 fdce 	bl	d6790 <delay>
    _cameraInterface.begin(baudrate);
   d4bf4:	69a0      	ldr	r0, [r4, #24]
   d4bf6:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
   d4bfa:	f002 f9fd 	bl	d6ff8 <_ZN11USARTSerial5beginEm>
    _cameraInterface.setTimeout(_timeout);
   d4bfe:	68a1      	ldr	r1, [r4, #8]
   d4c00:	69a0      	ldr	r0, [r4, #24]
   d4c02:	f001 fc85 	bl	d6510 <_ZN6Stream10setTimeoutEm>
    delay(100);
   d4c06:	2064      	movs	r0, #100	; 0x64
   d4c08:	f001 fdc2 	bl	d6790 <delay>
    return uCamIII_Base::init();
   d4c0c:	4620      	mov	r0, r4
   d4c0e:	f000 ff95 	bl	d5b3c <_ZN12uCamIII_Base4initEv>
    WiFiClass() :
            NetworkClass(NETWORK_INTERFACE_WIFI_STA) {
    }

    WLanConfig* wifi_config() {
        return (WLanConfig*)network_config(*this, 0, NULL);
   d4c12:	4b23      	ldr	r3, [pc, #140]	; (d4ca0 <setup+0xf8>)
  ucam.init(115200);

#if Wiring_WiFi
  strncpy(lIP, String(WiFi.localIP()), sizeof(lIP));
   d4c14:	4c23      	ldr	r4, [pc, #140]	; (d4ca4 <setup+0xfc>)
   d4c16:	6858      	ldr	r0, [r3, #4]
   d4c18:	2200      	movs	r2, #0
   d4c1a:	4611      	mov	r1, r2
   d4c1c:	f001 f9da 	bl	d5fd4 <network_config>
        memcpy(mac, wifi_config()->nw.uaMacAddr, 6);
        return mac;
    }

    IPAddress localIP() {
        return IPAddress(wifi_config()->nw.aucIP);
   d4c20:	1c81      	adds	r1, r0, #2
   d4c22:	a804      	add	r0, sp, #16
   d4c24:	f002 f8ba 	bl	d6d9c <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
   d4c28:	a904      	add	r1, sp, #16
   d4c2a:	4668      	mov	r0, sp
   d4c2c:	f001 fbe8 	bl	d6400 <_ZN6StringC1ERK9Printable>
   d4c30:	9900      	ldr	r1, [sp, #0]
   d4c32:	2210      	movs	r2, #16
   d4c34:	4620      	mov	r0, r4
   d4c36:	f003 ff96 	bl	d8b66 <strncpy>
   d4c3a:	4668      	mov	r0, sp
   d4c3c:	f001 fb1e 	bl	d627c <_ZN6StringD1Ev>
        return _variable(varKey, (const char*)userVar, userVarType);
    }

    template<typename T> static inline bool _variable(const char *varKey, typename T::PointerType userVar, const T& userVarType)
    {
        return spark_variable(varKey, (const void*)userVar, T::TYPE_ID, NULL);
   d4c40:	4621      	mov	r1, r4
  m_server.begin();
}

void WebServer::setDefaultCommand(Command *cmd)
{
  m_defaultCmd = cmd;
   d4c42:	4c19      	ldr	r4, [pc, #100]	; (d4ca8 <setup+0x100>)
   d4c44:	4819      	ldr	r0, [pc, #100]	; (d4cac <setup+0x104>)
   d4c46:	2300      	movs	r3, #0
   d4c48:	2204      	movs	r2, #4
   d4c4a:	f001 fa1b 	bl	d6084 <spark_variable>
   d4c4e:	4a18      	ldr	r2, [pc, #96]	; (d4cb0 <setup+0x108>)
  Particle.variable("IP", lIP);

  webserver.setDefaultCommand(&defaultCmd);
  webserver.addCommand("index.html", &defaultCmd);
   d4c50:	4918      	ldr	r1, [pc, #96]	; (d4cb4 <setup+0x10c>)
   d4c52:	f8c4 20b8 	str.w	r2, [r4, #184]	; 0xb8
   d4c56:	4620      	mov	r0, r4
   d4c58:	f7ff fbd0 	bl	d43fc <_ZN9WebServer10addCommandEPKcPFvRS_NS_14ConnectionTypeEPcbE>
  webserver.addCommand("image.dat", &imageCmd);
   d4c5c:	4a16      	ldr	r2, [pc, #88]	; (d4cb8 <setup+0x110>)
   d4c5e:	4917      	ldr	r1, [pc, #92]	; (d4cbc <setup+0x114>)
   d4c60:	4620      	mov	r0, r4
   d4c62:	f7ff fbcb 	bl	d43fc <_ZN9WebServer10addCommandEPKcPFvRS_NS_14ConnectionTypeEPcbE>

P(webServerHeader) = "Server: Webduino/" WEBDUINO_VERSION_STRING CRLF;

void WebServer::begin()
{
  m_server.begin();
   d4c66:	f104 0008 	add.w	r0, r4, #8
   d4c6a:	f001 fe61 	bl	d6930 <_ZN9TCPServer5beginEv>
  webserver.begin();
#endif
}
   d4c6e:	b00a      	add	sp, #40	; 0x28
   d4c70:	bd10      	pop	{r4, pc}
   d4c72:	bf00      	nop
   d4c74:	000d6cc1 	.word	0x000d6cc1
   d4c78:	000da29e 	.word	0x000da29e
   d4c7c:	000d430d 	.word	0x000d430d
   d4c80:	000da2a8 	.word	0x000da2a8
   d4c84:	000d40cd 	.word	0x000d40cd
   d4c88:	000da2b2 	.word	0x000da2b2
   d4c8c:	000d51e1 	.word	0x000d51e1
   d4c90:	20034b74 	.word	0x20034b74
   d4c94:	000d9787 	.word	0x000d9787
   d4c98:	000da2b7 	.word	0x000da2b7
   d4c9c:	2003e2b0 	.word	0x2003e2b0
   d4ca0:	2003e5ec 	.word	0x2003e5ec
   d4ca4:	20034bb4 	.word	0x20034bb4
   d4ca8:	20034a48 	.word	0x20034a48
   d4cac:	000da2c3 	.word	0x000da2c3
   d4cb0:	000d4e71 	.word	0x000d4e71
   d4cb4:	000da2c6 	.word	0x000da2c6
   d4cb8:	000d53f9 	.word	0x000d53f9
   d4cbc:	000da2d1 	.word	0x000da2d1

000d4cc0 <loop>:





void loop() {
   d4cc0:	b500      	push	{lr}
   d4cc2:	b093      	sub	sp, #76	; 0x4c
  static uint32_t msSend = 0;    

#if Wiring_WiFi
  char buff[64];
  int len = 64;
   d4cc4:	aa12      	add	r2, sp, #72	; 0x48
   d4cc6:	2340      	movs	r3, #64	; 0x40
   d4cc8:	f842 3d44 	str.w	r3, [r2, #-68]!
  webserver.processConnection(buff, &len);
   d4ccc:	a902      	add	r1, sp, #8
   d4cce:	4803      	ldr	r0, [pc, #12]	; (d4cdc <loop+0x1c>)
   d4cd0:	f7ff fedc 	bl	d4a8c <_ZN9WebServer17processConnectionEPcPi>
#endif
}
   d4cd4:	b013      	add	sp, #76	; 0x4c
   d4cd6:	f85d fb04 	ldr.w	pc, [sp], #4
   d4cda:	bf00      	nop
   d4cdc:	20034a48 	.word	0x20034a48

000d4ce0 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE>:
}

long prepareCam(uCamIII_SNAP_TYPE snap, uCamIII_IMAGE_FORMAT fmt, uCamIII_RES res, 
                 uCamIII_CBE contrast, uCamIII_CBE brightness, uCamIII_CBE exposure,
                 uCamIII_callback callback)
{
   d4ce0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  int retVal = 0;
  
  digitalWrite(D7, HIGH);

  ucam.hardReset();
   d4ce4:	4f57      	ldr	r7, [pc, #348]	; (d4e44 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x164>)
}

long prepareCam(uCamIII_SNAP_TYPE snap, uCamIII_IMAGE_FORMAT fmt, uCamIII_RES res, 
                 uCamIII_CBE contrast, uCamIII_CBE brightness, uCamIII_CBE exposure,
                 uCamIII_callback callback)
{
   d4ce6:	4682      	mov	sl, r0
   d4ce8:	460d      	mov	r5, r1
  int retVal = 0;
  
  digitalWrite(D7, HIGH);
   d4cea:	2007      	movs	r0, #7
   d4cec:	2101      	movs	r1, #1
}

long prepareCam(uCamIII_SNAP_TYPE snap, uCamIII_IMAGE_FORMAT fmt, uCamIII_RES res, 
                 uCamIII_CBE contrast, uCamIII_CBE brightness, uCamIII_CBE exposure,
                 uCamIII_callback callback)
{
   d4cee:	4616      	mov	r6, r2
   d4cf0:	461c      	mov	r4, r3
  int retVal = 0;
  
  digitalWrite(D7, HIGH);
   d4cf2:	f002 fea2 	bl	d7a3a <digitalWrite>

  ucam.hardReset();
   d4cf6:	4638      	mov	r0, r7
   d4cf8:	f000 fd38 	bl	d576c <_ZN12uCamIII_Base9hardResetEv>

  if (!(retVal = ucam.sync())) return -1;
   d4cfc:	213c      	movs	r1, #60	; 0x3c
   d4cfe:	4638      	mov	r0, r7
   d4d00:	f000 fed8 	bl	d5ab4 <_ZN12uCamIII_Base4syncEi>
   d4d04:	2800      	cmp	r0, #0
   d4d06:	f000 808d 	beq.w	d4e24 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x144>
  long              getJpegData(uint8_t *buffer, int len, uCamIII_callback callback = NULL, int package = -1);
  long              getRawData(uint8_t *buffer, int len, uCamIII_callback callback = NULL);
  void              hardReset();
  
  inline long       setImageFormat(uCamIII_IMAGE_FORMAT format = uCamIII_COMP_JPEG, uCamIII_RES resolution = uCamIII_640x480)
                    { Log.trace(__FUNCTION__); return sendCmdWithAck(uCamIII_CMD_INIT, 0x00, format, resolution, resolution); }
   d4d0a:	494f      	ldr	r1, [pc, #316]	; (d4e48 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x168>)
   d4d0c:	484f      	ldr	r0, [pc, #316]	; (d4e4c <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x16c>)
   d4d0e:	f7ff fa75 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>
   d4d12:	9601      	str	r6, [sp, #4]
   d4d14:	9600      	str	r6, [sp, #0]
   d4d16:	462b      	mov	r3, r5
   d4d18:	2200      	movs	r2, #0
   d4d1a:	2101      	movs	r1, #1
   d4d1c:	4638      	mov	r0, r7
   d4d1e:	f000 fea7 	bl	d5a70 <_ZN12uCamIII_Base14sendCmdWithAckE11uCamIII_CMDhhhh>
  
  if (!(retVal = ucam.setImageFormat(fmt, res))) return -2;
   d4d22:	2800      	cmp	r0, #0
   d4d24:	f000 8081 	beq.w	d4e2a <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x14a>
  inline long       reset(uCamIII_RESET_TYPE type = uCamIII_RESET_FULL, bool force = true)
                    { Log.trace(__FUNCTION__); return sendCmdWithAck(uCamIII_CMD_RESET, type, 0x00, 0x00, force ? uCamIII_RESET_FORCE : 0x00); }
  inline long       setFrequency(uCamIII_FREQ frequency = uCamIII_50Hz)
                    { Log.trace(__FUNCTION__); return sendCmdWithAck(uCamIII_CMD_SET_FREQ, frequency); }
  inline long       setCBE(uCamIII_CBE contrast = uCamIII_DEFAULT, uCamIII_CBE brightness = uCamIII_DEFAULT, uCamIII_CBE exposure = uCamIII_DEFAULT)
                    { Log.trace(__FUNCTION__); return sendCmdWithAck(uCamIII_CMD_SET_CBE, contrast, brightness, exposure); }
   d4d28:	4949      	ldr	r1, [pc, #292]	; (d4e50 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x170>)
   d4d2a:	4848      	ldr	r0, [pc, #288]	; (d4e4c <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x16c>)
   d4d2c:	f7ff fa66 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>
   d4d30:	f04f 0900 	mov.w	r9, #0
   d4d34:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
   d4d38:	9300      	str	r3, [sp, #0]
   d4d3a:	4622      	mov	r2, r4
   d4d3c:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
   d4d40:	f8cd 9004 	str.w	r9, [sp, #4]
   d4d44:	2114      	movs	r1, #20
   d4d46:	4638      	mov	r0, r7
   d4d48:	f000 fe92 	bl	d5a70 <_ZN12uCamIII_Base14sendCmdWithAckE11uCamIII_CMDhhhh>
  
  retVal = ucam.setCBE(contrast, brightness, exposure);

  if (imageType == uCamIII_TYPE_SNAPSHOT)
   d4d4c:	4b41      	ldr	r3, [pc, #260]	; (d4e54 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x174>)
   d4d4e:	681a      	ldr	r2, [r3, #0]
   d4d50:	2a01      	cmp	r2, #1
   d4d52:	4604      	mov	r4, r0
   d4d54:	4698      	mov	r8, r3
   d4d56:	d113      	bne.n	d4d80 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0xa0>
  void              hardReset();
  
  inline long       setImageFormat(uCamIII_IMAGE_FORMAT format = uCamIII_COMP_JPEG, uCamIII_RES resolution = uCamIII_640x480)
                    { Log.trace(__FUNCTION__); return sendCmdWithAck(uCamIII_CMD_INIT, 0x00, format, resolution, resolution); }
  inline long       takeSnapshot(uCamIII_SNAP_TYPE type = uCamIII_SNAP_JPEG, uint16_t frame = 0)
                    { Log.trace(__FUNCTION__); long r = sendCmdWithAck(uCamIII_CMD_SNAPSHOT, type, frame & 0xFF, (frame >> 8) & 0xFF); delay(_timeout); return r; }
   d4d58:	493f      	ldr	r1, [pc, #252]	; (d4e58 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x178>)
   d4d5a:	483c      	ldr	r0, [pc, #240]	; (d4e4c <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x16c>)
   d4d5c:	f7ff fa4e 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>
   d4d60:	f8cd 9004 	str.w	r9, [sp, #4]
   d4d64:	f8cd 9000 	str.w	r9, [sp]
   d4d68:	464b      	mov	r3, r9
   d4d6a:	4652      	mov	r2, sl
   d4d6c:	2105      	movs	r1, #5
   d4d6e:	4638      	mov	r0, r7
   d4d70:	f000 fe7e 	bl	d5a70 <_ZN12uCamIII_Base14sendCmdWithAckE11uCamIII_CMDhhhh>
   d4d74:	4604      	mov	r4, r0
   d4d76:	68b8      	ldr	r0, [r7, #8]
   d4d78:	f001 fd0a 	bl	d6790 <delay>
    if (!(retVal = ucam.takeSnapshot(snap))) return -3;
   d4d7c:	2c00      	cmp	r4, #0
   d4d7e:	d057      	beq.n	d4e30 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x150>

  imageTime = Time.now();
   d4d80:	f001 fcf5 	bl	d676e <_ZN9TimeClass3nowEv>
   d4d84:	4b35      	ldr	r3, [pc, #212]	; (d4e5c <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x17c>)

  if (fmt == uCamIII_COMP_JPEG) 
   d4d86:	2d07      	cmp	r5, #7
  retVal = ucam.setCBE(contrast, brightness, exposure);

  if (imageType == uCamIII_TYPE_SNAPSHOT)
    if (!(retVal = ucam.takeSnapshot(snap))) return -3;

  imageTime = Time.now();
   d4d88:	6018      	str	r0, [r3, #0]

  if (fmt == uCamIII_COMP_JPEG) 
   d4d8a:	d113      	bne.n	d4db4 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0xd4>
  inline long       setCBE(uCamIII_CBE contrast = uCamIII_DEFAULT, uCamIII_CBE brightness = uCamIII_DEFAULT, uCamIII_CBE exposure = uCamIII_DEFAULT)
                    { Log.trace(__FUNCTION__); return sendCmdWithAck(uCamIII_CMD_SET_CBE, contrast, brightness, exposure); }
  inline long       setIdleTime(uint8_t seconds = 15)
                    { Log.trace(__FUNCTION__); return sendCmdWithAck(uCamIII_CMD_SLEEP, seconds); }
  inline long       setPackageSize(uint16_t size = 64)
                    { Log.trace(__FUNCTION__); return sendCmdWithAck(uCamIII_CMD_SET_PACKSIZE, 0x08, size & 0xFF, (size >> 8) & 0xFF) ? (_packageSize = size) : 0; }
   d4d8c:	4934      	ldr	r1, [pc, #208]	; (d4e60 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x180>)
   d4d8e:	482f      	ldr	r0, [pc, #188]	; (d4e4c <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x16c>)
   d4d90:	4c2c      	ldr	r4, [pc, #176]	; (d4e44 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x164>)
   d4d92:	f7ff fa33 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>
   d4d96:	2202      	movs	r2, #2
   d4d98:	2300      	movs	r3, #0
   d4d9a:	e88d 000c 	stmia.w	sp, {r2, r3}
   d4d9e:	2106      	movs	r1, #6
   d4da0:	2208      	movs	r2, #8
   d4da2:	4620      	mov	r0, r4
   d4da4:	f000 fe64 	bl	d5a70 <_ZN12uCamIII_Base14sendCmdWithAckE11uCamIII_CMDhhhh>
   d4da8:	2800      	cmp	r0, #0
   d4daa:	d044      	beq.n	d4e36 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x156>
   d4dac:	f44f 7000 	mov.w	r0, #512	; 0x200
   d4db0:	8220      	strh	r0, [r4, #16]
   d4db2:	4604      	mov	r4, r0
    if (!(retVal = ucam.setPackageSize(512))) return -4;

  // if we made it to here, we can set the global image variables accordingly 
  imageType = snap;             
  
  switch(res) 
   d4db4:	3e01      	subs	r6, #1

  if (fmt == uCamIII_COMP_JPEG) 
    if (!(retVal = ucam.setPackageSize(512))) return -4;

  // if we made it to here, we can set the global image variables accordingly 
  imageType = snap;             
   d4db6:	f8c8 a000 	str.w	sl, [r8]
   d4dba:	492a      	ldr	r1, [pc, #168]	; (d4e64 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x184>)
   d4dbc:	4b2a      	ldr	r3, [pc, #168]	; (d4e68 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x188>)
  
  switch(res) 
   d4dbe:	2e08      	cmp	r6, #8
   d4dc0:	d81c      	bhi.n	d4dfc <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x11c>
   d4dc2:	e8df f006 	tbb	[pc, r6]
   d4dc6:	1b1b      	.short	0x1b1b
   d4dc8:	1b091b05 	.word	0x1b091b05
   d4dcc:	140e      	.short	0x140e
   d4dce:	18          	.byte	0x18
   d4dcf:	00          	.byte	0x00
    case uCamIII_80x60:
      imageWidth  = 80;
      imageHeight = 60;
      break;
    case uCamIII_160x120:          
      imageWidth  = 160;
   d4dd0:	22a0      	movs	r2, #160	; 0xa0
   d4dd2:	600a      	str	r2, [r1, #0]
      imageHeight = 120;
   d4dd4:	2278      	movs	r2, #120	; 0x78
   d4dd6:	e014      	b.n	d4e02 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x122>
      break;
    case uCamIII_320x240:
      imageWidth  = 320;
   d4dd8:	f44f 72a0 	mov.w	r2, #320	; 0x140
   d4ddc:	600a      	str	r2, [r1, #0]
      imageHeight = 240;
   d4dde:	22f0      	movs	r2, #240	; 0xf0
   d4de0:	e00f      	b.n	d4e02 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x122>
      break;
    case uCamIII_640x480:
      imageWidth  = 640;
   d4de2:	f44f 7220 	mov.w	r2, #640	; 0x280
   d4de6:	600a      	str	r2, [r1, #0]
      imageHeight = 480;
   d4de8:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
   d4dec:	e009      	b.n	d4e02 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x122>
      break;
    case uCamIII_128x96:
      imageWidth  = 128;
   d4dee:	2280      	movs	r2, #128	; 0x80
   d4df0:	600a      	str	r2, [r1, #0]
      imageHeight = 96;
   d4df2:	2260      	movs	r2, #96	; 0x60
   d4df4:	e005      	b.n	d4e02 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x122>
      break;
    case uCamIII_128x128:
      imageWidth  = 128;
   d4df6:	2280      	movs	r2, #128	; 0x80
   d4df8:	600a      	str	r2, [r1, #0]
   d4dfa:	e002      	b.n	d4e02 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x122>
      imageHeight = 128;
      break;
    default:
      imageWidth  = 80;
   d4dfc:	2250      	movs	r2, #80	; 0x50
   d4dfe:	600a      	str	r2, [r1, #0]
      imageHeight = 60;
   d4e00:	223c      	movs	r2, #60	; 0x3c
      break;
  }

  switch (fmt)
   d4e02:	3d03      	subs	r5, #3
      imageWidth  = 128;
      imageHeight = 128;
      break;
    default:
      imageWidth  = 80;
      imageHeight = 60;
   d4e04:	601a      	str	r2, [r3, #0]
      break;
  }

  switch (fmt)
   d4e06:	2d05      	cmp	r5, #5
   d4e08:	d818      	bhi.n	d4e3c <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x15c>
   d4e0a:	e8df f005 	tbb	[pc, r5]
   d4e0e:	1707      	.short	0x1707
   d4e10:	05030517 	.word	0x05030517
  {
    case uCamIII_COMP_JPEG:
      imagePxDepth = 24;
   d4e14:	2218      	movs	r2, #24
   d4e16:	e002      	b.n	d4e1e <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x13e>
      break;
    case uCamIII_RAW_16BIT_RGB565:
    case uCamIII_RAW_16BIT_CRYCBY:
      imagePxDepth = 16;
   d4e18:	2210      	movs	r2, #16
   d4e1a:	e000      	b.n	d4e1e <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x13e>
      break;
    case uCamIII_RAW_8BIT:
    defaut:
      imagePxDepth = 8;
   d4e1c:	2208      	movs	r2, #8
   d4e1e:	4b13      	ldr	r3, [pc, #76]	; (d4e6c <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x18c>)
   d4e20:	601a      	str	r2, [r3, #0]
   d4e22:	e00b      	b.n	d4e3c <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x15c>
  
  digitalWrite(D7, HIGH);

  ucam.hardReset();

  if (!(retVal = ucam.sync())) return -1;
   d4e24:	f04f 30ff 	mov.w	r0, #4294967295
   d4e28:	e009      	b.n	d4e3e <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x15e>
  
  if (!(retVal = ucam.setImageFormat(fmt, res))) return -2;
   d4e2a:	f06f 0001 	mvn.w	r0, #1
   d4e2e:	e006      	b.n	d4e3e <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x15e>
  
  retVal = ucam.setCBE(contrast, brightness, exposure);

  if (imageType == uCamIII_TYPE_SNAPSHOT)
    if (!(retVal = ucam.takeSnapshot(snap))) return -3;
   d4e30:	f06f 0002 	mvn.w	r0, #2
   d4e34:	e003      	b.n	d4e3e <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x15e>

  imageTime = Time.now();

  if (fmt == uCamIII_COMP_JPEG) 
    if (!(retVal = ucam.setPackageSize(512))) return -4;
   d4e36:	f06f 0003 	mvn.w	r0, #3
   d4e3a:	e000      	b.n	d4e3e <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE+0x15e>
    defaut:
      imagePxDepth = 8;
      break;
  }
  
  return retVal;
   d4e3c:	4620      	mov	r0, r4
}
   d4e3e:	b002      	add	sp, #8
   d4e40:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   d4e44:	20034b74 	.word	0x20034b74
   d4e48:	000d9778 	.word	0x000d9778
   d4e4c:	2003e2b0 	.word	0x2003e2b0
   d4e50:	000d94ca 	.word	0x000d94ca
   d4e54:	20034984 	.word	0x20034984
   d4e58:	000d97a4 	.word	0x000d97a4
   d4e5c:	2003e254 	.word	0x2003e254
   d4e60:	000d95fa 	.word	0x000d95fa
   d4e64:	20034bc8 	.word	0x20034bc8
   d4e68:	20034a44 	.word	0x20034a44
   d4e6c:	20034b70 	.word	0x20034b70

000d4e70 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb>:
{
  return webserver.write(buf, len);
}

void defaultCmd(WebServer &server, WebServer::ConnectionType type, char *url_tail, bool tail_complete)
{
   d4e70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   d4e74:	b0f7      	sub	sp, #476	; 0x1dc
  int jpgRes = -1;
  int contr  = 0;
  int bright = 0;
  int expose = 0;

  char strScript[strlen((const char*)script)+16] = "";
   d4e76:	2400      	movs	r4, #0
{
  return webserver.write(buf, len);
}

void defaultCmd(WebServer &server, WebServer::ConnectionType type, char *url_tail, bool tail_complete)
{
   d4e78:	4680      	mov	r8, r0
   d4e7a:	460d      	mov	r5, r1
  Log.trace(__FUNCTION__); 
   d4e7c:	486a      	ldr	r0, [pc, #424]	; (d5028 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x1b8>)
   d4e7e:	496b      	ldr	r1, [pc, #428]	; (d502c <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x1bc>)
{
  return webserver.write(buf, len);
}

void defaultCmd(WebServer &server, WebServer::ConnectionType type, char *url_tail, bool tail_complete)
{
   d4e80:	920b      	str	r2, [sp, #44]	; 0x2c
  Log.trace(__FUNCTION__); 
   d4e82:	f7ff f9bb 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>
  int jpgRes = -1;
  int contr  = 0;
  int bright = 0;
  int expose = 0;

  char strScript[strlen((const char*)script)+16] = "";
   d4e86:	f240 1263 	movw	r2, #355	; 0x163
   d4e8a:	4621      	mov	r1, r4
   d4e8c:	a81d      	add	r0, sp, #116	; 0x74
   d4e8e:	941c      	str	r4, [sp, #112]	; 0x70
   d4e90:	f003 f8e7 	bl	d8062 <memset>
  int  tzOffset  = Time.local() - Time.now();
   d4e94:	f001 fb6a 	bl	d656c <_ZN9TimeClass5localEv>
   d4e98:	9009      	str	r0, [sp, #36]	; 0x24
   d4e9a:	f001 fc68 	bl	d676e <_ZN9TimeClass3nowEv>
  int  tzHours   = tzOffset / 3600; 
  int  tzMinutes = abs(tzOffset / 60) % 60;

  server.httpSuccess();
   d4e9e:	4622      	mov	r2, r4
  int contr  = 0;
  int bright = 0;
  int expose = 0;

  char strScript[strlen((const char*)script)+16] = "";
  int  tzOffset  = Time.local() - Time.now();
   d4ea0:	900a      	str	r0, [sp, #40]	; 0x28
  int  tzHours   = tzOffset / 3600; 
  int  tzMinutes = abs(tzOffset / 60) % 60;

  server.httpSuccess();
   d4ea2:	4963      	ldr	r1, [pc, #396]	; (d5030 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x1c0>)
   d4ea4:	4640      	mov	r0, r8
   d4ea6:	f7ff fbb3 	bl	d4610 <_ZN9WebServer11httpSuccessEPKcS1_>

  if (type == WebServer::HEAD)
   d4eaa:	2d02      	cmp	r5, #2
   d4eac:	f000 80b9 	beq.w	d5022 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x1b2>
    return;

  if (strlen(url_tail)) 
   d4eb0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   d4eb2:	781b      	ldrb	r3, [r3, #0]
   d4eb4:	2b00      	cmp	r3, #0
   d4eb6:	f000 80a4 	beq.w	d5002 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x192>
   d4eba:	f04f 37ff 	mov.w	r7, #4294967295
   d4ebe:	46a3      	mov	fp, r4
   d4ec0:	46a2      	mov	sl, r4
   d4ec2:	9708      	str	r7, [sp, #32]
   d4ec4:	463e      	mov	r6, r7
   d4ec6:	46b9      	mov	r9, r7
  {
    while (strlen(url_tail))
   d4ec8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   d4eca:	781b      	ldrb	r3, [r3, #0]
   d4ecc:	2b00      	cmp	r3, #0
   d4ece:	d04c      	beq.n	d4f6a <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0xfa>
    {
    URLPARAM_RESULT rc;
    char name[NAMELEN];
    char value[VALUELEN];
    
    rc = server.nextURLparam(&url_tail, name, NAMELEN, value, VALUELEN);
   d4ed0:	2320      	movs	r3, #32
   d4ed2:	ad14      	add	r5, sp, #80	; 0x50
   d4ed4:	9301      	str	r3, [sp, #4]
   d4ed6:	9500      	str	r5, [sp, #0]
   d4ed8:	aa0c      	add	r2, sp, #48	; 0x30
   d4eda:	a90b      	add	r1, sp, #44	; 0x2c
   d4edc:	4640      	mov	r0, r8
   d4ede:	f7ff fcba 	bl	d4856 <_ZN9WebServer12nextURLparamEPPcS0_iS0_i>
    if (rc != URLPARAM_EOS)
   d4ee2:	2804      	cmp	r0, #4
   d4ee4:	d0f0      	beq.n	d4ec8 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x58>
    {
      if (!strcmp(name, COLOR_TYPE))
   d4ee6:	4953      	ldr	r1, [pc, #332]	; (d5034 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x1c4>)
   d4ee8:	a80c      	add	r0, sp, #48	; 0x30
   d4eea:	f003 f8f9 	bl	d80e0 <strcmp>
   d4eee:	b948      	cbnz	r0, d4f04 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x94>
      {
        fmt = atoi(value);
   d4ef0:	4628      	mov	r0, r5
   d4ef2:	f002 ffa1 	bl	d7e38 <atoi>
        snap = (fmt == uCamIII_COMP_JPEG) ? uCamIII_SNAP_JPEG : uCamIII_SNAP_RAW;
   d4ef6:	f1b0 0907 	subs.w	r9, r0, #7
    rc = server.nextURLparam(&url_tail, name, NAMELEN, value, VALUELEN);
    if (rc != URLPARAM_EOS)
    {
      if (!strcmp(name, COLOR_TYPE))
      {
        fmt = atoi(value);
   d4efa:	4606      	mov	r6, r0
        snap = (fmt == uCamIII_COMP_JPEG) ? uCamIII_SNAP_JPEG : uCamIII_SNAP_RAW;
   d4efc:	bf18      	it	ne
   d4efe:	f04f 0901 	movne.w	r9, #1
   d4f02:	e7e1      	b.n	d4ec8 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x58>
      }
      else if (!strcmp(name, RAW_RES))
   d4f04:	494c      	ldr	r1, [pc, #304]	; (d5038 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x1c8>)
   d4f06:	a80c      	add	r0, sp, #48	; 0x30
   d4f08:	f003 f8ea 	bl	d80e0 <strcmp>
   d4f0c:	b920      	cbnz	r0, d4f18 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0xa8>
        rawRes = atoi(value);           
   d4f0e:	4628      	mov	r0, r5
   d4f10:	f002 ff92 	bl	d7e38 <atoi>
   d4f14:	9008      	str	r0, [sp, #32]
   d4f16:	e7d7      	b.n	d4ec8 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x58>
      else if (!strcmp(name, JPG_RES))
   d4f18:	4948      	ldr	r1, [pc, #288]	; (d503c <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x1cc>)
   d4f1a:	a80c      	add	r0, sp, #48	; 0x30
   d4f1c:	f003 f8e0 	bl	d80e0 <strcmp>
   d4f20:	b920      	cbnz	r0, d4f2c <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0xbc>
        jpgRes = atoi(value);           
   d4f22:	4628      	mov	r0, r5
   d4f24:	f002 ff88 	bl	d7e38 <atoi>
   d4f28:	4607      	mov	r7, r0
   d4f2a:	e7cd      	b.n	d4ec8 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x58>
      else if (!strcmp(name, CONTRAST))
   d4f2c:	4944      	ldr	r1, [pc, #272]	; (d5040 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x1d0>)
   d4f2e:	a80c      	add	r0, sp, #48	; 0x30
   d4f30:	f003 f8d6 	bl	d80e0 <strcmp>
   d4f34:	b920      	cbnz	r0, d4f40 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0xd0>
        contr = atoi(value);           
   d4f36:	4628      	mov	r0, r5
   d4f38:	f002 ff7e 	bl	d7e38 <atoi>
   d4f3c:	4682      	mov	sl, r0
   d4f3e:	e7c3      	b.n	d4ec8 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x58>
      else if (!strcmp(name, BRIGHTNESS))
   d4f40:	4940      	ldr	r1, [pc, #256]	; (d5044 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x1d4>)
   d4f42:	a80c      	add	r0, sp, #48	; 0x30
   d4f44:	f003 f8cc 	bl	d80e0 <strcmp>
   d4f48:	b920      	cbnz	r0, d4f54 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0xe4>
        bright = atoi(value);           
   d4f4a:	4628      	mov	r0, r5
   d4f4c:	f002 ff74 	bl	d7e38 <atoi>
   d4f50:	4683      	mov	fp, r0
   d4f52:	e7b9      	b.n	d4ec8 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x58>
      else if (!strcmp(name, EXPOSURE))
   d4f54:	493c      	ldr	r1, [pc, #240]	; (d5048 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x1d8>)
   d4f56:	a80c      	add	r0, sp, #48	; 0x30
   d4f58:	f003 f8c2 	bl	d80e0 <strcmp>
   d4f5c:	2800      	cmp	r0, #0
   d4f5e:	d1b3      	bne.n	d4ec8 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x58>
        expose = atoi(value);           
   d4f60:	4628      	mov	r0, r5
   d4f62:	f002 ff69 	bl	d7e38 <atoi>
   d4f66:	4604      	mov	r4, r0
  if (type == WebServer::HEAD)
    return;

  if (strlen(url_tail)) 
  {
    while (strlen(url_tail))
   d4f68:	e7ae      	b.n	d4ec8 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x58>
      else if (!strcmp(name, EXPOSURE))
        expose = atoi(value);           
    }
    }
    
    res = (fmt == uCamIII_COMP_JPEG) ? jpgRes : rawRes;
   d4f6a:	2e07      	cmp	r6, #7
   d4f6c:	d006      	beq.n	d4f7c <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x10c>
    if (snap >= 0 && fmt > 0 && res > 0)
   d4f6e:	f1b9 3fff 	cmp.w	r9, #4294967295
   d4f72:	d018      	beq.n	d4fa6 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x136>
   d4f74:	2e00      	cmp	r6, #0
   d4f76:	dd16      	ble.n	d4fa6 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x136>
   d4f78:	9a08      	ldr	r2, [sp, #32]
   d4f7a:	e003      	b.n	d4f84 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x114>
   d4f7c:	f1b9 3fff 	cmp.w	r9, #4294967295
   d4f80:	d011      	beq.n	d4fa6 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x136>
   d4f82:	463a      	mov	r2, r7
   d4f84:	2a00      	cmp	r2, #0
   d4f86:	dd0e      	ble.n	d4fa6 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x136>
      prepareCam((uCamIII_SNAP_TYPE)snap, (uCamIII_IMAGE_FORMAT)fmt, (uCamIII_RES)res, 
                 (uCamIII_CBE)contr, (uCamIII_CBE)bright, (uCamIII_CBE)expose);
   d4f88:	2300      	movs	r3, #0
   d4f8a:	9302      	str	r3, [sp, #8]
   d4f8c:	b2e3      	uxtb	r3, r4
   d4f8e:	9301      	str	r3, [sp, #4]
   d4f90:	fa5f f38b 	uxtb.w	r3, fp
   d4f94:	9300      	str	r3, [sp, #0]
   d4f96:	b2d2      	uxtb	r2, r2
   d4f98:	fa5f f38a 	uxtb.w	r3, sl
   d4f9c:	b2f1      	uxtb	r1, r6
   d4f9e:	fa5f f089 	uxtb.w	r0, r9
   d4fa2:	f7ff fe9d 	bl	d4ce0 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE>
  int contr  = 0;
  int bright = 0;
  int expose = 0;

  char strScript[strlen((const char*)script)+16] = "";
  int  tzOffset  = Time.local() - Time.now();
   d4fa6:	9b09      	ldr	r3, [sp, #36]	; 0x24
   d4fa8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
      prepareCam((uCamIII_SNAP_TYPE)snap, (uCamIII_IMAGE_FORMAT)fmt, (uCamIII_RES)res, 
                 (uCamIII_CBE)contr, (uCamIII_CBE)bright, (uCamIII_CBE)expose);

    snprintf(strScript, sizeof(strScript), (const char*)script, 
           fmt, rawRes, jpgRes, contr, bright, expose, 
           (const char*)Time.format(imageTime, "%FT%T"), tzHours, tzMinutes);
   d4faa:	4928      	ldr	r1, [pc, #160]	; (d504c <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x1dc>)
  int contr  = 0;
  int bright = 0;
  int expose = 0;

  char strScript[strlen((const char*)script)+16] = "";
  int  tzOffset  = Time.local() - Time.now();
   d4fac:	1a9d      	subs	r5, r3, r2
      prepareCam((uCamIII_SNAP_TYPE)snap, (uCamIII_IMAGE_FORMAT)fmt, (uCamIII_RES)res, 
                 (uCamIII_CBE)contr, (uCamIII_CBE)bright, (uCamIII_CBE)expose);

    snprintf(strScript, sizeof(strScript), (const char*)script, 
           fmt, rawRes, jpgRes, contr, bright, expose, 
           (const char*)Time.format(imageTime, "%FT%T"), tzHours, tzMinutes);
   d4fae:	4a28      	ldr	r2, [pc, #160]	; (d5050 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x1e0>)
   d4fb0:	4b28      	ldr	r3, [pc, #160]	; (d5054 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x1e4>)
   d4fb2:	6812      	ldr	r2, [r2, #0]
   d4fb4:	a814      	add	r0, sp, #80	; 0x50
   d4fb6:	f001 fb87 	bl	d66c8 <_ZN9TimeClass6formatElPKc>
   d4fba:	213c      	movs	r1, #60	; 0x3c
   d4fbc:	fb95 f3f1 	sdiv	r3, r5, r1
   d4fc0:	2b00      	cmp	r3, #0
   d4fc2:	bfb8      	it	lt
   d4fc4:	425b      	neglt	r3, r3
   d4fc6:	fb93 f2f1 	sdiv	r2, r3, r1
   d4fca:	fb01 3312 	mls	r3, r1, r2, r3
   d4fce:	9307      	str	r3, [sp, #28]
   d4fd0:	f44f 6361 	mov.w	r3, #3600	; 0xe10
   d4fd4:	fb95 f5f3 	sdiv	r5, r5, r3
   d4fd8:	9b14      	ldr	r3, [sp, #80]	; 0x50
   d4fda:	9305      	str	r3, [sp, #20]
   d4fdc:	9b08      	ldr	r3, [sp, #32]
   d4fde:	9300      	str	r3, [sp, #0]
   d4fe0:	9506      	str	r5, [sp, #24]
   d4fe2:	9404      	str	r4, [sp, #16]
   d4fe4:	f8cd b00c 	str.w	fp, [sp, #12]
   d4fe8:	f8cd a008 	str.w	sl, [sp, #8]
   d4fec:	9701      	str	r7, [sp, #4]
   d4fee:	4633      	mov	r3, r6
   d4ff0:	4a19      	ldr	r2, [pc, #100]	; (d5058 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x1e8>)
   d4ff2:	f240 1167 	movw	r1, #359	; 0x167
   d4ff6:	a81c      	add	r0, sp, #112	; 0x70
   d4ff8:	f001 f8a4 	bl	d6144 <snprintf>
   d4ffc:	a814      	add	r0, sp, #80	; 0x50
   d4ffe:	f001 f93d 	bl	d627c <_ZN6StringD1Ev>
  }
  server.printP(Page_start);
   d5002:	4916      	ldr	r1, [pc, #88]	; (d505c <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x1ec>)
   d5004:	4640      	mov	r0, r8
   d5006:	f7ff fa44 	bl	d4492 <_ZN9WebServer6printPEPKh>
  server.printP(camBody);
   d500a:	4915      	ldr	r1, [pc, #84]	; (d5060 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x1f0>)
   d500c:	4640      	mov	r0, r8
   d500e:	f7ff fa40 	bl	d4492 <_ZN9WebServer6printPEPKh>
  server.print(strScript);
   d5012:	a91c      	add	r1, sp, #112	; 0x70
   d5014:	4640      	mov	r0, r8
   d5016:	f001 fa3f 	bl	d6498 <_ZN5Print5printEPKc>
  server.printP(Page_end);
   d501a:	4912      	ldr	r1, [pc, #72]	; (d5064 <_Z10defaultCmdR9WebServerNS_14ConnectionTypeEPcb+0x1f4>)
   d501c:	4640      	mov	r0, r8
   d501e:	f7ff fa38 	bl	d4492 <_ZN9WebServer6printPEPKh>
}
   d5022:	b077      	add	sp, #476	; 0x1dc
   d5024:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   d5028:	2003e2b0 	.word	0x2003e2b0
   d502c:	000da14e 	.word	0x000da14e
   d5030:	000da2db 	.word	0x000da2db
   d5034:	000da2f4 	.word	0x000da2f4
   d5038:	000da2f7 	.word	0x000da2f7
   d503c:	000da2fa 	.word	0x000da2fa
   d5040:	000da2fd 	.word	0x000da2fd
   d5044:	000da302 	.word	0x000da302
   d5048:	000da307 	.word	0x000da307
   d504c:	2003e2c0 	.word	0x2003e2c0
   d5050:	2003e254 	.word	0x2003e254
   d5054:	000da30c 	.word	0x000da30c
   d5058:	000d9609 	.word	0x000d9609
   d505c:	000d9466 	.word	0x000d9466
   d5060:	000d97f2 	.word	0x000d97f2
   d5064:	000d943c 	.word	0x000d943c

000d5068 <_Z9bmpHeaderPhiiiiii>:
  uint32_t Reserved;          //                                            [120][134]
*/
} __attribute__((__packed__));

int bmpHeader(uint8_t *buf, int len, int width, int height, int bits, int encoding, int padding)  
{  
   d5068:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   d506c:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   d506e:	460d      	mov	r5, r1
   d5070:	4604      	mov	r4, r0
  Log.trace(__FUNCTION__); 
   d5072:	4958      	ldr	r1, [pc, #352]	; (d51d4 <_Z9bmpHeaderPhiiiiii+0x16c>)
   d5074:	4858      	ldr	r0, [pc, #352]	; (d51d8 <_Z9bmpHeaderPhiiiiii+0x170>)
  uint32_t Reserved;          //                                            [120][134]
*/
} __attribute__((__packed__));

int bmpHeader(uint8_t *buf, int len, int width, int height, int bits, int encoding, int padding)  
{  
   d5076:	4698      	mov	r8, r3
   d5078:	4691      	mov	r9, r2
  Log.trace(__FUNCTION__); 
   d507a:	f7ff f8bf 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>

  uint32_t          headerSize      = sizeof(BITMAPFILEHEADER) 
                                    + sizeof(BITMAPV5HEADER);
  uint32_t          paletteSize     = (bits <= 8) ? (1 << (bits+2)) : 0;    // optional palette
   d507e:	2e08      	cmp	r6, #8
   d5080:	bfdd      	ittte	le
   d5082:	2701      	movle	r7, #1
   d5084:	1cb3      	addle	r3, r6, #2
   d5086:	409f      	lslle	r7, r3
   d5088:	2700      	movgt	r7, #0

  BITMAPFILEHEADER *bmpFileHeader   = (BITMAPFILEHEADER*)buf;
  BITMAPV5HEADER   *bmpInfoHeader   = (BITMAPV5HEADER*)(buf + sizeof(BITMAPFILEHEADER));
  uint8_t          *bmpPalette      = buf + headerSize; 

  if (len < headerSize + paletteSize) return 0;
   d508a:	f107 0a46 	add.w	sl, r7, #70	; 0x46
   d508e:	45aa      	cmp	sl, r5
   d5090:	f200 809b 	bhi.w	d51ca <_Z9bmpHeaderPhiiiiii+0x162>

  /// ToDo: where do we set encoding R5G6B5 vs. CrYCbY?

  memset(bmpFileHeader, 0, sizeof(BITMAPFILEHEADER));
   d5094:	220e      	movs	r2, #14
   d5096:	2100      	movs	r1, #0
   d5098:	4620      	mov	r0, r4
   d509a:	f002 ffe2 	bl	d8062 <memset>
  bmpFileHeader->bfType              = 0x4D42;                               // magic number "BM"
  bmpFileHeader->bfSize              = headerSize 
                                     + paletteSize
                                     + pixelDataSize;
   d509e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  //bmpFileHeader->bfReserved1         =
  //bmpFileHeader->bfReserved2         = 0;
  bmpFileHeader->bfOffBits           = headerSize
                                     + paletteSize;
   d50a0:	f8c4 a00a 	str.w	sl, [r4, #10]
  if (len < headerSize + paletteSize) return 0;

  /// ToDo: where do we set encoding R5G6B5 vs. CrYCbY?

  memset(bmpFileHeader, 0, sizeof(BITMAPFILEHEADER));
  bmpFileHeader->bfType              = 0x4D42;                               // magic number "BM"
   d50a4:	2342      	movs	r3, #66	; 0x42
   d50a6:	7023      	strb	r3, [r4, #0]
   d50a8:	234d      	movs	r3, #77	; 0x4d
   d50aa:	7063      	strb	r3, [r4, #1]
  bmpFileHeader->bfSize              = headerSize 
                                     + paletteSize
                                     + pixelDataSize;
   d50ac:	2308      	movs	r3, #8
   d50ae:	fb96 f3f3 	sdiv	r3, r6, r3
   d50b2:	fb09 2303 	mla	r3, r9, r3, r2
  if (len < headerSize + paletteSize) return 0;

  /// ToDo: where do we set encoding R5G6B5 vs. CrYCbY?

  memset(bmpFileHeader, 0, sizeof(BITMAPFILEHEADER));
  bmpFileHeader->bfType              = 0x4D42;                               // magic number "BM"
   d50b6:	2500      	movs	r5, #0
  bmpFileHeader->bfSize              = headerSize 
                                     + paletteSize
                                     + pixelDataSize;
   d50b8:	fb08 a303 	mla	r3, r8, r3, sl
  //bmpFileHeader->bfReserved1         =
  //bmpFileHeader->bfReserved2         = 0;
  bmpFileHeader->bfOffBits           = headerSize
                                     + paletteSize;

  memset(bmpInfoHeader, 0, sizeof(BITMAPV5HEADER));
   d50bc:	f04f 0a38 	mov.w	sl, #56	; 0x38

  memset(bmpFileHeader, 0, sizeof(BITMAPFILEHEADER));
  bmpFileHeader->bfType              = 0x4D42;                               // magic number "BM"
  bmpFileHeader->bfSize              = headerSize 
                                     + paletteSize
                                     + pixelDataSize;
   d50c0:	f8c4 3002 	str.w	r3, [r4, #2]
  //bmpFileHeader->bfReserved1         =
  //bmpFileHeader->bfReserved2         = 0;
  bmpFileHeader->bfOffBits           = headerSize
                                     + paletteSize;

  memset(bmpInfoHeader, 0, sizeof(BITMAPV5HEADER));
   d50c4:	4652      	mov	r2, sl
   d50c6:	4629      	mov	r1, r5
   d50c8:	f104 000e 	add.w	r0, r4, #14
   d50cc:	f002 ffc9 	bl	d8062 <memset>
  bmpInfoHeader->Size                = sizeof(BITMAPV5HEADER);  
  bmpInfoHeader->Width               = width;                               
  bmpInfoHeader->Height              = -height;                              // negative height flips vertically
                                                                            // so image isn't upside down 
                                                                            // but Google Chorme doesn't support that!!! 
  bmpInfoHeader->Planes              = 1;  
   d50d0:	2301      	movs	r3, #1
  bmpInfoHeader->BitsPerPixel        = bits;  
  //bmpInfoHeader->Compression         = 0; 
  bmpInfoHeader->SizeOfBitmap        = 0x03;                                 // BI_RGB (0), BI_BITFIELD (3)
   d50d2:	2203      	movs	r2, #3
  bmpInfoHeader->HorzResolution      = 0x1000; 
  bmpInfoHeader->VertResolution      = 0x1000; 
  bmpInfoHeader->ColorsUsed          =     
  bmpInfoHeader->ColorsImportant     = (bits <= 8) ? (1 << bits) : 0;        // <= 8bit use color palette
   d50d4:	2e08      	cmp	r6, #8
  //bmpFileHeader->bfReserved2         = 0;
  bmpFileHeader->bfOffBits           = headerSize
                                     + paletteSize;

  memset(bmpInfoHeader, 0, sizeof(BITMAPV5HEADER));
  bmpInfoHeader->Size                = sizeof(BITMAPV5HEADER);  
   d50d6:	73e5      	strb	r5, [r4, #15]
   d50d8:	7425      	strb	r5, [r4, #16]
   d50da:	7465      	strb	r5, [r4, #17]
  bmpInfoHeader->Width               = width;                               
  bmpInfoHeader->Height              = -height;                              // negative height flips vertically
   d50dc:	f1c8 0800 	rsb	r8, r8, #0
                                                                            // so image isn't upside down 
                                                                            // but Google Chorme doesn't support that!!! 
  bmpInfoHeader->Planes              = 1;  
   d50e0:	76e5      	strb	r5, [r4, #27]
  bmpInfoHeader->BitsPerPixel        = bits;  
  //bmpInfoHeader->Compression         = 0; 
  bmpInfoHeader->SizeOfBitmap        = 0x03;                                 // BI_RGB (0), BI_BITFIELD (3)
   d50e2:	f884 2022 	strb.w	r2, [r4, #34]	; 0x22
   d50e6:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23
  bmpInfoHeader->HorzResolution      = 0x1000; 
   d50ea:	f04f 0210 	mov.w	r2, #16
                                                                            // so image isn't upside down 
                                                                            // but Google Chorme doesn't support that!!! 
  bmpInfoHeader->Planes              = 1;  
  bmpInfoHeader->BitsPerPixel        = bits;  
  //bmpInfoHeader->Compression         = 0; 
  bmpInfoHeader->SizeOfBitmap        = 0x03;                                 // BI_RGB (0), BI_BITFIELD (3)
   d50ee:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
   d50f2:	f884 5025 	strb.w	r5, [r4, #37]	; 0x25
  bmpInfoHeader->HorzResolution      = 0x1000; 
   d50f6:	f884 5026 	strb.w	r5, [r4, #38]	; 0x26
   d50fa:	f884 5028 	strb.w	r5, [r4, #40]	; 0x28
   d50fe:	f884 5029 	strb.w	r5, [r4, #41]	; 0x29
  bmpInfoHeader->VertResolution      = 0x1000; 
   d5102:	f884 502a 	strb.w	r5, [r4, #42]	; 0x2a
   d5106:	f884 502c 	strb.w	r5, [r4, #44]	; 0x2c
   d510a:	f884 502d 	strb.w	r5, [r4, #45]	; 0x2d
  bmpInfoHeader->ColorsUsed          =     
  bmpInfoHeader->ColorsImportant     = (bits <= 8) ? (1 << bits) : 0;        // <= 8bit use color palette
   d510e:	bfd8      	it	le
   d5110:	fa03 f506 	lslle.w	r5, r3, r6
  if (bits == 16)
   d5114:	2e10      	cmp	r6, #16
  //bmpFileHeader->bfReserved2         = 0;
  bmpFileHeader->bfOffBits           = headerSize
                                     + paletteSize;

  memset(bmpInfoHeader, 0, sizeof(BITMAPV5HEADER));
  bmpInfoHeader->Size                = sizeof(BITMAPV5HEADER);  
   d5116:	f884 a00e 	strb.w	sl, [r4, #14]
  bmpInfoHeader->Width               = width;                               
   d511a:	f8c4 9012 	str.w	r9, [r4, #18]
  bmpInfoHeader->Height              = -height;                              // negative height flips vertically
   d511e:	f8c4 8016 	str.w	r8, [r4, #22]
                                                                            // so image isn't upside down 
                                                                            // but Google Chorme doesn't support that!!! 
  bmpInfoHeader->Planes              = 1;  
   d5122:	76a3      	strb	r3, [r4, #26]
  bmpInfoHeader->BitsPerPixel        = bits;  
   d5124:	83a6      	strh	r6, [r4, #28]
  //bmpInfoHeader->Compression         = 0; 
  bmpInfoHeader->SizeOfBitmap        = 0x03;                                 // BI_RGB (0), BI_BITFIELD (3)
  bmpInfoHeader->HorzResolution      = 0x1000; 
   d5126:	f884 2027 	strb.w	r2, [r4, #39]	; 0x27
  bmpInfoHeader->VertResolution      = 0x1000; 
   d512a:	f884 202b 	strb.w	r2, [r4, #43]	; 0x2b
  bmpInfoHeader->ColorsUsed          =     
  bmpInfoHeader->ColorsImportant     = (bits <= 8) ? (1 << bits) : 0;        // <= 8bit use color palette
   d512e:	f8c4 5032 	str.w	r5, [r4, #50]	; 0x32
   d5132:	f8c4 502e 	str.w	r5, [r4, #46]	; 0x2e
  if (bits == 16)
   d5136:	d11e      	bne.n	d5176 <_Z9bmpHeaderPhiiiiii+0x10e>
  {  
    bmpInfoHeader->RedMask           = 0x0000f800;
   d5138:	f06f 0207 	mvn.w	r2, #7
   d513c:	f884 2037 	strb.w	r2, [r4, #55]	; 0x37
	bmpInfoHeader->GreenMask         = 0x000007e0;
   d5140:	f06f 021f 	mvn.w	r2, #31
   d5144:	f884 203a 	strb.w	r2, [r4, #58]	; 0x3a
   d5148:	2207      	movs	r2, #7
  bmpInfoHeader->VertResolution      = 0x1000; 
  bmpInfoHeader->ColorsUsed          =     
  bmpInfoHeader->ColorsImportant     = (bits <= 8) ? (1 << bits) : 0;        // <= 8bit use color palette
  if (bits == 16)
  {  
    bmpInfoHeader->RedMask           = 0x0000f800;
   d514a:	2300      	movs	r3, #0
	bmpInfoHeader->GreenMask         = 0x000007e0;
   d514c:	f884 203b 	strb.w	r2, [r4, #59]	; 0x3b
	bmpInfoHeader->BlueMask          = 0x0000001f;
   d5150:	221f      	movs	r2, #31
  bmpInfoHeader->VertResolution      = 0x1000; 
  bmpInfoHeader->ColorsUsed          =     
  bmpInfoHeader->ColorsImportant     = (bits <= 8) ? (1 << bits) : 0;        // <= 8bit use color palette
  if (bits == 16)
  {  
    bmpInfoHeader->RedMask           = 0x0000f800;
   d5152:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
   d5156:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
   d515a:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
	bmpInfoHeader->GreenMask         = 0x000007e0;
   d515e:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
   d5162:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
	bmpInfoHeader->BlueMask          = 0x0000001f;
   d5166:	f884 203e 	strb.w	r2, [r4, #62]	; 0x3e
   d516a:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
   d516e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
   d5172:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
   d5176:	f104 0146 	add.w	r1, r4, #70	; 0x46
  uint32_t          paletteSize     = (bits <= 8) ? (1 << (bits+2)) : 0;    // optional palette
  uint32_t          pixelDataSize   = height * ((width * (bits / 8)) + padding);  

  BITMAPFILEHEADER *bmpFileHeader   = (BITMAPFILEHEADER*)buf;
  BITMAPV5HEADER   *bmpInfoHeader   = (BITMAPV5HEADER*)(buf + sizeof(BITMAPFILEHEADER));
  uint8_t          *bmpPalette      = buf + headerSize; 
   d517a:	2000      	movs	r0, #0
  {
    uint8_t color = 255 * c / (bmpInfoHeader->ColorsUsed - 1);
    *(bmpPalette++) = color;
    *(bmpPalette++) = color;
    *(bmpPalette++) = color;
    *(bmpPalette++) = 0xFF;
   d517c:	25ff      	movs	r5, #255	; 0xff
    bmpInfoHeader->RedMask           = 0x0000f800;
	bmpInfoHeader->GreenMask         = 0x000007e0;
	bmpInfoHeader->BlueMask          = 0x0000001f;
  }

  for (int c = 0; c < bmpInfoHeader->ColorsUsed; c++)                         // grayscale color table
   d517e:	f8d4 302e 	ldr.w	r3, [r4, #46]	; 0x2e
   d5182:	4283      	cmp	r3, r0
   d5184:	f101 0104 	add.w	r1, r1, #4
   d5188:	d90f      	bls.n	d51aa <_Z9bmpHeaderPhiiiiii+0x142>
  {
    uint8_t color = 255 * c / (bmpInfoHeader->ColorsUsed - 1);
   d518a:	ebc0 2200 	rsb	r2, r0, r0, lsl #8
   d518e:	3b01      	subs	r3, #1
   d5190:	fbb2 f3f3 	udiv	r3, r2, r3
   d5194:	b2db      	uxtb	r3, r3
    *(bmpPalette++) = color;
   d5196:	f801 3c04 	strb.w	r3, [r1, #-4]
    *(bmpPalette++) = color;
   d519a:	f801 3c03 	strb.w	r3, [r1, #-3]
    *(bmpPalette++) = color;
   d519e:	f801 3c02 	strb.w	r3, [r1, #-2]
    *(bmpPalette++) = 0xFF;
   d51a2:	f801 5c01 	strb.w	r5, [r1, #-1]
    bmpInfoHeader->RedMask           = 0x0000f800;
	bmpInfoHeader->GreenMask         = 0x000007e0;
	bmpInfoHeader->BlueMask          = 0x0000001f;
  }

  for (int c = 0; c < bmpInfoHeader->ColorsUsed; c++)                         // grayscale color table
   d51a6:	3001      	adds	r0, #1
   d51a8:	e7e9      	b.n	d517e <_Z9bmpHeaderPhiiiiii+0x116>
    *(bmpPalette++) = color;
    *(bmpPalette++) = color;
    *(bmpPalette++) = color;
    *(bmpPalette++) = 0xFF;
  }
  Log.trace("BMP data offset: %d + %d + %d = %d, BMP file size: %d",  
   d51aa:	f8d4 3002 	ldr.w	r3, [r4, #2]
    sizeof(BITMAPFILEHEADER), sizeof(BITMAPV5HEADER), paletteSize, bmpFileHeader->bfOffBits, bmpFileHeader->bfSize);
   d51ae:	9302      	str	r3, [sp, #8]
    *(bmpPalette++) = color;
    *(bmpPalette++) = color;
    *(bmpPalette++) = color;
    *(bmpPalette++) = 0xFF;
  }
  Log.trace("BMP data offset: %d + %d + %d = %d, BMP file size: %d",  
   d51b0:	f8d4 300a 	ldr.w	r3, [r4, #10]
    sizeof(BITMAPFILEHEADER), sizeof(BITMAPV5HEADER), paletteSize, bmpFileHeader->bfOffBits, bmpFileHeader->bfSize);
   d51b4:	9301      	str	r3, [sp, #4]
   d51b6:	4808      	ldr	r0, [pc, #32]	; (d51d8 <_Z9bmpHeaderPhiiiiii+0x170>)
   d51b8:	9700      	str	r7, [sp, #0]
   d51ba:	2338      	movs	r3, #56	; 0x38
   d51bc:	220e      	movs	r2, #14
   d51be:	4907      	ldr	r1, [pc, #28]	; (d51dc <_Z9bmpHeaderPhiiiiii+0x174>)
   d51c0:	f7ff f81c 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>
  return bmpFileHeader->bfOffBits;
   d51c4:	f8d4 000a 	ldr.w	r0, [r4, #10]
   d51c8:	e000      	b.n	d51cc <_Z9bmpHeaderPhiiiiii+0x164>

  BITMAPFILEHEADER *bmpFileHeader   = (BITMAPFILEHEADER*)buf;
  BITMAPV5HEADER   *bmpInfoHeader   = (BITMAPV5HEADER*)(buf + sizeof(BITMAPFILEHEADER));
  uint8_t          *bmpPalette      = buf + headerSize; 

  if (len < headerSize + paletteSize) return 0;
   d51ca:	2000      	movs	r0, #0
    *(bmpPalette++) = 0xFF;
  }
  Log.trace("BMP data offset: %d + %d + %d = %d, BMP file size: %d",  
    sizeof(BITMAPFILEHEADER), sizeof(BITMAPV5HEADER), paletteSize, bmpFileHeader->bfOffBits, bmpFileHeader->bfSize);
  return bmpFileHeader->bfOffBits;
}  
   d51cc:	b004      	add	sp, #16
   d51ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   d51d2:	bf00      	nop
   d51d4:	000d94c0 	.word	0x000d94c0
   d51d8:	2003e2b0 	.word	0x2003e2b0
   d51dc:	000da312 	.word	0x000da312

000d51e0 <_Z12takeSnapshot6String>:
    
  return 0;
}

int takeSnapshot(String format) 
{
   d51e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  Log.trace(__FUNCTION__); 
   d51e4:	4973      	ldr	r1, [pc, #460]	; (d53b4 <_Z12takeSnapshot6String+0x1d4>)
    
  return 0;
}

int takeSnapshot(String format) 
{
   d51e6:	b08d      	sub	sp, #52	; 0x34
   d51e8:	4604      	mov	r4, r0
  Log.trace(__FUNCTION__); 
   d51ea:	4873      	ldr	r0, [pc, #460]	; (d53b8 <_Z12takeSnapshot6String+0x1d8>)
   d51ec:	f7ff f806 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>

  int retVal;
  
  if (format.equalsIgnoreCase("JPG") || format.equalsIgnoreCase("JPEG"))
   d51f0:	4972      	ldr	r1, [pc, #456]	; (d53bc <_Z12takeSnapshot6String+0x1dc>)
   d51f2:	a804      	add	r0, sp, #16
   d51f4:	f001 f889 	bl	d630a <_ZN6StringC1EPK19__FlashStringHelper>
   d51f8:	a904      	add	r1, sp, #16
   d51fa:	4620      	mov	r0, r4
   d51fc:	f001 f8e5 	bl	d63ca <_ZNK6String16equalsIgnoreCaseERKS_>
   d5200:	b970      	cbnz	r0, d5220 <_Z12takeSnapshot6String+0x40>
   d5202:	496f      	ldr	r1, [pc, #444]	; (d53c0 <_Z12takeSnapshot6String+0x1e0>)
   d5204:	a808      	add	r0, sp, #32
   d5206:	f001 f880 	bl	d630a <_ZN6StringC1EPK19__FlashStringHelper>
   d520a:	a908      	add	r1, sp, #32
   d520c:	4620      	mov	r0, r4
   d520e:	f001 f8dc 	bl	d63ca <_ZNK6String16equalsIgnoreCaseERKS_>
   d5212:	1c05      	adds	r5, r0, #0
   d5214:	a808      	add	r0, sp, #32
   d5216:	bf18      	it	ne
   d5218:	2501      	movne	r5, #1
   d521a:	f001 f82f 	bl	d627c <_ZN6StringD1Ev>
   d521e:	e000      	b.n	d5222 <_Z12takeSnapshot6String+0x42>
   d5220:	2501      	movs	r5, #1
   d5222:	a804      	add	r0, sp, #16
   d5224:	f001 f82a 	bl	d627c <_ZN6StringD1Ev>
   d5228:	4f66      	ldr	r7, [pc, #408]	; (d53c4 <_Z12takeSnapshot6String+0x1e4>)
   d522a:	b145      	cbz	r5, d523e <_Z12takeSnapshot6String+0x5e>
    retVal = prepareCam(uCamIII_SNAP_JPEG, uCamIII_COMP_JPEG, uCamIII_640x480, 
                       uCamIII_DEFAULT, uCamIII_DEFAULT, uCamIII_DEFAULT, snapTarget);
   d522c:	683b      	ldr	r3, [r7, #0]
   d522e:	9302      	str	r3, [sp, #8]
   d5230:	2207      	movs	r2, #7
   d5232:	2302      	movs	r3, #2
   d5234:	9301      	str	r3, [sp, #4]
   d5236:	9300      	str	r3, [sp, #0]
   d5238:	4611      	mov	r1, r2
   d523a:	2000      	movs	r0, #0
   d523c:	e03b      	b.n	d52b6 <_Z12takeSnapshot6String+0xd6>
  else if (format.equalsIgnoreCase("RGB16"))
   d523e:	4962      	ldr	r1, [pc, #392]	; (d53c8 <_Z12takeSnapshot6String+0x1e8>)
   d5240:	a808      	add	r0, sp, #32
   d5242:	f001 f862 	bl	d630a <_ZN6StringC1EPK19__FlashStringHelper>
   d5246:	a908      	add	r1, sp, #32
   d5248:	4620      	mov	r0, r4
   d524a:	f001 f8be 	bl	d63ca <_ZNK6String16equalsIgnoreCaseERKS_>
   d524e:	4605      	mov	r5, r0
   d5250:	a808      	add	r0, sp, #32
   d5252:	f001 f813 	bl	d627c <_ZN6StringD1Ev>
   d5256:	b13d      	cbz	r5, d5268 <_Z12takeSnapshot6String+0x88>
    retVal = prepareCam(uCamIII_SNAP_RAW, uCamIII_RAW_16BIT_RGB565, uCamIII_160x120, 
                       uCamIII_DEFAULT, uCamIII_DEFAULT, uCamIII_DEFAULT, snapTarget);
   d5258:	683b      	ldr	r3, [r7, #0]
   d525a:	9302      	str	r3, [sp, #8]
   d525c:	2302      	movs	r3, #2
   d525e:	9301      	str	r3, [sp, #4]
   d5260:	9300      	str	r3, [sp, #0]
   d5262:	2203      	movs	r2, #3
   d5264:	2106      	movs	r1, #6
   d5266:	e025      	b.n	d52b4 <_Z12takeSnapshot6String+0xd4>
  else if (format.equalsIgnoreCase("UYVY16") || format.equalsIgnoreCase("CrYCbY16"))
   d5268:	4958      	ldr	r1, [pc, #352]	; (d53cc <_Z12takeSnapshot6String+0x1ec>)
   d526a:	a804      	add	r0, sp, #16
   d526c:	f001 f84d 	bl	d630a <_ZN6StringC1EPK19__FlashStringHelper>
   d5270:	a904      	add	r1, sp, #16
   d5272:	4620      	mov	r0, r4
   d5274:	f001 f8a9 	bl	d63ca <_ZNK6String16equalsIgnoreCaseERKS_>
   d5278:	b970      	cbnz	r0, d5298 <_Z12takeSnapshot6String+0xb8>
   d527a:	4955      	ldr	r1, [pc, #340]	; (d53d0 <_Z12takeSnapshot6String+0x1f0>)
   d527c:	a808      	add	r0, sp, #32
   d527e:	f001 f844 	bl	d630a <_ZN6StringC1EPK19__FlashStringHelper>
   d5282:	a908      	add	r1, sp, #32
   d5284:	4620      	mov	r0, r4
   d5286:	f001 f8a0 	bl	d63ca <_ZNK6String16equalsIgnoreCaseERKS_>
   d528a:	1c04      	adds	r4, r0, #0
   d528c:	a808      	add	r0, sp, #32
   d528e:	bf18      	it	ne
   d5290:	2401      	movne	r4, #1
   d5292:	f000 fff3 	bl	d627c <_ZN6StringD1Ev>
   d5296:	e000      	b.n	d529a <_Z12takeSnapshot6String+0xba>
   d5298:	2401      	movs	r4, #1
   d529a:	a804      	add	r0, sp, #16
   d529c:	f000 ffee 	bl	d627c <_ZN6StringD1Ev>
    retVal = prepareCam(uCamIII_SNAP_RAW, uCamIII_RAW_16BIT_CRYCBY, uCamIII_160x120, 
                       uCamIII_DEFAULT, uCamIII_DEFAULT, uCamIII_DEFAULT, snapTarget);
   d52a0:	683a      	ldr	r2, [r7, #0]
   d52a2:	9202      	str	r2, [sp, #8]
   d52a4:	2302      	movs	r3, #2
   d52a6:	9301      	str	r3, [sp, #4]
   d52a8:	9300      	str	r3, [sp, #0]
   d52aa:	2203      	movs	r2, #3
    retVal = prepareCam(uCamIII_SNAP_JPEG, uCamIII_COMP_JPEG, uCamIII_640x480, 
                       uCamIII_DEFAULT, uCamIII_DEFAULT, uCamIII_DEFAULT, snapTarget);
  else if (format.equalsIgnoreCase("RGB16"))
    retVal = prepareCam(uCamIII_SNAP_RAW, uCamIII_RAW_16BIT_RGB565, uCamIII_160x120, 
                       uCamIII_DEFAULT, uCamIII_DEFAULT, uCamIII_DEFAULT, snapTarget);
  else if (format.equalsIgnoreCase("UYVY16") || format.equalsIgnoreCase("CrYCbY16"))
   d52ac:	b10c      	cbz	r4, d52b2 <_Z12takeSnapshot6String+0xd2>
    retVal = prepareCam(uCamIII_SNAP_RAW, uCamIII_RAW_16BIT_CRYCBY, uCamIII_160x120, 
                       uCamIII_DEFAULT, uCamIII_DEFAULT, uCamIII_DEFAULT, snapTarget);
   d52ae:	2108      	movs	r1, #8
   d52b0:	e000      	b.n	d52b4 <_Z12takeSnapshot6String+0xd4>
  else // default to "GRAY8"
    retVal = prepareCam(uCamIII_SNAP_RAW, uCamIII_RAW_8BIT, uCamIII_160x120, 
                       uCamIII_DEFAULT, uCamIII_DEFAULT, uCamIII_DEFAULT, snapTarget);
   d52b2:	4611      	mov	r1, r2
   d52b4:	2001      	movs	r0, #1
   d52b6:	f7ff fd13 	bl	d4ce0 <_Z10prepareCam17uCamIII_SNAP_TYPE20uCamIII_IMAGE_FORMAT11uCamIII_RES11uCamIII_CBES2_S2_PFiPhiiE>

  if (retVal <= 0) return retVal;
   d52ba:	2800      	cmp	r0, #0
   d52bc:	dd76      	ble.n	d53ac <_Z12takeSnapshot6String+0x1cc>
  
  if (retVal = imageSize = ucam.getPicture((uCamIII_PIC_TYPE)imageType))
   d52be:	4d45      	ldr	r5, [pc, #276]	; (d53d4 <_Z12takeSnapshot6String+0x1f4>)
   d52c0:	4845      	ldr	r0, [pc, #276]	; (d53d8 <_Z12takeSnapshot6String+0x1f8>)
   d52c2:	7829      	ldrb	r1, [r5, #0]
   d52c4:	4e45      	ldr	r6, [pc, #276]	; (d53dc <_Z12takeSnapshot6String+0x1fc>)
   d52c6:	f000 fc4f 	bl	d5b68 <_ZN12uCamIII_Base10getPictureE16uCamIII_PIC_TYPE>
   d52ca:	4604      	mov	r4, r0
   d52cc:	6030      	str	r0, [r6, #0]
   d52ce:	2800      	cmp	r0, #0
   d52d0:	d068      	beq.n	d53a4 <_Z12takeSnapshot6String+0x1c4>
  {
    Log.info("\r\nImageSize: %d", imageSize);
   d52d2:	4602      	mov	r2, r0
   d52d4:	4942      	ldr	r1, [pc, #264]	; (d53e0 <_Z12takeSnapshot6String+0x200>)
   d52d6:	4838      	ldr	r0, [pc, #224]	; (d53b8 <_Z12takeSnapshot6String+0x1d8>)
   d52d8:	f7fe ffa7 	bl	d422a <_ZNK5spark6Logger4infoEPKcz>

    if (imageType == uCamIII_SNAP_JPEG)
   d52dc:	682d      	ldr	r5, [r5, #0]
   d52de:	b9dd      	cbnz	r5, d5318 <_Z12takeSnapshot6String+0x138>
      for (int received = 0, chunk = 0; (received < imageSize) && (chunk = ucam.getJpegData(&imageBuffer[constrain(received, 0, sizeof(imageBuffer)-512)], 512, snapTarget)); received += chunk);
   d52e0:	f8df 8100 	ldr.w	r8, [pc, #256]	; d53e4 <_Z12takeSnapshot6String+0x204>
   d52e4:	f249 4986 	movw	r9, #38022	; 0x9486
   d52e8:	6833      	ldr	r3, [r6, #0]
   d52ea:	429d      	cmp	r5, r3
   d52ec:	da4f      	bge.n	d538e <_Z12takeSnapshot6String+0x1ae>
   d52ee:	454d      	cmp	r5, r9
   d52f0:	f04f 33ff 	mov.w	r3, #4294967295
   d52f4:	4629      	mov	r1, r5
   d52f6:	9300      	str	r3, [sp, #0]
   d52f8:	bfa8      	it	ge
   d52fa:	4649      	movge	r1, r9
   d52fc:	683b      	ldr	r3, [r7, #0]
   d52fe:	4836      	ldr	r0, [pc, #216]	; (d53d8 <_Z12takeSnapshot6String+0x1f8>)
   d5300:	f44f 7200 	mov.w	r2, #512	; 0x200
   d5304:	2900      	cmp	r1, #0
   d5306:	bfac      	ite	ge
   d5308:	4441      	addge	r1, r8
   d530a:	f108 0100 	addlt.w	r1, r8, #0
   d530e:	f000 fa83 	bl	d5818 <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi>
   d5312:	2800      	cmp	r0, #0
   d5314:	d148      	bne.n	d53a8 <_Z12takeSnapshot6String+0x1c8>
   d5316:	e03a      	b.n	d538e <_Z12takeSnapshot6String+0x1ae>
    else if (imageSize <= sizeof(imageBuffer)) 
   d5318:	6833      	ldr	r3, [r6, #0]
   d531a:	f249 6186 	movw	r1, #38534	; 0x9686
   d531e:	428b      	cmp	r3, r1
   d5320:	d835      	bhi.n	d538e <_Z12takeSnapshot6String+0x1ae>
    {
      int offset = bmpHeader(imageBuffer, sizeof(imageBuffer), imageWidth, imageHeight, imagePxDepth);
   d5322:	2400      	movs	r4, #0
   d5324:	f8df 90cc 	ldr.w	r9, [pc, #204]	; d53f4 <_Z12takeSnapshot6String+0x214>
   d5328:	9402      	str	r4, [sp, #8]
   d532a:	9401      	str	r4, [sp, #4]
   d532c:	f8d9 3000 	ldr.w	r3, [r9]
   d5330:	9300      	str	r3, [sp, #0]
   d5332:	4d2c      	ldr	r5, [pc, #176]	; (d53e4 <_Z12takeSnapshot6String+0x204>)
   d5334:	4b2c      	ldr	r3, [pc, #176]	; (d53e8 <_Z12takeSnapshot6String+0x208>)
   d5336:	4a2d      	ldr	r2, [pc, #180]	; (d53ec <_Z12takeSnapshot6String+0x20c>)
   d5338:	681b      	ldr	r3, [r3, #0]
   d533a:	6812      	ldr	r2, [r2, #0]
   d533c:	4628      	mov	r0, r5
   d533e:	f7ff fe93 	bl	d5068 <_Z9bmpHeaderPhiiiiii>
      retVal     = ucam.getRawData(&imageBuffer[offset], imageSize, NULL);
   d5342:	4405      	add	r5, r0
   d5344:	4623      	mov	r3, r4

    if (imageType == uCamIII_SNAP_JPEG)
      for (int received = 0, chunk = 0; (received < imageSize) && (chunk = ucam.getJpegData(&imageBuffer[constrain(received, 0, sizeof(imageBuffer)-512)], 512, snapTarget)); received += chunk);
    else if (imageSize <= sizeof(imageBuffer)) 
    {
      int offset = bmpHeader(imageBuffer, sizeof(imageBuffer), imageWidth, imageHeight, imagePxDepth);
   d5346:	4680      	mov	r8, r0
      retVal     = ucam.getRawData(&imageBuffer[offset], imageSize, NULL);
   d5348:	6832      	ldr	r2, [r6, #0]
   d534a:	4823      	ldr	r0, [pc, #140]	; (d53d8 <_Z12takeSnapshot6String+0x1f8>)
   d534c:	4629      	mov	r1, r5
   d534e:	f000 faef 	bl	d5930 <_ZN12uCamIII_Base10getRawDataEPhiPFiS0_iiE>

      if (imagePxDepth == 16) 
   d5352:	f8d9 3000 	ldr.w	r3, [r9]
   d5356:	2b10      	cmp	r3, #16
    if (imageType == uCamIII_SNAP_JPEG)
      for (int received = 0, chunk = 0; (received < imageSize) && (chunk = ucam.getJpegData(&imageBuffer[constrain(received, 0, sizeof(imageBuffer)-512)], 512, snapTarget)); received += chunk);
    else if (imageSize <= sizeof(imageBuffer)) 
    {
      int offset = bmpHeader(imageBuffer, sizeof(imageBuffer), imageWidth, imageHeight, imagePxDepth);
      retVal     = ucam.getRawData(&imageBuffer[offset], imageSize, NULL);
   d5358:	4604      	mov	r4, r0

      if (imagePxDepth == 16) 
   d535a:	d112      	bne.n	d5382 <_Z12takeSnapshot6String+0x1a2>
      {
        for (int i = offset; i < imageSize + offset; i += 2)    // raw image comes big-endian and upside down from cam,
   d535c:	6833      	ldr	r3, [r6, #0]
   d535e:	4629      	mov	r1, r5
   d5360:	eb08 0203 	add.w	r2, r8, r3
   d5364:	4643      	mov	r3, r8
   d5366:	4293      	cmp	r3, r2
   d5368:	f101 0102 	add.w	r1, r1, #2
   d536c:	da09      	bge.n	d5382 <_Z12takeSnapshot6String+0x1a2>
        {                                                       // this block corrects endianness
          uint8_t dmy = imageBuffer[i];
   d536e:	f811 0c02 	ldrb.w	r0, [r1, #-2]
          imageBuffer[i] = imageBuffer[i+1];
   d5372:	f811 5c01 	ldrb.w	r5, [r1, #-1]
   d5376:	f801 5c02 	strb.w	r5, [r1, #-2]
          imageBuffer[i+1] = dmy;
   d537a:	f801 0c01 	strb.w	r0, [r1, #-1]
      int offset = bmpHeader(imageBuffer, sizeof(imageBuffer), imageWidth, imageHeight, imagePxDepth);
      retVal     = ucam.getRawData(&imageBuffer[offset], imageSize, NULL);

      if (imagePxDepth == 16) 
      {
        for (int i = offset; i < imageSize + offset; i += 2)    // raw image comes big-endian and upside down from cam,
   d537e:	3302      	adds	r3, #2
   d5380:	e7f1      	b.n	d5366 <_Z12takeSnapshot6String+0x186>
          uint8_t dmy = imageBuffer[i];
          imageBuffer[i] = imageBuffer[i+1];
          imageBuffer[i+1] = dmy;
        }
      }
      snapTarget(imageBuffer, imageSize + offset, 0);
   d5382:	6831      	ldr	r1, [r6, #0]
   d5384:	683b      	ldr	r3, [r7, #0]
   d5386:	4817      	ldr	r0, [pc, #92]	; (d53e4 <_Z12takeSnapshot6String+0x204>)
   d5388:	2200      	movs	r2, #0
   d538a:	4441      	add	r1, r8
   d538c:	4798      	blx	r3
    }

    if (client.connected())                                     // if the TCP client would still be connected
   d538e:	4818      	ldr	r0, [pc, #96]	; (d53f0 <_Z12takeSnapshot6String+0x210>)
   d5390:	f001 ff85 	bl	d729e <_ZN9TCPClient9connectedEv>
   d5394:	b110      	cbz	r0, d539c <_Z12takeSnapshot6String+0x1bc>
      client.stop();                                            // stop the connection
   d5396:	4816      	ldr	r0, [pc, #88]	; (d53f0 <_Z12takeSnapshot6String+0x210>)
   d5398:	f002 f954 	bl	d7644 <_ZN9TCPClient4stopEv>

    digitalWrite(D7, LOW);
   d539c:	2100      	movs	r1, #0
   d539e:	2007      	movs	r0, #7
   d53a0:	f002 fb4b 	bl	d7a3a <digitalWrite>

    return retVal;
  }

  return 0;
   d53a4:	4620      	mov	r0, r4
   d53a6:	e001      	b.n	d53ac <_Z12takeSnapshot6String+0x1cc>
  if (retVal = imageSize = ucam.getPicture((uCamIII_PIC_TYPE)imageType))
  {
    Log.info("\r\nImageSize: %d", imageSize);

    if (imageType == uCamIII_SNAP_JPEG)
      for (int received = 0, chunk = 0; (received < imageSize) && (chunk = ucam.getJpegData(&imageBuffer[constrain(received, 0, sizeof(imageBuffer)-512)], 512, snapTarget)); received += chunk);
   d53a8:	4405      	add	r5, r0
   d53aa:	e79d      	b.n	d52e8 <_Z12takeSnapshot6String+0x108>

    return retVal;
  }

  return 0;
}
   d53ac:	b00d      	add	sp, #52	; 0x34
   d53ae:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   d53b2:	bf00      	nop
   d53b4:	000d94b3 	.word	0x000d94b3
   d53b8:	2003e2b0 	.word	0x2003e2b0
   d53bc:	000da348 	.word	0x000da348
   d53c0:	000da34c 	.word	0x000da34c
   d53c4:	20034980 	.word	0x20034980
   d53c8:	000da351 	.word	0x000da351
   d53cc:	000da357 	.word	0x000da357
   d53d0:	000da35e 	.word	0x000da35e
   d53d4:	20034984 	.word	0x20034984
   d53d8:	20034b74 	.word	0x20034b74
   d53dc:	2003e294 	.word	0x2003e294
   d53e0:	000da367 	.word	0x000da367
   d53e4:	20034bcc 	.word	0x20034bcc
   d53e8:	20034a44 	.word	0x20034a44
   d53ec:	20034bc8 	.word	0x20034bc8
   d53f0:	20034b90 	.word	0x20034b90
   d53f4:	20034b70 	.word	0x20034b70

000d53f8 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb>:
  server.print(strScript);
  server.printP(Page_end);
}

void imageCmd(WebServer &server, WebServer::ConnectionType type, char *url_tail, bool tail_complete)
{
   d53f8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  Log.trace(__FUNCTION__); 

  if (imageSize = ucam.getPicture((uCamIII_PIC_TYPE)imageType))
   d53fc:	4c52      	ldr	r4, [pc, #328]	; (d5548 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x150>)
  server.printP(Page_end);
}

void imageCmd(WebServer &server, WebServer::ConnectionType type, char *url_tail, bool tail_complete)
{
  Log.trace(__FUNCTION__); 
   d53fe:	4953      	ldr	r1, [pc, #332]	; (d554c <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x154>)

  if (imageSize = ucam.getPicture((uCamIII_PIC_TYPE)imageType))
   d5400:	4d53      	ldr	r5, [pc, #332]	; (d5550 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x158>)
  server.print(strScript);
  server.printP(Page_end);
}

void imageCmd(WebServer &server, WebServer::ConnectionType type, char *url_tail, bool tail_complete)
{
   d5402:	b085      	sub	sp, #20
   d5404:	4680      	mov	r8, r0
  Log.trace(__FUNCTION__); 
   d5406:	4853      	ldr	r0, [pc, #332]	; (d5554 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x15c>)
   d5408:	f7fe fef8 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>

  if (imageSize = ucam.getPicture((uCamIII_PIC_TYPE)imageType))
   d540c:	7821      	ldrb	r1, [r4, #0]
   d540e:	4852      	ldr	r0, [pc, #328]	; (d5558 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x160>)
   d5410:	f000 fbaa 	bl	d5b68 <_ZN12uCamIII_Base10getPictureE16uCamIII_PIC_TYPE>
   d5414:	4602      	mov	r2, r0
   d5416:	6028      	str	r0, [r5, #0]
   d5418:	2800      	cmp	r0, #0
   d541a:	f000 8091 	beq.w	d5540 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x148>
  {
    Log.info("\r\nImageSize: %d", imageSize);
   d541e:	494f      	ldr	r1, [pc, #316]	; (d555c <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x164>)
   d5420:	484c      	ldr	r0, [pc, #304]	; (d5554 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x15c>)
   d5422:	f7fe ff02 	bl	d422a <_ZNK5spark6Logger4infoEPKcz>

    if (imageType == uCamIII_SNAP_JPEG)
   d5426:	6824      	ldr	r4, [r4, #0]
   d5428:	b9e4      	cbnz	r4, d5464 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x6c>
    {
      Log.info("get JPEG chunks");
   d542a:	494d      	ldr	r1, [pc, #308]	; (d5560 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x168>)
   d542c:	4849      	ldr	r0, [pc, #292]	; (d5554 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x15c>)
      for (int received = 0, chunk = 0; (received < imageSize) && (chunk = ucam.getJpegData(&imageBuffer[constrain(received, 0, sizeof(imageBuffer)-512)], 512, callbackWebServer)); received += chunk);
   d542e:	4e4d      	ldr	r6, [pc, #308]	; (d5564 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x16c>)
  {
    Log.info("\r\nImageSize: %d", imageSize);

    if (imageType == uCamIII_SNAP_JPEG)
    {
      Log.info("get JPEG chunks");
   d5430:	f7fe fefb 	bl	d422a <_ZNK5spark6Logger4infoEPKcz>
      for (int received = 0, chunk = 0; (received < imageSize) && (chunk = ucam.getJpegData(&imageBuffer[constrain(received, 0, sizeof(imageBuffer)-512)], 512, callbackWebServer)); received += chunk);
   d5434:	682b      	ldr	r3, [r5, #0]
   d5436:	429c      	cmp	r4, r3
   d5438:	da79      	bge.n	d552e <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x136>
   d543a:	f249 4186 	movw	r1, #38022	; 0x9486
   d543e:	42a1      	cmp	r1, r4
   d5440:	bfa8      	it	ge
   d5442:	4621      	movge	r1, r4
   d5444:	f04f 33ff 	mov.w	r3, #4294967295
   d5448:	9300      	str	r3, [sp, #0]
   d544a:	f44f 7200 	mov.w	r2, #512	; 0x200
   d544e:	4b46      	ldr	r3, [pc, #280]	; (d5568 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x170>)
   d5450:	4841      	ldr	r0, [pc, #260]	; (d5558 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x160>)
   d5452:	2900      	cmp	r1, #0
   d5454:	bfac      	ite	ge
   d5456:	1871      	addge	r1, r6, r1
   d5458:	1c31      	addlt	r1, r6, #0
   d545a:	f000 f9dd 	bl	d5818 <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi>
   d545e:	2800      	cmp	r0, #0
   d5460:	d16c      	bne.n	d553c <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x144>
   d5462:	e064      	b.n	d552e <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x136>
    }
    else if (imageSize <= sizeof(imageBuffer)) 
   d5464:	682a      	ldr	r2, [r5, #0]
   d5466:	f249 6686 	movw	r6, #38534	; 0x9686
   d546a:	42b2      	cmp	r2, r6
   d546c:	d85a      	bhi.n	d5524 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x12c>
    {
      Log.info("get RAW image");

      int offset = bmpHeader(imageBuffer, sizeof(imageBuffer), imageWidth, imageHeight, imagePxDepth);
   d546e:	f8df 911c 	ldr.w	r9, [pc, #284]	; d558c <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x194>
      Log.info("get JPEG chunks");
      for (int received = 0, chunk = 0; (received < imageSize) && (chunk = ucam.getJpegData(&imageBuffer[constrain(received, 0, sizeof(imageBuffer)-512)], 512, callbackWebServer)); received += chunk);
    }
    else if (imageSize <= sizeof(imageBuffer)) 
    {
      Log.info("get RAW image");
   d5472:	493e      	ldr	r1, [pc, #248]	; (d556c <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x174>)
   d5474:	4837      	ldr	r0, [pc, #220]	; (d5554 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x15c>)

      int offset = bmpHeader(imageBuffer, sizeof(imageBuffer), imageWidth, imageHeight, imagePxDepth);
   d5476:	4c3b      	ldr	r4, [pc, #236]	; (d5564 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x16c>)
      Log.info("get JPEG chunks");
      for (int received = 0, chunk = 0; (received < imageSize) && (chunk = ucam.getJpegData(&imageBuffer[constrain(received, 0, sizeof(imageBuffer)-512)], 512, callbackWebServer)); received += chunk);
    }
    else if (imageSize <= sizeof(imageBuffer)) 
    {
      Log.info("get RAW image");
   d5478:	f7fe fed7 	bl	d422a <_ZNK5spark6Logger4infoEPKcz>

      int offset = bmpHeader(imageBuffer, sizeof(imageBuffer), imageWidth, imageHeight, imagePxDepth);
   d547c:	f8d9 3000 	ldr.w	r3, [r9]
   d5480:	9300      	str	r3, [sp, #0]
   d5482:	2700      	movs	r7, #0
   d5484:	4b3a      	ldr	r3, [pc, #232]	; (d5570 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x178>)
   d5486:	4a3b      	ldr	r2, [pc, #236]	; (d5574 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x17c>)
   d5488:	9702      	str	r7, [sp, #8]
   d548a:	9701      	str	r7, [sp, #4]
   d548c:	681b      	ldr	r3, [r3, #0]
   d548e:	6812      	ldr	r2, [r2, #0]
   d5490:	4631      	mov	r1, r6
   d5492:	4620      	mov	r0, r4
   d5494:	f7ff fde8 	bl	d5068 <_Z9bmpHeaderPhiiiiii>
   d5498:	4606      	mov	r6, r0
Log.trace("after bmpHeader (%d)", offset);
   d549a:	4602      	mov	r2, r0
   d549c:	4936      	ldr	r1, [pc, #216]	; (d5578 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x180>)
   d549e:	482d      	ldr	r0, [pc, #180]	; (d5554 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x15c>)
      int size   = ucam.getRawData(&imageBuffer[offset], imageSize, NULL);
   d54a0:	4434      	add	r4, r6
    else if (imageSize <= sizeof(imageBuffer)) 
    {
      Log.info("get RAW image");

      int offset = bmpHeader(imageBuffer, sizeof(imageBuffer), imageWidth, imageHeight, imagePxDepth);
Log.trace("after bmpHeader (%d)", offset);
   d54a2:	f7fe feab 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>
      int size   = ucam.getRawData(&imageBuffer[offset], imageSize, NULL);
   d54a6:	463b      	mov	r3, r7
   d54a8:	682a      	ldr	r2, [r5, #0]
   d54aa:	482b      	ldr	r0, [pc, #172]	; (d5558 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x160>)
   d54ac:	4621      	mov	r1, r4
   d54ae:	f000 fa3f 	bl	d5930 <_ZN12uCamIII_Base10getRawDataEPhiPFiS0_iiE>
Log.trace("after getRawData (%d)", size);
   d54b2:	4932      	ldr	r1, [pc, #200]	; (d557c <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x184>)
   d54b4:	4602      	mov	r2, r0
    {
      Log.info("get RAW image");

      int offset = bmpHeader(imageBuffer, sizeof(imageBuffer), imageWidth, imageHeight, imagePxDepth);
Log.trace("after bmpHeader (%d)", offset);
      int size   = ucam.getRawData(&imageBuffer[offset], imageSize, NULL);
   d54b6:	4607      	mov	r7, r0
Log.trace("after getRawData (%d)", size);
   d54b8:	4826      	ldr	r0, [pc, #152]	; (d5554 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x15c>)
   d54ba:	f7fe fe9f 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>

      if (imagePxDepth == 16) 
   d54be:	f8d9 3000 	ldr.w	r3, [r9]
   d54c2:	2b10      	cmp	r3, #16
   d54c4:	d111      	bne.n	d54ea <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0xf2>
      {
        for (int i = offset; i < imageSize + offset; i += 2)    // raw image comes big-endian and upside down from cam,
   d54c6:	682b      	ldr	r3, [r5, #0]
   d54c8:	4621      	mov	r1, r4
   d54ca:	18f2      	adds	r2, r6, r3
   d54cc:	4633      	mov	r3, r6
   d54ce:	4293      	cmp	r3, r2
   d54d0:	f101 0102 	add.w	r1, r1, #2
   d54d4:	da09      	bge.n	d54ea <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0xf2>
        {                                                       // this block corrects endianness
          uint8_t dmy = imageBuffer[i];
   d54d6:	f811 0c02 	ldrb.w	r0, [r1, #-2]
          imageBuffer[i] = imageBuffer[i+1];
   d54da:	f811 4c01 	ldrb.w	r4, [r1, #-1]
   d54de:	f801 4c02 	strb.w	r4, [r1, #-2]
          imageBuffer[i+1] = dmy;
   d54e2:	f801 0c01 	strb.w	r0, [r1, #-1]
      int size   = ucam.getRawData(&imageBuffer[offset], imageSize, NULL);
Log.trace("after getRawData (%d)", size);

      if (imagePxDepth == 16) 
      {
        for (int i = offset; i < imageSize + offset; i += 2)    // raw image comes big-endian and upside down from cam,
   d54e6:	3302      	adds	r3, #2
   d54e8:	e7f1      	b.n	d54ce <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0xd6>
          imageBuffer[i] = imageBuffer[i+1];
          imageBuffer[i+1] = dmy;
        }
      }
        
Log.trace("before server write (%d + %d = %d / %d == %d)", imageSize, offset, imageSize + offset, imageSize, size);
   d54ea:	682a      	ldr	r2, [r5, #0]
   d54ec:	9201      	str	r2, [sp, #4]
   d54ee:	18b3      	adds	r3, r6, r2
   d54f0:	9300      	str	r3, [sp, #0]
   d54f2:	9702      	str	r7, [sp, #8]
   d54f4:	4633      	mov	r3, r6
   d54f6:	4922      	ldr	r1, [pc, #136]	; (d5580 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x188>)
   d54f8:	4816      	ldr	r0, [pc, #88]	; (d5554 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x15c>)
   d54fa:	f7fe fe7f 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>
      server.write(imageBuffer, imageSize + offset);
   d54fe:	682a      	ldr	r2, [r5, #0]
   d5500:	f8d8 3000 	ldr.w	r3, [r8]
   d5504:	4917      	ldr	r1, [pc, #92]	; (d5564 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x16c>)
   d5506:	68db      	ldr	r3, [r3, #12]
   d5508:	4432      	add	r2, r6
   d550a:	4640      	mov	r0, r8
   d550c:	4798      	blx	r3
Log.trace("after server write (%d + %d = %d / %d == %d)", imageSize, offset, imageSize + offset, imageSize, size);
   d550e:	682a      	ldr	r2, [r5, #0]
   d5510:	9702      	str	r7, [sp, #8]
   d5512:	18b3      	adds	r3, r6, r2
   d5514:	9300      	str	r3, [sp, #0]
   d5516:	9201      	str	r2, [sp, #4]
   d5518:	4633      	mov	r3, r6
   d551a:	491a      	ldr	r1, [pc, #104]	; (d5584 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x18c>)
   d551c:	480d      	ldr	r0, [pc, #52]	; (d5554 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x15c>)
   d551e:	f7fe fe6d 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>
   d5522:	e004      	b.n	d552e <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x136>
    }
else
{
Log.trace("raw too big for buffer %d <= %d", imageSize, sizeof(imageBuffer));
   d5524:	4633      	mov	r3, r6
   d5526:	4918      	ldr	r1, [pc, #96]	; (d5588 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x190>)
   d5528:	480a      	ldr	r0, [pc, #40]	; (d5554 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x15c>)
   d552a:	f7fe fe67 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>
}
    digitalWrite(D7, LOW);
   d552e:	2100      	movs	r1, #0
   d5530:	2007      	movs	r0, #7
  }
  
  //server.write(imageBuffer, imageSize);
}
   d5532:	b005      	add	sp, #20
   d5534:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    }
else
{
Log.trace("raw too big for buffer %d <= %d", imageSize, sizeof(imageBuffer));
}
    digitalWrite(D7, LOW);
   d5538:	f002 ba7f 	b.w	d7a3a <digitalWrite>
    Log.info("\r\nImageSize: %d", imageSize);

    if (imageType == uCamIII_SNAP_JPEG)
    {
      Log.info("get JPEG chunks");
      for (int received = 0, chunk = 0; (received < imageSize) && (chunk = ucam.getJpegData(&imageBuffer[constrain(received, 0, sizeof(imageBuffer)-512)], 512, callbackWebServer)); received += chunk);
   d553c:	4404      	add	r4, r0
   d553e:	e779      	b.n	d5434 <_Z8imageCmdR9WebServerNS_14ConnectionTypeEPcb+0x3c>
}
    digitalWrite(D7, LOW);
  }
  
  //server.write(imageBuffer, imageSize);
}
   d5540:	b005      	add	sp, #20
   d5542:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   d5546:	bf00      	nop
   d5548:	20034984 	.word	0x20034984
   d554c:	000d95a6 	.word	0x000d95a6
   d5550:	2003e294 	.word	0x2003e294
   d5554:	2003e2b0 	.word	0x2003e2b0
   d5558:	20034b74 	.word	0x20034b74
   d555c:	000da367 	.word	0x000da367
   d5560:	000da377 	.word	0x000da377
   d5564:	20034bcc 	.word	0x20034bcc
   d5568:	000d4465 	.word	0x000d4465
   d556c:	000da387 	.word	0x000da387
   d5570:	20034a44 	.word	0x20034a44
   d5574:	20034bc8 	.word	0x20034bc8
   d5578:	000da395 	.word	0x000da395
   d557c:	000da3aa 	.word	0x000da3aa
   d5580:	000da3c0 	.word	0x000da3c0
   d5584:	000da3ee 	.word	0x000da3ee
   d5588:	000da41b 	.word	0x000da41b
   d558c:	20034b70 	.word	0x20034b70

000d5590 <_ZN10TCPClientXD0Ev>:
   d5590:	b510      	push	{r4, lr}
   d5592:	4604      	mov	r4, r0
   d5594:	f7fe fe1e 	bl	d41d4 <_ZN10TCPClientXD1Ev>
   d5598:	4620      	mov	r0, r4
   d559a:	2124      	movs	r1, #36	; 0x24
   d559c:	f002 fab4 	bl	d7b08 <_ZdlPvj>
   d55a0:	4620      	mov	r0, r4
   d55a2:	bd10      	pop	{r4, pc}

000d55a4 <_GLOBAL__sub_I__ZN9WebServerC2EPKct>:
    *(bmpPalette++) = 0xFF;
  }
  Log.trace("BMP data offset: %d + %d + %d = %d, BMP file size: %d",  
    sizeof(BITMAPFILEHEADER), sizeof(BITMAPV5HEADER), paletteSize, bmpFileHeader->bfOffBits, bmpFileHeader->bfSize);
  return bmpFileHeader->bfOffBits;
}  
   d55a4:	b538      	push	{r3, r4, r5, lr}
 * of "", all pages will be at the root of the server. */
const char PREFIX[] = "";
const int  NAMELEN  = 32;
const int  VALUELEN = 32;

WebServer webserver(PREFIX, 80);
   d55a6:	4c1c      	ldr	r4, [pc, #112]	; (d5618 <_GLOBAL__sub_I__ZN9WebServerC2EPKct+0x74>)
   d55a8:	4d1c      	ldr	r5, [pc, #112]	; (d561c <_GLOBAL__sub_I__ZN9WebServerC2EPKct+0x78>)

inline void pinSetFast(pin_t _pin) __attribute__((always_inline));
inline void pinResetFast(pin_t _pin) __attribute__((always_inline));
inline int32_t pinReadFast(pin_t _pin) __attribute__((always_inline));

static Hal_Pin_Info* PIN_MAP = HAL_Pin_Map();
   d55aa:	f000 fb0f 	bl	d5bcc <HAL_Pin_Map>
   d55ae:	2250      	movs	r2, #80	; 0x50
   d55b0:	491b      	ldr	r1, [pc, #108]	; (d5620 <_GLOBAL__sub_I__ZN9WebServerC2EPKct+0x7c>)
   d55b2:	4620      	mov	r0, r4
   d55b4:	f7fe fefc 	bl	d43b0 <_ZN9WebServerC1EPKct>
   d55b8:	462a      	mov	r2, r5
   d55ba:	491a      	ldr	r1, [pc, #104]	; (d5624 <_GLOBAL__sub_I__ZN9WebServerC2EPKct+0x80>)
   d55bc:	4620      	mov	r0, r4
   d55be:	f002 fa95 	bl	d7aec <__aeabi_atexit>
                uCamIII_CBE contrast      = uCamIII_DEFAULT,
                uCamIII_CBE brightness    = uCamIII_DEFAULT,
                uCamIII_CBE exposure      = uCamIII_DEFAULT,
                uCamIII_callback callback = NULL);

uCamIII<USARTSerial> ucam(Serial1, A0, 500);                        // use HW Serial1 and A0 as reset pin for uCamIII
   d55c2:	f001 fd23 	bl	d700c <_Z22__fetch_global_Serial1v>
typedef int (*uCamIII_callback)(uint8_t* buffer, int len, int id);

class uCamIII_Base {
public:
  uCamIII_Base(Stream& cameraStream, int resetPin = -1, uint32_t timeout = 500) 
  : _cameraStream(cameraStream), _resetPin(resetPin), _timeout(timeout), _imageSize(0), _packageSize(64), _packageNumber(0), _lastError(0) { } 
   d55c6:	4b18      	ldr	r3, [pc, #96]	; (d5628 <_GLOBAL__sub_I__ZN9WebServerC2EPKct+0x84>)
int         imagePxDepth  = 0;
int         imageTime     = 0;
char        lIP[16];


IPAddress   serverAddr;
   d55c8:	4c18      	ldr	r4, [pc, #96]	; (d562c <_GLOBAL__sub_I__ZN9WebServerC2EPKct+0x88>)
   d55ca:	6018      	str	r0, [r3, #0]
   d55cc:	2213      	movs	r2, #19
   d55ce:	605a      	str	r2, [r3, #4]
   d55d0:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
   d55d4:	609a      	str	r2, [r3, #8]
   d55d6:	2140      	movs	r1, #64	; 0x40
   d55d8:	2200      	movs	r2, #0
   d55da:	60da      	str	r2, [r3, #12]
   d55dc:	8219      	strh	r1, [r3, #16]
   d55de:	825a      	strh	r2, [r3, #18]
   d55e0:	751a      	strb	r2, [r3, #20]

template <class serial>
class uCamIII : public uCamIII_Base {
public:
  uCamIII(serial& camera, int resetPin = -1, uint32_t timeout = 500) 
  : uCamIII_Base(camera, resetPin, timeout), _cameraInterface(camera) { } 
   d55e2:	6198      	str	r0, [r3, #24]
   d55e4:	4620      	mov	r0, r4
   d55e6:	f001 fbcb 	bl	d6d80 <_ZN9IPAddressC1Ev>
   d55ea:	4620      	mov	r0, r4

public:
    TCPClientX(size_t chunk = 512, uint32_t flushDelay = 100) 
    : TCPClient(), chunkSize(chunk), flushDelayTime(flushDelay) { }
   d55ec:	4c10      	ldr	r4, [pc, #64]	; (d5630 <_GLOBAL__sub_I__ZN9WebServerC2EPKct+0x8c>)
   d55ee:	4911      	ldr	r1, [pc, #68]	; (d5634 <_GLOBAL__sub_I__ZN9WebServerC2EPKct+0x90>)
   d55f0:	462a      	mov	r2, r5
   d55f2:	f002 fa7b 	bl	d7aec <__aeabi_atexit>
   d55f6:	4620      	mov	r0, r4
   d55f8:	f002 f8d8 	bl	d77ac <_ZN9TCPClientC1Ev>
   d55fc:	4b0e      	ldr	r3, [pc, #56]	; (d5638 <_GLOBAL__sub_I__ZN9WebServerC2EPKct+0x94>)
   d55fe:	6023      	str	r3, [r4, #0]
   d5600:	f44f 6380 	mov.w	r3, #1024	; 0x400
   d5604:	61e3      	str	r3, [r4, #28]
   d5606:	2364      	movs	r3, #100	; 0x64
   d5608:	6223      	str	r3, [r4, #32]
int         serverPort;
char        nonce[34];
#if Wiring_WiFi
  TCPClientX client(1024, 100);
   d560a:	462a      	mov	r2, r5
   d560c:	4620      	mov	r0, r4
   d560e:	490b      	ldr	r1, [pc, #44]	; (d563c <_GLOBAL__sub_I__ZN9WebServerC2EPKct+0x98>)
    *(bmpPalette++) = 0xFF;
  }
  Log.trace("BMP data offset: %d + %d + %d = %d, BMP file size: %d",  
    sizeof(BITMAPFILEHEADER), sizeof(BITMAPV5HEADER), paletteSize, bmpFileHeader->bfOffBits, bmpFileHeader->bfSize);
  return bmpFileHeader->bfOffBits;
}  
   d5610:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

IPAddress   serverAddr;
int         serverPort;
char        nonce[34];
#if Wiring_WiFi
  TCPClientX client(1024, 100);
   d5614:	f002 ba6a 	b.w	d7aec <__aeabi_atexit>
   d5618:	20034a48 	.word	0x20034a48
   d561c:	20034a40 	.word	0x20034a40
   d5620:	000da43b 	.word	0x000da43b
   d5624:	000d418d 	.word	0x000d418d
   d5628:	20034b74 	.word	0x20034b74
   d562c:	2003e27c 	.word	0x2003e27c
   d5630:	20034b90 	.word	0x20034b90
   d5634:	000d40c9 	.word	0x000d40c9
   d5638:	000da444 	.word	0x000da444
   d563c:	000d41d5 	.word	0x000d41d5

000d5640 <_GLOBAL__sub_I_MinimumSerial.cpp>:
   d5640:	f000 bac4 	b.w	d5bcc <HAL_Pin_Map>

000d5644 <_GLOBAL__sub_I__ZN7istream3getEv>:
   d5644:	f000 bac2 	b.w	d5bcc <HAL_Pin_Map>

000d5648 <_GLOBAL__sub_I__ZN7FatFile11lfnChecksumEPh>:
   d5648:	f000 bac0 	b.w	d5bcc <HAL_Pin_Map>

000d564c <_GLOBAL__sub_I__ZN11StdioStream6fcloseEv>:
   d564c:	f000 babe 	b.w	d5bcc <HAL_Pin_Map>

000d5650 <_GLOBAL__sub_I__ZN7ostream7do_fillEj>:
   d5650:	f000 babc 	b.w	d5bcc <HAL_Pin_Map>

000d5654 <_GLOBAL__sub_I__ZN7FatFile6getSFNEPc>:
   d5654:	f000 baba 	b.w	d5bcc <HAL_Pin_Map>

000d5658 <_GLOBAL__sub_I__ZN7FatFile5m_cwdE>:
   d5658:	f000 bab8 	b.w	d5bcc <HAL_Pin_Map>

000d565c <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
   d565c:	b570      	push	{r4, r5, r6, lr}
   d565e:	4605      	mov	r5, r0
      if (str == NULL) return 0;
   d5660:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
   d5662:	4608      	mov	r0, r1
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
   d5664:	b149      	cbz	r1, d567a <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
   d5666:	f003 fa61 	bl	d8b2c <strlen>
   d566a:	682b      	ldr	r3, [r5, #0]
   d566c:	4602      	mov	r2, r0
   d566e:	4621      	mov	r1, r4
   d5670:	4628      	mov	r0, r5
   d5672:	68db      	ldr	r3, [r3, #12]
    }
   d5674:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
   d5678:	4718      	bx	r3
    }
   d567a:	bd70      	pop	{r4, r5, r6, pc}

000d567c <_GLOBAL__sub_I__ZN7FatFile7dmpFileEP5Printmj>:
   d567c:	f000 baa6 	b.w	d5bcc <HAL_Pin_Map>

000d5680 <_GLOBAL__sub_I__ZN13FatStreamBase5getchEv>:
   d5680:	f000 baa4 	b.w	d5bcc <HAL_Pin_Map>

000d5684 <_GLOBAL__sub_I__ZN8FatCache4readEmh>:
   d5684:	f000 baa2 	b.w	d5bcc <HAL_Pin_Map>

000d5688 <_GLOBAL__sub_I__ZN10SdioCardEX9readBlockEmPh>:
   d5688:	f000 baa0 	b.w	d5bcc <HAL_Pin_Map>

000d568c <_GLOBAL__sub_I__ZN11SdSpiCardEX9readBlockEmPh>:
   d568c:	f000 ba9e 	b.w	d5bcc <HAL_Pin_Map>

000d5690 <_GLOBAL__sub_I__ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle13__SPISettingsE>:
   d5690:	f000 ba9c 	b.w	d5bcc <HAL_Pin_Map>

000d5694 <_GLOBAL__sub_I_SdSpiSAM3X.cpp>:
   d5694:	f000 ba9a 	b.w	d5bcc <HAL_Pin_Map>

000d5698 <_GLOBAL__sub_I_SdSpiTeensy3.cpp>:
   d5698:	f000 ba98 	b.w	d5bcc <HAL_Pin_Map>

000d569c <_GLOBAL__sub_I__ZN14SdSpiAltDriver8activateEv>:
   d569c:	f000 ba96 	b.w	d5bcc <HAL_Pin_Map>

000d56a0 <_ZN10TCPClientX5writeEPKhj>:
#include <TCPClientX.h>

size_t TCPClientX::write(const uint8_t *buffer, size_t size)
{
   d56a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
   d56a4:	4f15      	ldr	r7, [pc, #84]	; (d56fc <_ZN10TCPClientX5writeEPKhj+0x5c>)
   d56a6:	4605      	mov	r5, r0
   d56a8:	4688      	mov	r8, r1
   d56aa:	4616      	mov	r6, r2
  size_t pos; 
  for (pos = 0; pos < size;)
   d56ac:	2400      	movs	r4, #0
   d56ae:	42b4      	cmp	r4, r6
   d56b0:	d221      	bcs.n	d56f6 <_ZN10TCPClientX5writeEPKhj+0x56>
  {
    if (size - pos < chunkSize) chunkSize = size - pos;
   d56b2:	69ea      	ldr	r2, [r5, #28]
   d56b4:	1b33      	subs	r3, r6, r4
   d56b6:	4293      	cmp	r3, r2
   d56b8:	bf38      	it	cc
   d56ba:	61eb      	strcc	r3, [r5, #28]
    int sent = TCPClient::write(&buffer[pos], chunkSize);
   d56bc:	69ea      	ldr	r2, [r5, #28]
   d56be:	eb08 0104 	add.w	r1, r8, r4
   d56c2:	4628      	mov	r0, r5
   d56c4:	f001 fdd5 	bl	d7272 <_ZN9TCPClient5writeEPKhj>
    if (sent == chunkSize)
   d56c8:	69eb      	ldr	r3, [r5, #28]
   d56ca:	4298      	cmp	r0, r3
   d56cc:	d101      	bne.n	d56d2 <_ZN10TCPClientX5writeEPKhj+0x32>
      pos += chunkSize;
   d56ce:	4404      	add	r4, r0
   d56d0:	e7ed      	b.n	d56ae <_ZN10TCPClientX5writeEPKhj+0xe>
    else if (sent == -16) 
   d56d2:	3010      	adds	r0, #16
   d56d4:	d1eb      	bne.n	d56ae <_ZN10TCPClientX5writeEPKhj+0xe>
   d56d6:	f000 fac1 	bl	d5c5c <HAL_Timer_Get_Milli_Seconds>
   d56da:	4681      	mov	r9, r0
   d56dc:	f000 fabe 	bl	d5c5c <HAL_Timer_Get_Milli_Seconds>
      for (uint32_t ms = millis(); millis() - ms < flushDelayTime; Particle.process());
   d56e0:	6a2b      	ldr	r3, [r5, #32]
   d56e2:	ebc9 0000 	rsb	r0, r9, r0
   d56e6:	4298      	cmp	r0, r3
   d56e8:	d2e1      	bcs.n	d56ae <_ZN10TCPClientX5writeEPKhj+0xe>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
   d56ea:	f000 fab7 	bl	d5c5c <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
   d56ee:	6038      	str	r0, [r7, #0]
        spark_cloud_flag_connect();
    }
    static void disconnect(void) { spark_cloud_flag_disconnect(); }
    static void process(void) {
    		application_checkin();
    		spark_process();
   d56f0:	f000 fcd8 	bl	d60a4 <spark_process>
   d56f4:	e7f2      	b.n	d56dc <_ZN10TCPClientX5writeEPKhj+0x3c>
  }
  return pos;
}
   d56f6:	4620      	mov	r0, r4
   d56f8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   d56fc:	2003e608 	.word	0x2003e608

000d5700 <_GLOBAL__sub_I__ZN10TCPClientX5writeEPKhj>:
   d5700:	f000 ba64 	b.w	d5bcc <HAL_Pin_Map>

000d5704 <_ZNK5spark6Logger3logE8LogLevelPKcSt9__va_list>:
    va_start(args, fmt);
    log(level, fmt, args);
    va_end(args);
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
   d5704:	b510      	push	{r4, lr}
   d5706:	b08a      	sub	sp, #40	; 0x28
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
    attr.flags = 0;
    log_message_v(level, name_, &attr, nullptr, fmt, args);
   d5708:	e88d 000c 	stmia.w	sp, {r2, r3}
    va_start(args, fmt);
    log(level, fmt, args);
    va_end(args);
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
   d570c:	460c      	mov	r4, r1
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
   d570e:	2120      	movs	r1, #32
   d5710:	9102      	str	r1, [sp, #8]
    attr.flags = 0;
   d5712:	2100      	movs	r1, #0
   d5714:	9103      	str	r1, [sp, #12]
    log_message_v(level, name_, &attr, nullptr, fmt, args);
   d5716:	460b      	mov	r3, r1
   d5718:	aa02      	add	r2, sp, #8
   d571a:	6801      	ldr	r1, [r0, #0]
   d571c:	4620      	mov	r0, r4
   d571e:	f000 fc1d 	bl	d5f5c <log_message_v>
}
   d5722:	b00a      	add	sp, #40	; 0x28
   d5724:	bd10      	pop	{r4, pc}
	...

000d5728 <_ZN12uCamIII_Base5yieldEv.isra.0>:
  long              sendCmdWithAck(uCamIII_CMD cmd, uint8_t p1 = 0, uint8_t p2 = 0, uint8_t p3 = 0, uint8_t p4 = 0);
  long              expectPackage(uCamIII_CMD pkg, uint8_t option = uCamIII_DONT_CARE);
  long              init();
  
#if defined(PARTICLE)
  inline void       yield() 
   d5728:	b508      	push	{r3, lr}
                    { Log.trace(__FUNCTION__); Particle.process(); }
   d572a:	4906      	ldr	r1, [pc, #24]	; (d5744 <_ZN12uCamIII_Base5yieldEv.isra.0+0x1c>)
   d572c:	4806      	ldr	r0, [pc, #24]	; (d5748 <_ZN12uCamIII_Base5yieldEv.isra.0+0x20>)
   d572e:	f7fe fd65 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
   d5732:	f000 fa93 	bl	d5c5c <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
   d5736:	4b05      	ldr	r3, [pc, #20]	; (d574c <_ZN12uCamIII_Base5yieldEv.isra.0+0x24>)
   d5738:	6018      	str	r0, [r3, #0]
   d573a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   d573e:	f000 bcb1 	b.w	d60a4 <spark_process>
   d5742:	bf00      	nop
   d5744:	000da579 	.word	0x000da579
   d5748:	2003e2b0 	.word	0x2003e2b0
   d574c:	2003e608 	.word	0x2003e608

000d5750 <_ZNK5spark6Logger4warnEPKcz>:
    va_start(args, fmt);
    log(LOG_LEVEL_INFO, fmt, args);
    va_end(args);
}

inline void spark::Logger::warn(const char *fmt, ...) const {
   d5750:	b40e      	push	{r1, r2, r3}
   d5752:	b503      	push	{r0, r1, lr}
   d5754:	ab03      	add	r3, sp, #12
    va_list args;
    va_start(args, fmt);
    log(LOG_LEVEL_WARN, fmt, args);
   d5756:	2128      	movs	r1, #40	; 0x28
    va_start(args, fmt);
    log(LOG_LEVEL_INFO, fmt, args);
    va_end(args);
}

inline void spark::Logger::warn(const char *fmt, ...) const {
   d5758:	f853 2b04 	ldr.w	r2, [r3], #4
    va_list args;
    va_start(args, fmt);
   d575c:	9301      	str	r3, [sp, #4]
    log(LOG_LEVEL_WARN, fmt, args);
   d575e:	f7ff ffd1 	bl	d5704 <_ZNK5spark6Logger3logE8LogLevelPKcSt9__va_list>
    va_end(args);
}
   d5762:	b002      	add	sp, #8
   d5764:	f85d eb04 	ldr.w	lr, [sp], #4
   d5768:	b003      	add	sp, #12
   d576a:	4770      	bx	lr

000d576c <_ZN12uCamIII_Base9hardResetEv>:
  
  return 0;
}

void uCamIII_Base::hardReset()
{
   d576c:	b510      	push	{r4, lr}
   d576e:	4604      	mov	r4, r0
  Log.trace(__FUNCTION__); 
   d5770:	490d      	ldr	r1, [pc, #52]	; (d57a8 <_ZN12uCamIII_Base9hardResetEv+0x3c>)
   d5772:	480e      	ldr	r0, [pc, #56]	; (d57ac <_ZN12uCamIII_Base9hardResetEv+0x40>)
   d5774:	f7fe fd42 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>

  if (_resetPin > 0)
   d5778:	6860      	ldr	r0, [r4, #4]
   d577a:	2800      	cmp	r0, #0
   d577c:	dd13      	ble.n	d57a6 <_ZN12uCamIII_Base9hardResetEv+0x3a>
  {
    pinMode(_resetPin, OUTPUT);
   d577e:	2101      	movs	r1, #1
   d5780:	b280      	uxth	r0, r0
   d5782:	f002 f949 	bl	d7a18 <pinMode>
    digitalWrite(_resetPin, LOW);
   d5786:	2100      	movs	r1, #0
   d5788:	88a0      	ldrh	r0, [r4, #4]
   d578a:	f002 f956 	bl	d7a3a <digitalWrite>
    delay(10);
   d578e:	200a      	movs	r0, #10
   d5790:	f000 fffe 	bl	d6790 <delay>
    pinMode(_resetPin, INPUT);
   d5794:	88a0      	ldrh	r0, [r4, #4]
   d5796:	2100      	movs	r1, #0
   d5798:	f002 f93e 	bl	d7a18 <pinMode>
    delay(10);
   d579c:	200a      	movs	r0, #10
  }
}
   d579e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  {
    pinMode(_resetPin, OUTPUT);
    digitalWrite(_resetPin, LOW);
    delay(10);
    pinMode(_resetPin, INPUT);
    delay(10);
   d57a2:	f000 bff5 	b.w	d6790 <delay>
   d57a6:	bd10      	pop	{r4, pc}
   d57a8:	000da57f 	.word	0x000da57f
   d57ac:	2003e2b0 	.word	0x2003e2b0

000d57b0 <_ZN12uCamIII_Base7sendCmdE11uCamIII_CMDhhhh>:
}

// ----------------------------------- protected ----------------------------------------

long uCamIII_Base::sendCmd(uCamIII_CMD cmd, uint8_t p1, uint8_t p2, uint8_t p3, uint8_t p4)
{
   d57b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   d57b4:	b086      	sub	sp, #24
  Log.trace(__FUNCTION__); 
   d57b6:	4c15      	ldr	r4, [pc, #84]	; (d580c <_ZN12uCamIII_Base7sendCmdE11uCamIII_CMDhhhh+0x5c>)
}

// ----------------------------------- protected ----------------------------------------

long uCamIII_Base::sendCmd(uCamIII_CMD cmd, uint8_t p1, uint8_t p2, uint8_t p3, uint8_t p4)
{
   d57b8:	f89d 8038 	ldrb.w	r8, [sp, #56]	; 0x38
   d57bc:	f89d 903c 	ldrb.w	r9, [sp, #60]	; 0x3c
   d57c0:	4616      	mov	r6, r2
   d57c2:	461f      	mov	r7, r3
   d57c4:	460d      	mov	r5, r1
   d57c6:	4682      	mov	sl, r0
  Log.trace(__FUNCTION__); 
   d57c8:	4911      	ldr	r1, [pc, #68]	; (d5810 <_ZN12uCamIII_Base7sendCmdE11uCamIII_CMDhhhh+0x60>)
   d57ca:	4620      	mov	r0, r4
   d57cc:	f7fe fd16 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>

  uint8_t buf[6] = { uCamIII_STARTBYTE, cmd, p1, p2, p3, p4 };
   d57d0:	22aa      	movs	r2, #170	; 0xaa
  Log.info("sendCmd: %02X %02X %02X %02X %02X %02X", buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);
   d57d2:	462b      	mov	r3, r5
   d57d4:	4620      	mov	r0, r4
   d57d6:	e88d 03c0 	stmia.w	sp, {r6, r7, r8, r9}
   d57da:	490e      	ldr	r1, [pc, #56]	; (d5814 <_ZN12uCamIII_Base7sendCmdE11uCamIII_CMDhhhh+0x64>)

long uCamIII_Base::sendCmd(uCamIII_CMD cmd, uint8_t p1, uint8_t p2, uint8_t p3, uint8_t p4)
{
  Log.trace(__FUNCTION__); 

  uint8_t buf[6] = { uCamIII_STARTBYTE, cmd, p1, p2, p3, p4 };
   d57dc:	f88d 2010 	strb.w	r2, [sp, #16]
   d57e0:	f88d 5011 	strb.w	r5, [sp, #17]
   d57e4:	f88d 6012 	strb.w	r6, [sp, #18]
   d57e8:	f88d 7013 	strb.w	r7, [sp, #19]
   d57ec:	f88d 8014 	strb.w	r8, [sp, #20]
   d57f0:	f88d 9015 	strb.w	r9, [sp, #21]
  Log.info("sendCmd: %02X %02X %02X %02X %02X %02X", buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);
   d57f4:	f7fe fd19 	bl	d422a <_ZNK5spark6Logger4infoEPKcz>
  return _cameraStream.write(buf, 6);
   d57f8:	f8da 0000 	ldr.w	r0, [sl]
   d57fc:	6803      	ldr	r3, [r0, #0]
   d57fe:	2206      	movs	r2, #6
   d5800:	68db      	ldr	r3, [r3, #12]
   d5802:	a904      	add	r1, sp, #16
   d5804:	4798      	blx	r3
}
   d5806:	b006      	add	sp, #24
   d5808:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   d580c:	2003e2b0 	.word	0x2003e2b0
   d5810:	000da488 	.word	0x000da488
   d5814:	000da4ae 	.word	0x000da4ae

000d5818 <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi>:
  return 0;
}


long uCamIII_Base::getJpegData(uint8_t *buffer, int len, uCamIII_callback callback, int package)
{
   d5818:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   d581c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   d581e:	4605      	mov	r5, r0
   d5820:	4688      	mov	r8, r1
  Log.trace(__FUNCTION__); 
   d5822:	4841      	ldr	r0, [pc, #260]	; (d5928 <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0x110>)
   d5824:	4941      	ldr	r1, [pc, #260]	; (d592c <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0x114>)
  return 0;
}


long uCamIII_Base::getJpegData(uint8_t *buffer, int len, uCamIII_callback callback, int package)
{
   d5826:	4616      	mov	r6, r2
   d5828:	4699      	mov	r9, r3
  Log.trace(__FUNCTION__); 
   d582a:	f7fe fce7 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>
   d582e:	f000 fa15 	bl	d5c5c <HAL_Timer_Get_Milli_Seconds>

  uint16_t        id    = 0;
  uint16_t        size  = 0;
  uint32_t        ms    = millis();

  if (package >= 0) _packageNumber = package;           // request specific package
   d5832:	2c00      	cmp	r4, #0
   d5834:	bfa8      	it	ge
   d5836:	826c      	strhge	r4, [r5, #18]
  
  if (sendCmd(uCamIII_CMD_ACK, 0x00, 0x00, _packageNumber & 0xFF, _packageNumber >> 8))
   d5838:	8a6b      	ldrh	r3, [r5, #18]
   d583a:	0a1a      	lsrs	r2, r3, #8
   d583c:	b2db      	uxtb	r3, r3
   d583e:	9300      	str	r3, [sp, #0]
   d5840:	2300      	movs	r3, #0
   d5842:	4607      	mov	r7, r0
   d5844:	9201      	str	r2, [sp, #4]
   d5846:	210e      	movs	r1, #14
   d5848:	461a      	mov	r2, r3
   d584a:	4628      	mov	r0, r5
   d584c:	f7ff ffb0 	bl	d57b0 <_ZN12uCamIII_Base7sendCmdE11uCamIII_CMDhhhh>
   d5850:	b320      	cbz	r0, d589c <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0x84>
  {
    char info[4];
    char chk[2];
    if (_cameraStream.readBytes(info, sizeof(info)) == sizeof(info))
   d5852:	2204      	movs	r2, #4
   d5854:	a903      	add	r1, sp, #12
   d5856:	6828      	ldr	r0, [r5, #0]
   d5858:	f000 fe5c 	bl	d6514 <_ZN6Stream9readBytesEPcj>
   d585c:	2804      	cmp	r0, #4
   d585e:	d12d      	bne.n	d58bc <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0xa4>
    {
      id   = info[0] | info[1] << 8;
      size = info[2] | info[3] << 8;
   d5860:	f89d 400f 	ldrb.w	r4, [sp, #15]
   d5864:	f89d 300e 	ldrb.w	r3, [sp, #14]
    }
    
    if (!size || size > len 
    || _cameraStream.readBytes((char*)buffer, size) != size
    || _cameraStream.readBytes(chk, sizeof(chk)) != sizeof(chk)
   d5868:	ea53 2404 	orrs.w	r4, r3, r4, lsl #8
   d586c:	d027      	beq.n	d58be <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0xa6>
    {
      id   = info[0] | info[1] << 8;
      size = info[2] | info[3] << 8;
    }
    
    if (!size || size > len 
   d586e:	42b4      	cmp	r4, r6
   d5870:	dc25      	bgt.n	d58be <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0xa6>
    || _cameraStream.readBytes((char*)buffer, size) != size
   d5872:	4622      	mov	r2, r4
   d5874:	4641      	mov	r1, r8
   d5876:	6828      	ldr	r0, [r5, #0]
  {
    char info[4];
    char chk[2];
    if (_cameraStream.readBytes(info, sizeof(info)) == sizeof(info))
    {
      id   = info[0] | info[1] << 8;
   d5878:	f89d 600c 	ldrb.w	r6, [sp, #12]
   d587c:	f89d a00d 	ldrb.w	sl, [sp, #13]
      size = info[2] | info[3] << 8;
    }
    
    if (!size || size > len 
    || _cameraStream.readBytes((char*)buffer, size) != size
   d5880:	f000 fe48 	bl	d6514 <_ZN6Stream9readBytesEPcj>
   d5884:	4284      	cmp	r4, r0
   d5886:	d11a      	bne.n	d58be <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0xa6>
    || _cameraStream.readBytes(chk, sizeof(chk)) != sizeof(chk)
   d5888:	2202      	movs	r2, #2
   d588a:	a902      	add	r1, sp, #8
   d588c:	6828      	ldr	r0, [r5, #0]
   d588e:	f000 fe41 	bl	d6514 <_ZN6Stream9readBytesEPcj>
   d5892:	2802      	cmp	r0, #2
   d5894:	d113      	bne.n	d58be <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0xa6>
  {
    char info[4];
    char chk[2];
    if (_cameraStream.readBytes(info, sizeof(info)) == sizeof(info))
    {
      id   = info[0] | info[1] << 8;
   d5896:	ea46 260a 	orr.w	r6, r6, sl, lsl #8
   d589a:	e001      	b.n	d58a0 <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0x88>
long uCamIII_Base::getJpegData(uint8_t *buffer, int len, uCamIII_callback callback, int package)
{
  Log.trace(__FUNCTION__); 

  uint16_t        id    = 0;
  uint16_t        size  = 0;
   d589c:	4604      	mov	r4, r0

long uCamIII_Base::getJpegData(uint8_t *buffer, int len, uCamIII_callback callback, int package)
{
  Log.trace(__FUNCTION__); 

  uint16_t        id    = 0;
   d589e:	4606      	mov	r6, r0
      while(_cameraStream.read() >= 0 && millis() - ms < _timeout) yield();
      id = 0xF0F0;                                      // prepare for termination of request
    }
  }

  if (id * (_packageSize - 6) >= _imageSize || millis() - ms >= _timeout)
   d58a0:	f9b5 3010 	ldrsh.w	r3, [r5, #16]
   d58a4:	68ea      	ldr	r2, [r5, #12]
   d58a6:	3b06      	subs	r3, #6
   d58a8:	4373      	muls	r3, r6
   d58aa:	4293      	cmp	r3, r2
   d58ac:	da1f      	bge.n	d58ee <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0xd6>
   d58ae:	f000 f9d5 	bl	d5c5c <HAL_Timer_Get_Milli_Seconds>
   d58b2:	68ab      	ldr	r3, [r5, #8]
   d58b4:	1bc0      	subs	r0, r0, r7
   d58b6:	4298      	cmp	r0, r3
   d58b8:	d219      	bcs.n	d58ee <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0xd6>
   d58ba:	e030      	b.n	d591e <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0x106>
long uCamIII_Base::getJpegData(uint8_t *buffer, int len, uCamIII_callback callback, int package)
{
  Log.trace(__FUNCTION__); 

  uint16_t        id    = 0;
  uint16_t        size  = 0;
   d58bc:	2400      	movs	r4, #0
    if (!size || size > len 
    || _cameraStream.readBytes((char*)buffer, size) != size
    || _cameraStream.readBytes(chk, sizeof(chk)) != sizeof(chk)
    ) 
    {                                                   // if the expected data didn't arrive in time                                                   
      delay(100);                                       // allow for extra bytes to trickle in and then
   d58be:	2064      	movs	r0, #100	; 0x64
   d58c0:	f000 ff66 	bl	d6790 <delay>
   d58c4:	f000 f9ca 	bl	d5c5c <HAL_Timer_Get_Milli_Seconds>
   d58c8:	4607      	mov	r7, r0
      ms = millis();                                    // flush the RX buffer and
      while(_cameraStream.read() >= 0 && millis() - ms < _timeout) yield();
   d58ca:	6828      	ldr	r0, [r5, #0]
   d58cc:	6803      	ldr	r3, [r0, #0]
   d58ce:	695b      	ldr	r3, [r3, #20]
   d58d0:	4798      	blx	r3
   d58d2:	2800      	cmp	r0, #0
   d58d4:	db08      	blt.n	d58e8 <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0xd0>
   d58d6:	f000 f9c1 	bl	d5c5c <HAL_Timer_Get_Milli_Seconds>
   d58da:	68ab      	ldr	r3, [r5, #8]
   d58dc:	1bc0      	subs	r0, r0, r7
   d58de:	4298      	cmp	r0, r3
   d58e0:	d202      	bcs.n	d58e8 <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0xd0>
   d58e2:	f7ff ff21 	bl	d5728 <_ZN12uCamIII_Base5yieldEv.isra.0>
   d58e6:	e7f0      	b.n	d58ca <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0xb2>
      id = 0xF0F0;                                      // prepare for termination of request
   d58e8:	f24f 06f0 	movw	r6, #61680	; 0xf0f0
   d58ec:	e7d8      	b.n	d58a0 <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0x88>
    }
  }

  if (id * (_packageSize - 6) >= _imageSize || millis() - ms >= _timeout)
    sendCmd(uCamIII_CMD_ACK, 0x00, 0x00, 0xF0, 0xF0);   // report end of final data request to camera
   d58ee:	23f0      	movs	r3, #240	; 0xf0
   d58f0:	9301      	str	r3, [sp, #4]
   d58f2:	9300      	str	r3, [sp, #0]
   d58f4:	2300      	movs	r3, #0
   d58f6:	461a      	mov	r2, r3
   d58f8:	210e      	movs	r1, #14
   d58fa:	4628      	mov	r0, r5
   d58fc:	f7ff ff58 	bl	d57b0 <_ZN12uCamIII_Base7sendCmdE11uCamIII_CMDhhhh>
  else
    _packageNumber = id;                                // prepare to request next package
  
  if (id < 0xF0F0)
   d5900:	f24f 03ef 	movw	r3, #61679	; 0xf0ef
   d5904:	429e      	cmp	r6, r3
   d5906:	d808      	bhi.n	d591a <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0x102>
  {
    if (callback) callback(buffer, size, id);
   d5908:	f1b9 0f00 	cmp.w	r9, #0
   d590c:	d003      	beq.n	d5916 <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0xfe>
   d590e:	4632      	mov	r2, r6
   d5910:	4621      	mov	r1, r4
   d5912:	4640      	mov	r0, r8
   d5914:	47c8      	blx	r9
    return size;    
   d5916:	4620      	mov	r0, r4
   d5918:	e003      	b.n	d5922 <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0x10a>
  }
  
  return 0;
   d591a:	2000      	movs	r0, #0
   d591c:	e001      	b.n	d5922 <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0x10a>
  }

  if (id * (_packageSize - 6) >= _imageSize || millis() - ms >= _timeout)
    sendCmd(uCamIII_CMD_ACK, 0x00, 0x00, 0xF0, 0xF0);   // report end of final data request to camera
  else
    _packageNumber = id;                                // prepare to request next package
   d591e:	826e      	strh	r6, [r5, #18]
   d5920:	e7ee      	b.n	d5900 <_ZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEi+0xe8>
    if (callback) callback(buffer, size, id);
    return size;    
  }
  
  return 0;
}
   d5922:	b004      	add	sp, #16
   d5924:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   d5928:	2003e2b0 	.word	0x2003e2b0
   d592c:	000da589 	.word	0x000da589

000d5930 <_ZN12uCamIII_Base10getRawDataEPhiPFiS0_iiE>:

long uCamIII_Base::getRawData(uint8_t *buffer, int len, uCamIII_callback callback)
{
   d5930:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (len >= _imageSize
   d5932:	68c5      	ldr	r5, [r0, #12]
  && _imageSize == (long)_cameraStream.readBytes((char*)buffer, _imageSize)
   d5934:	4295      	cmp	r5, r2
  
  return 0;
}

long uCamIII_Base::getRawData(uint8_t *buffer, int len, uCamIII_callback callback)
{
   d5936:	4604      	mov	r4, r0
   d5938:	460f      	mov	r7, r1
   d593a:	461e      	mov	r6, r3
  if (len >= _imageSize
  && _imageSize == (long)_cameraStream.readBytes((char*)buffer, _imageSize)
   d593c:	dc05      	bgt.n	d594a <_ZN12uCamIII_Base10getRawDataEPhiPFiS0_iiE+0x1a>
   d593e:	462a      	mov	r2, r5
   d5940:	6800      	ldr	r0, [r0, #0]
   d5942:	f000 fde7 	bl	d6514 <_ZN6Stream9readBytesEPcj>
   d5946:	4285      	cmp	r5, r0
   d5948:	d014      	beq.n	d5974 <_ZN12uCamIII_Base10getRawDataEPhiPFiS0_iiE+0x44>
    return _imageSize;       
  }
  else                                                  // if the expected data didn't arrive in time
  { 
    uint32_t ms;                                                                                         
    delay(100);                                         // allow for extra bytes to trickle in and then
   d594a:	2064      	movs	r0, #100	; 0x64
   d594c:	f000 ff20 	bl	d6790 <delay>
   d5950:	f000 f984 	bl	d5c5c <HAL_Timer_Get_Milli_Seconds>
   d5954:	4605      	mov	r5, r0
    ms = millis();                                      // flush the RX buffer
    while(_cameraStream.read() >= 0 && millis() - ms < _timeout) yield();
   d5956:	6820      	ldr	r0, [r4, #0]
   d5958:	6803      	ldr	r3, [r0, #0]
   d595a:	695b      	ldr	r3, [r3, #20]
   d595c:	4798      	blx	r3
   d595e:	2800      	cmp	r0, #0
   d5960:	db19      	blt.n	d5996 <_ZN12uCamIII_Base10getRawDataEPhiPFiS0_iiE+0x66>
   d5962:	f000 f97b 	bl	d5c5c <HAL_Timer_Get_Milli_Seconds>
   d5966:	68a3      	ldr	r3, [r4, #8]
   d5968:	1b40      	subs	r0, r0, r5
   d596a:	4298      	cmp	r0, r3
   d596c:	d213      	bcs.n	d5996 <_ZN12uCamIII_Base10getRawDataEPhiPFiS0_iiE+0x66>
   d596e:	f7ff fedb 	bl	d5728 <_ZN12uCamIII_Base5yieldEv.isra.0>
   d5972:	e7f0      	b.n	d5956 <_ZN12uCamIII_Base10getRawDataEPhiPFiS0_iiE+0x26>
{
  if (len >= _imageSize
  && _imageSize == (long)_cameraStream.readBytes((char*)buffer, _imageSize)
  )
  {                                                     // success -> report end of data request to camera
    sendCmd(uCamIII_CMD_ACK, uCamIII_CMD_DATA, 0x00, 0x01, 0x00);    
   d5974:	2301      	movs	r3, #1
   d5976:	2500      	movs	r5, #0
   d5978:	e88d 0028 	stmia.w	sp, {r3, r5}
   d597c:	220a      	movs	r2, #10
   d597e:	462b      	mov	r3, r5
   d5980:	210e      	movs	r1, #14
   d5982:	4620      	mov	r0, r4
   d5984:	f7ff ff14 	bl	d57b0 <_ZN12uCamIII_Base7sendCmdE11uCamIII_CMDhhhh>
    if (callback) callback(buffer, _imageSize, 0);
   d5988:	b11e      	cbz	r6, d5992 <_ZN12uCamIII_Base10getRawDataEPhiPFiS0_iiE+0x62>
   d598a:	462a      	mov	r2, r5
   d598c:	68e1      	ldr	r1, [r4, #12]
   d598e:	4638      	mov	r0, r7
   d5990:	47b0      	blx	r6
    return _imageSize;       
   d5992:	68e0      	ldr	r0, [r4, #12]
   d5994:	e000      	b.n	d5998 <_ZN12uCamIII_Base10getRawDataEPhiPFiS0_iiE+0x68>
    delay(100);                                         // allow for extra bytes to trickle in and then
    ms = millis();                                      // flush the RX buffer
    while(_cameraStream.read() >= 0 && millis() - ms < _timeout) yield();
  }
  
  return 0;
   d5996:	2000      	movs	r0, #0
}
   d5998:	b003      	add	sp, #12
   d599a:	bdf0      	pop	{r4, r5, r6, r7, pc}

000d599c <_ZN12uCamIII_Base13expectPackageE11uCamIII_CMDh>:
  sendCmd(cmd, p1, p2, p3, p4);
  return expectPackage(uCamIII_CMD_ACK, cmd);
}

long uCamIII_Base::expectPackage(uCamIII_CMD pkg, uint8_t option)
{
   d599c:	b5f0      	push	{r4, r5, r6, r7, lr}
   d599e:	b089      	sub	sp, #36	; 0x24
   d59a0:	4604      	mov	r4, r0
  Log.trace("%s(%02x,%02x)", __FUNCTION__, pkg, option); 
   d59a2:	460b      	mov	r3, r1
   d59a4:	9200      	str	r2, [sp, #0]
   d59a6:	482d      	ldr	r0, [pc, #180]	; (d5a5c <_ZN12uCamIII_Base13expectPackageE11uCamIII_CMDh+0xc0>)
  sendCmd(cmd, p1, p2, p3, p4);
  return expectPackage(uCamIII_CMD_ACK, cmd);
}

long uCamIII_Base::expectPackage(uCamIII_CMD pkg, uint8_t option)
{
   d59a8:	460f      	mov	r7, r1
   d59aa:	4615      	mov	r5, r2
  Log.trace("%s(%02x,%02x)", __FUNCTION__, pkg, option); 
   d59ac:	492c      	ldr	r1, [pc, #176]	; (d5a60 <_ZN12uCamIII_Base13expectPackageE11uCamIII_CMDh+0xc4>)
   d59ae:	4a2d      	ldr	r2, [pc, #180]	; (d5a64 <_ZN12uCamIII_Base13expectPackageE11uCamIII_CMDh+0xc8>)
   d59b0:	f7fe fc24 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>
  uint8_t buf[6];
  memset(buf, 0x00, sizeof(buf));
   d59b4:	2600      	movs	r6, #0

  if (_cameraStream.readBytes((char*)buf, sizeof(buf)) == sizeof(buf))
   d59b6:	2206      	movs	r2, #6
   d59b8:	a906      	add	r1, sp, #24
   d59ba:	6820      	ldr	r0, [r4, #0]

long uCamIII_Base::expectPackage(uCamIII_CMD pkg, uint8_t option)
{
  Log.trace("%s(%02x,%02x)", __FUNCTION__, pkg, option); 
  uint8_t buf[6];
  memset(buf, 0x00, sizeof(buf));
   d59bc:	9606      	str	r6, [sp, #24]
   d59be:	f8ad 601c 	strh.w	r6, [sp, #28]

  if (_cameraStream.readBytes((char*)buf, sizeof(buf)) == sizeof(buf))
   d59c2:	f000 fda7 	bl	d6514 <_ZN6Stream9readBytesEPcj>
   d59c6:	2806      	cmp	r0, #6
   d59c8:	d12e      	bne.n	d5a28 <_ZN12uCamIII_Base13expectPackageE11uCamIII_CMDh+0x8c>
  {
    _lastError = 0;
    Log.trace("received: %02X %02X %02X %02X %02X %02X", buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);
   d59ca:	f89d 101d 	ldrb.w	r1, [sp, #29]
   d59ce:	9103      	str	r1, [sp, #12]
   d59d0:	f89d 101c 	ldrb.w	r1, [sp, #28]
   d59d4:	9102      	str	r1, [sp, #8]
   d59d6:	f89d 101b 	ldrb.w	r1, [sp, #27]
   d59da:	9101      	str	r1, [sp, #4]
   d59dc:	f89d 101a 	ldrb.w	r1, [sp, #26]
   d59e0:	f89d 3019 	ldrb.w	r3, [sp, #25]
   d59e4:	f89d 2018 	ldrb.w	r2, [sp, #24]
   d59e8:	9100      	str	r1, [sp, #0]
  uint8_t buf[6];
  memset(buf, 0x00, sizeof(buf));

  if (_cameraStream.readBytes((char*)buf, sizeof(buf)) == sizeof(buf))
  {
    _lastError = 0;
   d59ea:	7526      	strb	r6, [r4, #20]
    Log.trace("received: %02X %02X %02X %02X %02X %02X", buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);
   d59ec:	491e      	ldr	r1, [pc, #120]	; (d5a68 <_ZN12uCamIII_Base13expectPackageE11uCamIII_CMDh+0xcc>)
   d59ee:	481b      	ldr	r0, [pc, #108]	; (d5a5c <_ZN12uCamIII_Base13expectPackageE11uCamIII_CMDh+0xc0>)
   d59f0:	f7fe fc04 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>
    if (buf[1] == pkg && (buf[2] == option || option == uCamIII_DONT_CARE)) 
   d59f4:	f89d 2019 	ldrb.w	r2, [sp, #25]
   d59f8:	f89d 301c 	ldrb.w	r3, [sp, #28]
   d59fc:	4297      	cmp	r7, r2
   d59fe:	d110      	bne.n	d5a22 <_ZN12uCamIII_Base13expectPackageE11uCamIII_CMDh+0x86>
   d5a00:	f89d 101a 	ldrb.w	r1, [sp, #26]
   d5a04:	42a9      	cmp	r1, r5
   d5a06:	d001      	beq.n	d5a0c <_ZN12uCamIII_Base13expectPackageE11uCamIII_CMDh+0x70>
   d5a08:	2dff      	cmp	r5, #255	; 0xff
   d5a0a:	d10a      	bne.n	d5a22 <_ZN12uCamIII_Base13expectPackageE11uCamIII_CMDh+0x86>
      return buf[3] | buf[4] << 8 | buf[5] << 16 | 0x1000000;
   d5a0c:	f89d 001b 	ldrb.w	r0, [sp, #27]
   d5a10:	f040 7080 	orr.w	r0, r0, #16777216	; 0x1000000
   d5a14:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
   d5a18:	f89d 301d 	ldrb.w	r3, [sp, #29]
   d5a1c:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
   d5a20:	e019      	b.n	d5a56 <_ZN12uCamIII_Base13expectPackageE11uCamIII_CMDh+0xba>
    else if (buf[1] == uCamIII_CMD_NAK)
   d5a22:	2a0f      	cmp	r2, #15
      _lastError = buf[4];
   d5a24:	bf08      	it	eq
   d5a26:	7523      	strbeq	r3, [r4, #20]
  }
  
  Log.warn("timeout: %02X %02X %02X %02X %02X %02X (%lu)", buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], _timeout);
   d5a28:	68a1      	ldr	r1, [r4, #8]
   d5a2a:	9104      	str	r1, [sp, #16]
   d5a2c:	f89d 101d 	ldrb.w	r1, [sp, #29]
   d5a30:	9103      	str	r1, [sp, #12]
   d5a32:	f89d 101c 	ldrb.w	r1, [sp, #28]
   d5a36:	9102      	str	r1, [sp, #8]
   d5a38:	f89d 101b 	ldrb.w	r1, [sp, #27]
   d5a3c:	9101      	str	r1, [sp, #4]
   d5a3e:	f89d 101a 	ldrb.w	r1, [sp, #26]
   d5a42:	9100      	str	r1, [sp, #0]
   d5a44:	4805      	ldr	r0, [pc, #20]	; (d5a5c <_ZN12uCamIII_Base13expectPackageE11uCamIII_CMDh+0xc0>)
   d5a46:	f89d 3019 	ldrb.w	r3, [sp, #25]
   d5a4a:	f89d 2018 	ldrb.w	r2, [sp, #24]
   d5a4e:	4907      	ldr	r1, [pc, #28]	; (d5a6c <_ZN12uCamIII_Base13expectPackageE11uCamIII_CMDh+0xd0>)
   d5a50:	f7ff fe7e 	bl	d5750 <_ZNK5spark6Logger4warnEPKcz>
  return 0;
   d5a54:	2000      	movs	r0, #0
}
   d5a56:	b009      	add	sp, #36	; 0x24
   d5a58:	bdf0      	pop	{r4, r5, r6, r7, pc}
   d5a5a:	bf00      	nop
   d5a5c:	2003e2b0 	.word	0x2003e2b0
   d5a60:	000da4d5 	.word	0x000da4d5
   d5a64:	000da495 	.word	0x000da495
   d5a68:	000da4e3 	.word	0x000da4e3
   d5a6c:	000da50b 	.word	0x000da50b

000d5a70 <_ZN12uCamIII_Base14sendCmdWithAckE11uCamIII_CMDhhhh>:
  Log.info("sendCmd: %02X %02X %02X %02X %02X %02X", buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);
  return _cameraStream.write(buf, 6);
}

long uCamIII_Base::sendCmdWithAck(uCamIII_CMD cmd, uint8_t p1, uint8_t p2, uint8_t p3, uint8_t p4) 
{
   d5a70:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   d5a74:	f89d 8028 	ldrb.w	r8, [sp, #40]	; 0x28
   d5a78:	f89d 902c 	ldrb.w	r9, [sp, #44]	; 0x2c
   d5a7c:	4604      	mov	r4, r0
   d5a7e:	460d      	mov	r5, r1
   d5a80:	4616      	mov	r6, r2
   d5a82:	461f      	mov	r7, r3
  Log.trace(__FUNCTION__); 
   d5a84:	4909      	ldr	r1, [pc, #36]	; (d5aac <_ZN12uCamIII_Base14sendCmdWithAckE11uCamIII_CMDhhhh+0x3c>)
   d5a86:	480a      	ldr	r0, [pc, #40]	; (d5ab0 <_ZN12uCamIII_Base14sendCmdWithAckE11uCamIII_CMDhhhh+0x40>)
   d5a88:	f7fe fbb8 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>

  sendCmd(cmd, p1, p2, p3, p4);
   d5a8c:	4632      	mov	r2, r6
   d5a8e:	4629      	mov	r1, r5
   d5a90:	e88d 0300 	stmia.w	sp, {r8, r9}
   d5a94:	463b      	mov	r3, r7
   d5a96:	4620      	mov	r0, r4
   d5a98:	f7ff fe8a 	bl	d57b0 <_ZN12uCamIII_Base7sendCmdE11uCamIII_CMDhhhh>
  return expectPackage(uCamIII_CMD_ACK, cmd);
   d5a9c:	462a      	mov	r2, r5
   d5a9e:	210e      	movs	r1, #14
   d5aa0:	4620      	mov	r0, r4
}
   d5aa2:	b003      	add	sp, #12
   d5aa4:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
long uCamIII_Base::sendCmdWithAck(uCamIII_CMD cmd, uint8_t p1, uint8_t p2, uint8_t p3, uint8_t p4) 
{
  Log.trace(__FUNCTION__); 

  sendCmd(cmd, p1, p2, p3, p4);
  return expectPackage(uCamIII_CMD_ACK, cmd);
   d5aa8:	f7ff bf78 	b.w	d599c <_ZN12uCamIII_Base13expectPackageE11uCamIII_CMDh>
   d5aac:	000da56a 	.word	0x000da56a
   d5ab0:	2003e2b0 	.word	0x2003e2b0

000d5ab4 <_ZN12uCamIII_Base4syncEi>:
  hardReset();
  return sync();
}

long uCamIII_Base::sync(int maxTry)
{
   d5ab4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   d5ab8:	4605      	mov	r5, r0
   d5aba:	460e      	mov	r6, r1
  Log.trace(__FUNCTION__); 
   d5abc:	481b      	ldr	r0, [pc, #108]	; (d5b2c <_ZN12uCamIII_Base4syncEi+0x78>)
   d5abe:	491c      	ldr	r1, [pc, #112]	; (d5b30 <_ZN12uCamIII_Base4syncEi+0x7c>)
   d5ac0:	f7fe fb9c 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>

  int      tries;
  int      count;
  uint32_t ms = _timeout;
   d5ac4:	f8d5 8008 	ldr.w	r8, [r5, #8]
  
  for (tries = 1; tries < maxTry; tries++)
   d5ac8:	2401      	movs	r4, #1
  {
    _timeout = 5 + tries;                                       // start with 5ms timeout between syncs and increase by 1ms
    if ((count = sendCmdWithAck(uCamIII_CMD_SYNC))) break;
   d5aca:	2700      	movs	r7, #0

  int      tries;
  int      count;
  uint32_t ms = _timeout;
  
  for (tries = 1; tries < maxTry; tries++)
   d5acc:	42b4      	cmp	r4, r6
   d5ace:	da0c      	bge.n	d5aea <_ZN12uCamIII_Base4syncEi+0x36>
  {
    _timeout = 5 + tries;                                       // start with 5ms timeout between syncs and increase by 1ms
   d5ad0:	1d63      	adds	r3, r4, #5
   d5ad2:	60ab      	str	r3, [r5, #8]
    if ((count = sendCmdWithAck(uCamIII_CMD_SYNC))) break;
   d5ad4:	2300      	movs	r3, #0
   d5ad6:	9701      	str	r7, [sp, #4]
   d5ad8:	9700      	str	r7, [sp, #0]
   d5ada:	461a      	mov	r2, r3
   d5adc:	210d      	movs	r1, #13
   d5ade:	4628      	mov	r0, r5
   d5ae0:	f7ff ffc6 	bl	d5a70 <_ZN12uCamIII_Base14sendCmdWithAckE11uCamIII_CMDhhhh>
   d5ae4:	b908      	cbnz	r0, d5aea <_ZN12uCamIII_Base4syncEi+0x36>

  int      tries;
  int      count;
  uint32_t ms = _timeout;
  
  for (tries = 1; tries < maxTry; tries++)
   d5ae6:	3401      	adds	r4, #1
   d5ae8:	e7f0      	b.n	d5acc <_ZN12uCamIII_Base4syncEi+0x18>
  {
    _timeout = 5 + tries;                                       // start with 5ms timeout between syncs and increase by 1ms
    if ((count = sendCmdWithAck(uCamIII_CMD_SYNC))) break;
  }
  _timeout = ms;
  if (tries < maxTry)
   d5aea:	42b4      	cmp	r4, r6
  for (tries = 1; tries < maxTry; tries++)
  {
    _timeout = 5 + tries;                                       // start with 5ms timeout between syncs and increase by 1ms
    if ((count = sendCmdWithAck(uCamIII_CMD_SYNC))) break;
  }
  _timeout = ms;
   d5aec:	f8c5 8008 	str.w	r8, [r5, #8]
  if (tries < maxTry)
   d5af0:	da14      	bge.n	d5b1c <_ZN12uCamIII_Base4syncEi+0x68>
  {
    Log.info("sync after %d tries", tries);    
   d5af2:	4622      	mov	r2, r4
   d5af4:	490f      	ldr	r1, [pc, #60]	; (d5b34 <_ZN12uCamIII_Base4syncEi+0x80>)
   d5af6:	480d      	ldr	r0, [pc, #52]	; (d5b2c <_ZN12uCamIII_Base4syncEi+0x78>)
   d5af8:	f7fe fb97 	bl	d422a <_ZNK5spark6Logger4infoEPKcz>
    if (expectPackage(uCamIII_CMD_SYNC)) {
   d5afc:	22ff      	movs	r2, #255	; 0xff
   d5afe:	210d      	movs	r1, #13
   d5b00:	4628      	mov	r0, r5
   d5b02:	f7ff ff4b 	bl	d599c <_ZN12uCamIII_Base13expectPackageE11uCamIII_CMDh>
   d5b06:	b148      	cbz	r0, d5b1c <_ZN12uCamIII_Base4syncEi+0x68>
      sendCmd(uCamIII_CMD_ACK, uCamIII_CMD_SYNC);
   d5b08:	2300      	movs	r3, #0
   d5b0a:	9301      	str	r3, [sp, #4]
   d5b0c:	9300      	str	r3, [sp, #0]
   d5b0e:	220d      	movs	r2, #13
   d5b10:	210e      	movs	r1, #14
   d5b12:	4628      	mov	r0, r5
   d5b14:	f7ff fe4c 	bl	d57b0 <_ZN12uCamIII_Base7sendCmdE11uCamIII_CMDhhhh>
      return tries;
   d5b18:	4620      	mov	r0, r4
   d5b1a:	e004      	b.n	d5b26 <_ZN12uCamIII_Base4syncEi+0x72>
    }
  }
  
  Log.warn("no sync");
   d5b1c:	4803      	ldr	r0, [pc, #12]	; (d5b2c <_ZN12uCamIII_Base4syncEi+0x78>)
   d5b1e:	4906      	ldr	r1, [pc, #24]	; (d5b38 <_ZN12uCamIII_Base4syncEi+0x84>)
   d5b20:	f7ff fe16 	bl	d5750 <_ZNK5spark6Logger4warnEPKcz>
  return 0;
   d5b24:	2000      	movs	r0, #0
}
   d5b26:	b002      	add	sp, #8
   d5b28:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   d5b2c:	2003e2b0 	.word	0x2003e2b0
   d5b30:	000da490 	.word	0x000da490
   d5b34:	000da538 	.word	0x000da538
   d5b38:	000da54c 	.word	0x000da54c

000d5b3c <_ZN12uCamIII_Base4initEv>:
************************************************************************************* */

#include <uCamIII.h>

long uCamIII_Base::init() 
{
   d5b3c:	b510      	push	{r4, lr}
  Log.trace("uCAMIII_Base: %s", __FUNCTION__); 
   d5b3e:	4907      	ldr	r1, [pc, #28]	; (d5b5c <_ZN12uCamIII_Base4initEv+0x20>)
   d5b40:	4a07      	ldr	r2, [pc, #28]	; (d5b60 <_ZN12uCamIII_Base4initEv+0x24>)
************************************************************************************* */

#include <uCamIII.h>

long uCamIII_Base::init() 
{
   d5b42:	4604      	mov	r4, r0
  Log.trace("uCAMIII_Base: %s", __FUNCTION__); 
   d5b44:	4807      	ldr	r0, [pc, #28]	; (d5b64 <_ZN12uCamIII_Base4initEv+0x28>)
   d5b46:	f7fe fb59 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>
  hardReset();
   d5b4a:	4620      	mov	r0, r4
   d5b4c:	f7ff fe0e 	bl	d576c <_ZN12uCamIII_Base9hardResetEv>
  return sync();
   d5b50:	4620      	mov	r0, r4
   d5b52:	213c      	movs	r1, #60	; 0x3c
}
   d5b54:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

long uCamIII_Base::init() 
{
  Log.trace("uCAMIII_Base: %s", __FUNCTION__); 
  hardReset();
  return sync();
   d5b58:	f7ff bfac 	b.w	d5ab4 <_ZN12uCamIII_Base4syncEi>
   d5b5c:	000da554 	.word	0x000da554
   d5b60:	000da565 	.word	0x000da565
   d5b64:	2003e2b0 	.word	0x2003e2b0

000d5b68 <_ZN12uCamIII_Base10getPictureE16uCamIII_PIC_TYPE>:
  Log.warn("no sync");
  return 0;
}

long uCamIII_Base::getPicture(uCamIII_PIC_TYPE type)
{
   d5b68:	b573      	push	{r0, r1, r4, r5, r6, lr}
  Log.trace(__FUNCTION__); 

  if (sendCmdWithAck(uCamIII_CMD_GET_PICTURE, type))
   d5b6a:	2500      	movs	r5, #0
  Log.warn("no sync");
  return 0;
}

long uCamIII_Base::getPicture(uCamIII_PIC_TYPE type)
{
   d5b6c:	4604      	mov	r4, r0
   d5b6e:	460e      	mov	r6, r1
  Log.trace(__FUNCTION__); 
   d5b70:	480b      	ldr	r0, [pc, #44]	; (d5ba0 <_ZN12uCamIII_Base10getPictureE16uCamIII_PIC_TYPE+0x38>)
   d5b72:	490c      	ldr	r1, [pc, #48]	; (d5ba4 <_ZN12uCamIII_Base10getPictureE16uCamIII_PIC_TYPE+0x3c>)
   d5b74:	f7fe fb42 	bl	d41fc <_ZNK5spark6Logger5traceEPKcz>

  if (sendCmdWithAck(uCamIII_CMD_GET_PICTURE, type))
   d5b78:	9501      	str	r5, [sp, #4]
   d5b7a:	9500      	str	r5, [sp, #0]
   d5b7c:	462b      	mov	r3, r5
   d5b7e:	4632      	mov	r2, r6
   d5b80:	2104      	movs	r1, #4
   d5b82:	4620      	mov	r0, r4
   d5b84:	f7ff ff74 	bl	d5a70 <_ZN12uCamIII_Base14sendCmdWithAckE11uCamIII_CMDhhhh>
   d5b88:	b140      	cbz	r0, d5b9c <_ZN12uCamIII_Base10getPictureE16uCamIII_PIC_TYPE+0x34>
  {
    _packageNumber = 0;    
   d5b8a:	8265      	strh	r5, [r4, #18]
    return (_imageSize = expectPackage(uCamIII_CMD_DATA, type) & 0x00FFFFFF);   // return image size
   d5b8c:	4632      	mov	r2, r6
   d5b8e:	210a      	movs	r1, #10
   d5b90:	4620      	mov	r0, r4
   d5b92:	f7ff ff03 	bl	d599c <_ZN12uCamIII_Base13expectPackageE11uCamIII_CMDh>
   d5b96:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   d5b9a:	60e0      	str	r0, [r4, #12]
  }
  return 0;
}
   d5b9c:	b002      	add	sp, #8
   d5b9e:	bd70      	pop	{r4, r5, r6, pc}
   d5ba0:	2003e2b0 	.word	0x2003e2b0
   d5ba4:	000da4a3 	.word	0x000da4a3

000d5ba8 <_GLOBAL__sub_I__ZN12uCamIII_Base4initEv>:
   d5ba8:	f000 b810 	b.w	d5bcc <HAL_Pin_Map>

000d5bac <netdb_freeaddrinfo>:

DYNALIB_BEGIN(hal_netdb)

DYNALIB_FN(0, hal_netdb, netdb_gethostbyname, struct hostent*(const char*))
DYNALIB_FN(1, hal_netdb, netdb_gethostbyname_r, int(const char*, struct hostent*, char*, size_t, struct hostent**, int*))
DYNALIB_FN(2, hal_netdb, netdb_freeaddrinfo, void(struct addrinfo*))
   d5bac:	b508      	push	{r3, lr}
   d5bae:	4b02      	ldr	r3, [pc, #8]	; (d5bb8 <netdb_freeaddrinfo+0xc>)
   d5bb0:	681b      	ldr	r3, [r3, #0]
   d5bb2:	689b      	ldr	r3, [r3, #8]
   d5bb4:	9301      	str	r3, [sp, #4]
   d5bb6:	bd08      	pop	{r3, pc}
   d5bb8:	00030268 	.word	0x00030268

000d5bbc <netdb_getaddrinfo>:
DYNALIB_FN(3, hal_netdb, netdb_getaddrinfo, int(const char*, const char*, const struct addrinfo*, struct addrinfo**))
   d5bbc:	b508      	push	{r3, lr}
   d5bbe:	4b02      	ldr	r3, [pc, #8]	; (d5bc8 <netdb_getaddrinfo+0xc>)
   d5bc0:	681b      	ldr	r3, [r3, #0]
   d5bc2:	68db      	ldr	r3, [r3, #12]
   d5bc4:	9301      	str	r3, [sp, #4]
   d5bc6:	bd08      	pop	{r3, pc}
   d5bc8:	00030268 	.word	0x00030268

000d5bcc <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, Hal_Pin_Info*(void))
   d5bcc:	b508      	push	{r3, lr}
   d5bce:	4b02      	ldr	r3, [pc, #8]	; (d5bd8 <HAL_Pin_Map+0xc>)
   d5bd0:	681b      	ldr	r3, [r3, #0]
   d5bd2:	681b      	ldr	r3, [r3, #0]
   d5bd4:	9301      	str	r3, [sp, #4]
   d5bd6:	bd08      	pop	{r3, pc}
   d5bd8:	0003022c 	.word	0x0003022c

000d5bdc <HAL_Pin_Mode>:
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
   d5bdc:	b508      	push	{r3, lr}
   d5bde:	4b02      	ldr	r3, [pc, #8]	; (d5be8 <HAL_Pin_Mode+0xc>)
   d5be0:	681b      	ldr	r3, [r3, #0]
   d5be2:	689b      	ldr	r3, [r3, #8]
   d5be4:	9301      	str	r3, [sp, #4]
   d5be6:	bd08      	pop	{r3, pc}
   d5be8:	0003022c 	.word	0x0003022c

000d5bec <HAL_Get_Pin_Mode>:
DYNALIB_FN(3, hal_gpio, HAL_Get_Pin_Mode, PinMode(pin_t))
   d5bec:	b508      	push	{r3, lr}
   d5bee:	4b02      	ldr	r3, [pc, #8]	; (d5bf8 <HAL_Get_Pin_Mode+0xc>)
   d5bf0:	681b      	ldr	r3, [r3, #0]
   d5bf2:	68db      	ldr	r3, [r3, #12]
   d5bf4:	9301      	str	r3, [sp, #4]
   d5bf6:	bd08      	pop	{r3, pc}
   d5bf8:	0003022c 	.word	0x0003022c

000d5bfc <HAL_GPIO_Write>:
DYNALIB_FN(4, hal_gpio, HAL_GPIO_Write, void(pin_t, uint8_t))
   d5bfc:	b508      	push	{r3, lr}
   d5bfe:	4b02      	ldr	r3, [pc, #8]	; (d5c08 <HAL_GPIO_Write+0xc>)
   d5c00:	681b      	ldr	r3, [r3, #0]
   d5c02:	691b      	ldr	r3, [r3, #16]
   d5c04:	9301      	str	r3, [sp, #4]
   d5c06:	bd08      	pop	{r3, pc}
   d5c08:	0003022c 	.word	0x0003022c

000d5c0c <HAL_SPI_Init>:
DYNALIB_FN(2, hal_spi, HAL_SPI_Set_Bit_Order, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(3, hal_spi, HAL_SPI_Set_Data_Mode, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(4, hal_spi, HAL_SPI_Set_Clock_Divider, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(5, hal_spi, HAL_SPI_Send_Receive_Data, uint16_t(HAL_SPI_Interface, uint16_t))
DYNALIB_FN(6, hal_spi, HAL_SPI_Is_Enabled_Old, bool(void))
DYNALIB_FN(7, hal_spi, HAL_SPI_Init, void(HAL_SPI_Interface))
   d5c0c:	b508      	push	{r3, lr}
   d5c0e:	4b02      	ldr	r3, [pc, #8]	; (d5c18 <HAL_SPI_Init+0xc>)
   d5c10:	681b      	ldr	r3, [r3, #0]
   d5c12:	69db      	ldr	r3, [r3, #28]
   d5c14:	9301      	str	r3, [sp, #4]
   d5c16:	bd08      	pop	{r3, pc}
   d5c18:	00030230 	.word	0x00030230

000d5c1c <HAL_SPI_Is_Enabled>:
DYNALIB_FN(8, hal_spi, HAL_SPI_Is_Enabled, bool(HAL_SPI_Interface))
   d5c1c:	b508      	push	{r3, lr}
   d5c1e:	4b02      	ldr	r3, [pc, #8]	; (d5c28 <HAL_SPI_Is_Enabled+0xc>)
   d5c20:	681b      	ldr	r3, [r3, #0]
   d5c22:	6a1b      	ldr	r3, [r3, #32]
   d5c24:	9301      	str	r3, [sp, #4]
   d5c26:	bd08      	pop	{r3, pc}
   d5c28:	00030230 	.word	0x00030230

000d5c2c <if_index_to_name>:
DYNALIB_FN(0, hal_ifapi, if_get_list, int(struct if_list**))
DYNALIB_FN(1, hal_ifapi, if_free_list, int(struct if_list*))
DYNALIB_FN(2, hal_ifapi, if_get_name_index, int(struct if_nameindex**))
DYNALIB_FN(3, hal_ifapi, if_free_name_index, int(struct if_nameindex*))
DYNALIB_FN(4, hal_ifapi, if_name_to_index, int(const char*, uint8_t*))
DYNALIB_FN(5, hal_ifapi, if_index_to_name, int(uint8_t, char*))
   d5c2c:	b508      	push	{r3, lr}
   d5c2e:	4b02      	ldr	r3, [pc, #8]	; (d5c38 <if_index_to_name+0xc>)
   d5c30:	681b      	ldr	r3, [r3, #0]
   d5c32:	695b      	ldr	r3, [r3, #20]
   d5c34:	9301      	str	r3, [sp, #4]
   d5c36:	bd08      	pop	{r3, pc}
   d5c38:	0003026c 	.word	0x0003026c

000d5c3c <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
   d5c3c:	b508      	push	{r3, lr}
   d5c3e:	4b02      	ldr	r3, [pc, #8]	; (d5c48 <HAL_RNG_GetRandomNumber+0xc>)
   d5c40:	681b      	ldr	r3, [r3, #0]
   d5c42:	685b      	ldr	r3, [r3, #4]
   d5c44:	9301      	str	r3, [sp, #4]
   d5c46:	bd08      	pop	{r3, pc}
   d5c48:	00030218 	.word	0x00030218

000d5c4c <HAL_Delay_Microseconds>:
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
   d5c4c:	b508      	push	{r3, lr}
   d5c4e:	4b02      	ldr	r3, [pc, #8]	; (d5c58 <HAL_Delay_Microseconds+0xc>)
   d5c50:	681b      	ldr	r3, [r3, #0]
   d5c52:	68db      	ldr	r3, [r3, #12]
   d5c54:	9301      	str	r3, [sp, #4]
   d5c56:	bd08      	pop	{r3, pc}
   d5c58:	00030218 	.word	0x00030218

000d5c5c <HAL_Timer_Get_Milli_Seconds>:
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
   d5c5c:	b508      	push	{r3, lr}
   d5c5e:	4b02      	ldr	r3, [pc, #8]	; (d5c68 <HAL_Timer_Get_Milli_Seconds+0xc>)
   d5c60:	681b      	ldr	r3, [r3, #0]
   d5c62:	695b      	ldr	r3, [r3, #20]
   d5c64:	9301      	str	r3, [sp, #4]
   d5c66:	bd08      	pop	{r3, pc}
   d5c68:	00030218 	.word	0x00030218

000d5c6c <HAL_RTC_Get_UnixTime>:

DYNALIB_FN(BASE_IDX + 4, hal, HAL_RTC_Configuration, void(void))
DYNALIB_FN(BASE_IDX + 5, hal, HAL_RTC_Get_UnixTime, time_t(void))
   d5c6c:	b508      	push	{r3, lr}
   d5c6e:	4b02      	ldr	r3, [pc, #8]	; (d5c78 <HAL_RTC_Get_UnixTime+0xc>)
   d5c70:	681b      	ldr	r3, [r3, #0]
   d5c72:	69db      	ldr	r3, [r3, #28]
   d5c74:	9301      	str	r3, [sp, #4]
   d5c76:	bd08      	pop	{r3, pc}
   d5c78:	00030218 	.word	0x00030218

000d5c7c <HAL_RTC_Time_Is_Valid>:
DYNALIB_FN(BASE_IDX + 15, hal,HAL_EEPROM_Get, void(uint32_t, void *, size_t))
DYNALIB_FN(BASE_IDX + 16, hal,HAL_EEPROM_Put, void(uint32_t, const void *, size_t))
DYNALIB_FN(BASE_IDX + 17, hal,HAL_EEPROM_Clear, void(void))
DYNALIB_FN(BASE_IDX + 18, hal,HAL_EEPROM_Has_Pending_Erase, bool(void))
DYNALIB_FN(BASE_IDX + 19, hal,HAL_EEPROM_Perform_Pending_Erase, void(void))
DYNALIB_FN(BASE_IDX + 20, hal, HAL_RTC_Time_Is_Valid, uint8_t(void*))
   d5c7c:	b508      	push	{r3, lr}
   d5c7e:	4b02      	ldr	r3, [pc, #8]	; (d5c88 <HAL_RTC_Time_Is_Valid+0xc>)
   d5c80:	681b      	ldr	r3, [r3, #0]
   d5c82:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   d5c84:	9301      	str	r3, [sp, #4]
   d5c86:	bd08      	pop	{r3, pc}
   d5c88:	00030218 	.word	0x00030218

000d5c8c <os_thread_is_current>:
DYNALIB_BEGIN(hal_concurrent)

#if PLATFORM_THREADING
DYNALIB_FN(0, hal_concurrent, __gthread_equal, bool(__gthread_t, __gthread_t))
DYNALIB_FN(1, hal_concurrent, os_thread_create, os_result_t(os_thread_t*, const char*, os_thread_prio_t, os_thread_fn_t, void*, size_t))
DYNALIB_FN(2, hal_concurrent, os_thread_is_current, bool(os_thread_t))
   d5c8c:	b508      	push	{r3, lr}
   d5c8e:	4b02      	ldr	r3, [pc, #8]	; (d5c98 <os_thread_is_current+0xc>)
   d5c90:	681b      	ldr	r3, [r3, #0]
   d5c92:	689b      	ldr	r3, [r3, #8]
   d5c94:	9301      	str	r3, [sp, #4]
   d5c96:	bd08      	pop	{r3, pc}
   d5c98:	00030248 	.word	0x00030248

000d5c9c <os_thread_join>:
DYNALIB_FN(3, hal_concurrent, os_thread_yield, os_result_t(void))
DYNALIB_FN(4, hal_concurrent, os_thread_join, os_result_t(os_thread_t))
   d5c9c:	b508      	push	{r3, lr}
   d5c9e:	4b02      	ldr	r3, [pc, #8]	; (d5ca8 <os_thread_join+0xc>)
   d5ca0:	681b      	ldr	r3, [r3, #0]
   d5ca2:	691b      	ldr	r3, [r3, #16]
   d5ca4:	9301      	str	r3, [sp, #4]
   d5ca6:	bd08      	pop	{r3, pc}
   d5ca8:	00030248 	.word	0x00030248

000d5cac <os_thread_cleanup>:
DYNALIB_FN(5, hal_concurrent, os_thread_cleanup, os_result_t(os_thread_t))
   d5cac:	b508      	push	{r3, lr}
   d5cae:	4b02      	ldr	r3, [pc, #8]	; (d5cb8 <os_thread_cleanup+0xc>)
   d5cb0:	681b      	ldr	r3, [r3, #0]
   d5cb2:	695b      	ldr	r3, [r3, #20]
   d5cb4:	9301      	str	r3, [sp, #4]
   d5cb6:	bd08      	pop	{r3, pc}
   d5cb8:	00030248 	.word	0x00030248

000d5cbc <os_thread_scheduling>:
DYNALIB_FN(6, hal_concurrent, os_thread_delay_until, os_result_t(system_tick_t*, system_tick_t))
DYNALIB_FN(7, hal_concurrent, os_thread_scheduling, void(bool, void*))
   d5cbc:	b508      	push	{r3, lr}
   d5cbe:	4b02      	ldr	r3, [pc, #8]	; (d5cc8 <os_thread_scheduling+0xc>)
   d5cc0:	681b      	ldr	r3, [r3, #0]
   d5cc2:	69db      	ldr	r3, [r3, #28]
   d5cc4:	9301      	str	r3, [sp, #4]
   d5cc6:	bd08      	pop	{r3, pc}
   d5cc8:	00030248 	.word	0x00030248

000d5ccc <os_mutex_recursive_create>:
DYNALIB_FN(13, hal_concurrent, os_mutex_destroy, int(os_mutex_t))
DYNALIB_FN(14, hal_concurrent, os_mutex_lock, int(os_mutex_t))
DYNALIB_FN(15, hal_concurrent, os_mutex_trylock, int(os_mutex_t))
DYNALIB_FN(16, hal_concurrent, os_mutex_unlock, int(os_mutex_t))

DYNALIB_FN(17, hal_concurrent, os_mutex_recursive_create, int(os_mutex_recursive_t*))
   d5ccc:	b508      	push	{r3, lr}
   d5cce:	4b02      	ldr	r3, [pc, #8]	; (d5cd8 <os_mutex_recursive_create+0xc>)
   d5cd0:	681b      	ldr	r3, [r3, #0]
   d5cd2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   d5cd4:	9301      	str	r3, [sp, #4]
   d5cd6:	bd08      	pop	{r3, pc}
   d5cd8:	00030248 	.word	0x00030248

000d5cdc <os_mutex_recursive_destroy>:
DYNALIB_FN(18, hal_concurrent, os_mutex_recursive_destroy, int(os_mutex_recursive_t))
   d5cdc:	b508      	push	{r3, lr}
   d5cde:	4b02      	ldr	r3, [pc, #8]	; (d5ce8 <os_mutex_recursive_destroy+0xc>)
   d5ce0:	681b      	ldr	r3, [r3, #0]
   d5ce2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   d5ce4:	9301      	str	r3, [sp, #4]
   d5ce6:	bd08      	pop	{r3, pc}
   d5ce8:	00030248 	.word	0x00030248

000d5cec <inet_inet_ntop>:
DYNALIB_FN(0, hal_inet, inet_inet_addr, in_addr_t(const char*))
DYNALIB_FN(1, hal_inet, inet_inet_aton, int(const char*, struct in_addr*))
DYNALIB_FN(2, hal_inet, inet_inet_network, in_addr_t(const char*))
DYNALIB_FN(3, hal_inet, inet_inet_ntoa, char*(struct in_addr))
DYNALIB_FN(4, hal_inet, inet_inet_ntoa_r, char*(struct in_addr, char*, socklen_t))
DYNALIB_FN(5, hal_inet, inet_inet_ntop, const char*(int, const void*, char*, socklen_t))
   d5cec:	b508      	push	{r3, lr}
   d5cee:	4b02      	ldr	r3, [pc, #8]	; (d5cf8 <inet_inet_ntop+0xc>)
   d5cf0:	681b      	ldr	r3, [r3, #0]
   d5cf2:	695b      	ldr	r3, [r3, #20]
   d5cf4:	9301      	str	r3, [sp, #4]
   d5cf6:	bd08      	pop	{r3, pc}
   d5cf8:	00030264 	.word	0x00030264

000d5cfc <inet_htonl>:
DYNALIB_FN(6, hal_inet, inet_inet_pton, int(int, const char*, void*))
DYNALIB_FN(7, hal_inet, inet_ntohl, uint32_t(uint32_t))
DYNALIB_FN(8, hal_inet, inet_htonl, uint32_t(uint32_t))
   d5cfc:	b508      	push	{r3, lr}
   d5cfe:	4b02      	ldr	r3, [pc, #8]	; (d5d08 <inet_htonl+0xc>)
   d5d00:	681b      	ldr	r3, [r3, #0]
   d5d02:	6a1b      	ldr	r3, [r3, #32]
   d5d04:	9301      	str	r3, [sp, #4]
   d5d06:	bd08      	pop	{r3, pc}
   d5d08:	00030264 	.word	0x00030264

000d5d0c <inet_htons>:
DYNALIB_FN(9, hal_inet, inet_ntohs, uint16_t(uint16_t))
DYNALIB_FN(10, hal_inet, inet_htons, uint16_t(uint16_t))
   d5d0c:	b508      	push	{r3, lr}
   d5d0e:	4b02      	ldr	r3, [pc, #8]	; (d5d18 <inet_htons+0xc>)
   d5d10:	681b      	ldr	r3, [r3, #0]
   d5d12:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   d5d14:	9301      	str	r3, [sp, #4]
   d5d16:	bd08      	pop	{r3, pc}
   d5d18:	00030264 	.word	0x00030264

000d5d1c <HAL_USART_Init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, HAL_USART_Init, void(HAL_USART_Serial, Ring_Buffer*, Ring_Buffer*))
   d5d1c:	b508      	push	{r3, lr}
   d5d1e:	4b02      	ldr	r3, [pc, #8]	; (d5d28 <HAL_USART_Init+0xc>)
   d5d20:	681b      	ldr	r3, [r3, #0]
   d5d22:	681b      	ldr	r3, [r3, #0]
   d5d24:	9301      	str	r3, [sp, #4]
   d5d26:	bd08      	pop	{r3, pc}
   d5d28:	0003023c 	.word	0x0003023c

000d5d2c <HAL_USART_End>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, HAL_USART_Begin, void(HAL_USART_Serial, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, HAL_USART_End, void(HAL_USART_Serial))
   d5d2c:	b508      	push	{r3, lr}
   d5d2e:	4b02      	ldr	r3, [pc, #8]	; (d5d38 <HAL_USART_End+0xc>)
   d5d30:	681b      	ldr	r3, [r3, #0]
   d5d32:	689b      	ldr	r3, [r3, #8]
   d5d34:	9301      	str	r3, [sp, #4]
   d5d36:	bd08      	pop	{r3, pc}
   d5d38:	0003023c 	.word	0x0003023c

000d5d3c <HAL_USART_Write_Data>:
DYNALIB_FN(BASE_IDX + 3, hal_usart, HAL_USART_Write_Data, uint32_t(HAL_USART_Serial, uint8_t))
   d5d3c:	b508      	push	{r3, lr}
   d5d3e:	4b02      	ldr	r3, [pc, #8]	; (d5d48 <HAL_USART_Write_Data+0xc>)
   d5d40:	681b      	ldr	r3, [r3, #0]
   d5d42:	68db      	ldr	r3, [r3, #12]
   d5d44:	9301      	str	r3, [sp, #4]
   d5d46:	bd08      	pop	{r3, pc}
   d5d48:	0003023c 	.word	0x0003023c

000d5d4c <HAL_USART_Available_Data>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, HAL_USART_Available_Data, int32_t(HAL_USART_Serial))
   d5d4c:	b508      	push	{r3, lr}
   d5d4e:	4b02      	ldr	r3, [pc, #8]	; (d5d58 <HAL_USART_Available_Data+0xc>)
   d5d50:	681b      	ldr	r3, [r3, #0]
   d5d52:	691b      	ldr	r3, [r3, #16]
   d5d54:	9301      	str	r3, [sp, #4]
   d5d56:	bd08      	pop	{r3, pc}
   d5d58:	0003023c 	.word	0x0003023c

000d5d5c <HAL_USART_Read_Data>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, HAL_USART_Read_Data, int32_t(HAL_USART_Serial))
   d5d5c:	b508      	push	{r3, lr}
   d5d5e:	4b02      	ldr	r3, [pc, #8]	; (d5d68 <HAL_USART_Read_Data+0xc>)
   d5d60:	681b      	ldr	r3, [r3, #0]
   d5d62:	695b      	ldr	r3, [r3, #20]
   d5d64:	9301      	str	r3, [sp, #4]
   d5d66:	bd08      	pop	{r3, pc}
   d5d68:	0003023c 	.word	0x0003023c

000d5d6c <HAL_USART_Peek_Data>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, HAL_USART_Peek_Data, int32_t(HAL_USART_Serial))
   d5d6c:	b508      	push	{r3, lr}
   d5d6e:	4b02      	ldr	r3, [pc, #8]	; (d5d78 <HAL_USART_Peek_Data+0xc>)
   d5d70:	681b      	ldr	r3, [r3, #0]
   d5d72:	699b      	ldr	r3, [r3, #24]
   d5d74:	9301      	str	r3, [sp, #4]
   d5d76:	bd08      	pop	{r3, pc}
   d5d78:	0003023c 	.word	0x0003023c

000d5d7c <HAL_USART_Flush_Data>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, HAL_USART_Flush_Data, void(HAL_USART_Serial))
   d5d7c:	b508      	push	{r3, lr}
   d5d7e:	4b02      	ldr	r3, [pc, #8]	; (d5d88 <HAL_USART_Flush_Data+0xc>)
   d5d80:	681b      	ldr	r3, [r3, #0]
   d5d82:	69db      	ldr	r3, [r3, #28]
   d5d84:	9301      	str	r3, [sp, #4]
   d5d86:	bd08      	pop	{r3, pc}
   d5d88:	0003023c 	.word	0x0003023c

000d5d8c <HAL_USART_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, HAL_USART_Is_Enabled, bool(HAL_USART_Serial))
   d5d8c:	b508      	push	{r3, lr}
   d5d8e:	4b02      	ldr	r3, [pc, #8]	; (d5d98 <HAL_USART_Is_Enabled+0xc>)
   d5d90:	681b      	ldr	r3, [r3, #0]
   d5d92:	6a1b      	ldr	r3, [r3, #32]
   d5d94:	9301      	str	r3, [sp, #4]
   d5d96:	bd08      	pop	{r3, pc}
   d5d98:	0003023c 	.word	0x0003023c

000d5d9c <HAL_USART_Available_Data_For_Write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, HAL_USART_Half_Duplex, void(HAL_USART_Serial, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, HAL_USART_Available_Data_For_Write, int32_t(HAL_USART_Serial))
   d5d9c:	b508      	push	{r3, lr}
   d5d9e:	4b02      	ldr	r3, [pc, #8]	; (d5da8 <HAL_USART_Available_Data_For_Write+0xc>)
   d5da0:	681b      	ldr	r3, [r3, #0]
   d5da2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   d5da4:	9301      	str	r3, [sp, #4]
   d5da6:	bd08      	pop	{r3, pc}
   d5da8:	0003023c 	.word	0x0003023c

000d5dac <HAL_USART_BeginConfig>:
#define BASE_IDX2 (BASE_IDX+13)
#else
#define BASE_IDX2 (BASE_IDX+11)
#endif

DYNALIB_FN(BASE_IDX2 + 0, hal_usart, HAL_USART_BeginConfig, void(HAL_USART_Serial serial, uint32_t baud, uint32_t config, void *ptr))
   d5dac:	b508      	push	{r3, lr}
   d5dae:	4b02      	ldr	r3, [pc, #8]	; (d5db8 <HAL_USART_BeginConfig+0xc>)
   d5db0:	681b      	ldr	r3, [r3, #0]
   d5db2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   d5db4:	9301      	str	r3, [sp, #4]
   d5db6:	bd08      	pop	{r3, pc}
   d5db8:	0003023c 	.word	0x0003023c

000d5dbc <HAL_I2C_Write_Data>:
DYNALIB_FN(BASE_IDX + 3, hal_i2c, HAL_I2C_Begin, void(HAL_I2C_Interface, I2C_Mode, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 4, hal_i2c, HAL_I2C_End, void(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, HAL_I2C_Request_Data, uint32_t(HAL_I2C_Interface, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 6, hal_i2c, HAL_I2C_Begin_Transmission, void(HAL_I2C_Interface, uint8_t, const HAL_I2C_Transmission_Config*))
DYNALIB_FN(BASE_IDX + 7, hal_i2c, HAL_I2C_End_Transmission, uint8_t(HAL_I2C_Interface, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 8, hal_i2c, HAL_I2C_Write_Data, uint32_t(HAL_I2C_Interface, uint8_t, void*))
   d5dbc:	b508      	push	{r3, lr}
   d5dbe:	4b02      	ldr	r3, [pc, #8]	; (d5dc8 <HAL_I2C_Write_Data+0xc>)
   d5dc0:	681b      	ldr	r3, [r3, #0]
   d5dc2:	6a1b      	ldr	r3, [r3, #32]
   d5dc4:	9301      	str	r3, [sp, #4]
   d5dc6:	bd08      	pop	{r3, pc}
   d5dc8:	00030228 	.word	0x00030228

000d5dcc <HAL_I2C_Available_Data>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, HAL_I2C_Available_Data, int32_t(HAL_I2C_Interface, void*))
   d5dcc:	b508      	push	{r3, lr}
   d5dce:	4b02      	ldr	r3, [pc, #8]	; (d5dd8 <HAL_I2C_Available_Data+0xc>)
   d5dd0:	681b      	ldr	r3, [r3, #0]
   d5dd2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   d5dd4:	9301      	str	r3, [sp, #4]
   d5dd6:	bd08      	pop	{r3, pc}
   d5dd8:	00030228 	.word	0x00030228

000d5ddc <HAL_I2C_Read_Data>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, HAL_I2C_Read_Data, int32_t(HAL_I2C_Interface, void*))
   d5ddc:	b508      	push	{r3, lr}
   d5dde:	4b02      	ldr	r3, [pc, #8]	; (d5de8 <HAL_I2C_Read_Data+0xc>)
   d5de0:	681b      	ldr	r3, [r3, #0]
   d5de2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   d5de4:	9301      	str	r3, [sp, #4]
   d5de6:	bd08      	pop	{r3, pc}
   d5de8:	00030228 	.word	0x00030228

000d5dec <HAL_I2C_Peek_Data>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, HAL_I2C_Peek_Data, int32_t(HAL_I2C_Interface, void*))
   d5dec:	b508      	push	{r3, lr}
   d5dee:	4b02      	ldr	r3, [pc, #8]	; (d5df8 <HAL_I2C_Peek_Data+0xc>)
   d5df0:	681b      	ldr	r3, [r3, #0]
   d5df2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   d5df4:	9301      	str	r3, [sp, #4]
   d5df6:	bd08      	pop	{r3, pc}
   d5df8:	00030228 	.word	0x00030228

000d5dfc <HAL_I2C_Flush_Data>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, HAL_I2C_Flush_Data, void(HAL_I2C_Interface, void*))
   d5dfc:	b508      	push	{r3, lr}
   d5dfe:	4b02      	ldr	r3, [pc, #8]	; (d5e08 <HAL_I2C_Flush_Data+0xc>)
   d5e00:	681b      	ldr	r3, [r3, #0]
   d5e02:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   d5e04:	9301      	str	r3, [sp, #4]
   d5e06:	bd08      	pop	{r3, pc}
   d5e08:	00030228 	.word	0x00030228

000d5e0c <HAL_I2C_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, HAL_I2C_Is_Enabled, bool(HAL_I2C_Interface, void*))
   d5e0c:	b508      	push	{r3, lr}
   d5e0e:	4b02      	ldr	r3, [pc, #8]	; (d5e18 <HAL_I2C_Is_Enabled+0xc>)
   d5e10:	681b      	ldr	r3, [r3, #0]
   d5e12:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   d5e14:	9301      	str	r3, [sp, #4]
   d5e16:	bd08      	pop	{r3, pc}
   d5e18:	00030228 	.word	0x00030228

000d5e1c <HAL_I2C_Init>:
DYNALIB_FN(BASE_IDX + 14, hal_i2c, HAL_I2C_Set_Callback_On_Receive, void(HAL_I2C_Interface, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, HAL_I2C_Set_Callback_On_Request, void(HAL_I2C_Interface, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, HAL_I2C_Init, int(HAL_I2C_Interface, const HAL_I2C_Config*))
   d5e1c:	b508      	push	{r3, lr}
   d5e1e:	4b02      	ldr	r3, [pc, #8]	; (d5e28 <HAL_I2C_Init+0xc>)
   d5e20:	681b      	ldr	r3, [r3, #0]
   d5e22:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   d5e24:	9301      	str	r3, [sp, #4]
   d5e26:	bd08      	pop	{r3, pc}
   d5e28:	00030228 	.word	0x00030228

000d5e2c <sock_accept>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_socket)

DYNALIB_FN(0, hal_socket, sock_accept, int(int, struct sockaddr*, socklen_t*))
   d5e2c:	b508      	push	{r3, lr}
   d5e2e:	4b02      	ldr	r3, [pc, #8]	; (d5e38 <sock_accept+0xc>)
   d5e30:	681b      	ldr	r3, [r3, #0]
   d5e32:	681b      	ldr	r3, [r3, #0]
   d5e34:	9301      	str	r3, [sp, #4]
   d5e36:	bd08      	pop	{r3, pc}
   d5e38:	00030238 	.word	0x00030238

000d5e3c <sock_bind>:
DYNALIB_FN(1, hal_socket, sock_bind, int(int, const struct sockaddr*, socklen_t))
   d5e3c:	b508      	push	{r3, lr}
   d5e3e:	4b02      	ldr	r3, [pc, #8]	; (d5e48 <sock_bind+0xc>)
   d5e40:	681b      	ldr	r3, [r3, #0]
   d5e42:	685b      	ldr	r3, [r3, #4]
   d5e44:	9301      	str	r3, [sp, #4]
   d5e46:	bd08      	pop	{r3, pc}
   d5e48:	00030238 	.word	0x00030238

000d5e4c <sock_getpeername>:
DYNALIB_FN(2, hal_socket, sock_shutdown, int(int, int))
DYNALIB_FN(3, hal_socket, sock_getpeername, int(int, struct sockaddr*, socklen_t*))
   d5e4c:	b508      	push	{r3, lr}
   d5e4e:	4b02      	ldr	r3, [pc, #8]	; (d5e58 <sock_getpeername+0xc>)
   d5e50:	681b      	ldr	r3, [r3, #0]
   d5e52:	68db      	ldr	r3, [r3, #12]
   d5e54:	9301      	str	r3, [sp, #4]
   d5e56:	bd08      	pop	{r3, pc}
   d5e58:	00030238 	.word	0x00030238

000d5e5c <sock_setsockopt>:
DYNALIB_FN(4, hal_socket, sock_getsockname, int(int, struct sockaddr*, socklen_t*))
DYNALIB_FN(5, hal_socket, sock_getsockopt, int(int, int, int, void*, socklen_t*))
DYNALIB_FN(6, hal_socket, sock_setsockopt, int(int, int, int, const void*, socklen_t))
   d5e5c:	b508      	push	{r3, lr}
   d5e5e:	4b02      	ldr	r3, [pc, #8]	; (d5e68 <sock_setsockopt+0xc>)
   d5e60:	681b      	ldr	r3, [r3, #0]
   d5e62:	699b      	ldr	r3, [r3, #24]
   d5e64:	9301      	str	r3, [sp, #4]
   d5e66:	bd08      	pop	{r3, pc}
   d5e68:	00030238 	.word	0x00030238

000d5e6c <sock_close>:
DYNALIB_FN(7, hal_socket, sock_close, int(int))
   d5e6c:	b508      	push	{r3, lr}
   d5e6e:	4b02      	ldr	r3, [pc, #8]	; (d5e78 <sock_close+0xc>)
   d5e70:	681b      	ldr	r3, [r3, #0]
   d5e72:	69db      	ldr	r3, [r3, #28]
   d5e74:	9301      	str	r3, [sp, #4]
   d5e76:	bd08      	pop	{r3, pc}
   d5e78:	00030238 	.word	0x00030238

000d5e7c <sock_connect>:
DYNALIB_FN(8, hal_socket, sock_connect, int(int, const struct sockaddr*, socklen_t))
   d5e7c:	b508      	push	{r3, lr}
   d5e7e:	4b02      	ldr	r3, [pc, #8]	; (d5e88 <sock_connect+0xc>)
   d5e80:	681b      	ldr	r3, [r3, #0]
   d5e82:	6a1b      	ldr	r3, [r3, #32]
   d5e84:	9301      	str	r3, [sp, #4]
   d5e86:	bd08      	pop	{r3, pc}
   d5e88:	00030238 	.word	0x00030238

000d5e8c <sock_listen>:
DYNALIB_FN(9, hal_socket, sock_listen, int(int, int))
   d5e8c:	b508      	push	{r3, lr}
   d5e8e:	4b02      	ldr	r3, [pc, #8]	; (d5e98 <sock_listen+0xc>)
   d5e90:	681b      	ldr	r3, [r3, #0]
   d5e92:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   d5e94:	9301      	str	r3, [sp, #4]
   d5e96:	bd08      	pop	{r3, pc}
   d5e98:	00030238 	.word	0x00030238

000d5e9c <sock_recv>:
DYNALIB_FN(10, hal_socket, sock_recv, int(int, void*, size_t, int))
   d5e9c:	b508      	push	{r3, lr}
   d5e9e:	4b02      	ldr	r3, [pc, #8]	; (d5ea8 <sock_recv+0xc>)
   d5ea0:	681b      	ldr	r3, [r3, #0]
   d5ea2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   d5ea4:	9301      	str	r3, [sp, #4]
   d5ea6:	bd08      	pop	{r3, pc}
   d5ea8:	00030238 	.word	0x00030238

000d5eac <sock_send>:
DYNALIB_FN(11, hal_socket, sock_recvfrom, int(int, void*, size_t, int, struct sockaddr*, socklen_t*))
DYNALIB_FN(12, hal_socket, sock_send, int(int, const void*, size_t, int))
   d5eac:	b508      	push	{r3, lr}
   d5eae:	4b02      	ldr	r3, [pc, #8]	; (d5eb8 <sock_send+0xc>)
   d5eb0:	681b      	ldr	r3, [r3, #0]
   d5eb2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   d5eb4:	9301      	str	r3, [sp, #4]
   d5eb6:	bd08      	pop	{r3, pc}
   d5eb8:	00030238 	.word	0x00030238

000d5ebc <sock_socket>:
DYNALIB_FN(13, hal_socket, sock_sendto, int(int, const void*, size_t, int, const struct sockaddr*, socklen_t))
DYNALIB_FN(14, hal_socket, sock_socket, int(int, int, int))
   d5ebc:	b508      	push	{r3, lr}
   d5ebe:	4b02      	ldr	r3, [pc, #8]	; (d5ec8 <sock_socket+0xc>)
   d5ec0:	681b      	ldr	r3, [r3, #0]
   d5ec2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   d5ec4:	9301      	str	r3, [sp, #4]
   d5ec6:	bd08      	pop	{r3, pc}
   d5ec8:	00030238 	.word	0x00030238

000d5ecc <sock_fcntl>:
DYNALIB_FN(15, hal_socket, sock_fcntl, int(int, int, ...))
   d5ecc:	b508      	push	{r3, lr}
   d5ece:	4b02      	ldr	r3, [pc, #8]	; (d5ed8 <sock_fcntl+0xc>)
   d5ed0:	681b      	ldr	r3, [r3, #0]
   d5ed2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   d5ed4:	9301      	str	r3, [sp, #4]
   d5ed6:	bd08      	pop	{r3, pc}
   d5ed8:	00030238 	.word	0x00030238

000d5edc <HAL_USB_USART_Init>:
#endif

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
   d5edc:	b508      	push	{r3, lr}
   d5ede:	4b02      	ldr	r3, [pc, #8]	; (d5ee8 <HAL_USB_USART_Init+0xc>)
   d5ee0:	681b      	ldr	r3, [r3, #0]
   d5ee2:	681b      	ldr	r3, [r3, #0]
   d5ee4:	9301      	str	r3, [sp, #4]
   d5ee6:	bd08      	pop	{r3, pc}
   d5ee8:	0003024c 	.word	0x0003024c

000d5eec <HAL_USB_USART_Available_Data>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
   d5eec:	b508      	push	{r3, lr}
   d5eee:	4b02      	ldr	r3, [pc, #8]	; (d5ef8 <HAL_USB_USART_Available_Data+0xc>)
   d5ef0:	681b      	ldr	r3, [r3, #0]
   d5ef2:	691b      	ldr	r3, [r3, #16]
   d5ef4:	9301      	str	r3, [sp, #4]
   d5ef6:	bd08      	pop	{r3, pc}
   d5ef8:	0003024c 	.word	0x0003024c

000d5efc <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
   d5efc:	b508      	push	{r3, lr}
   d5efe:	4b02      	ldr	r3, [pc, #8]	; (d5f08 <HAL_USB_USART_Available_Data_For_Write+0xc>)
   d5f00:	681b      	ldr	r3, [r3, #0]
   d5f02:	695b      	ldr	r3, [r3, #20]
   d5f04:	9301      	str	r3, [sp, #4]
   d5f06:	bd08      	pop	{r3, pc}
   d5f08:	0003024c 	.word	0x0003024c

000d5f0c <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
   d5f0c:	b508      	push	{r3, lr}
   d5f0e:	4b02      	ldr	r3, [pc, #8]	; (d5f18 <HAL_USB_USART_Receive_Data+0xc>)
   d5f10:	681b      	ldr	r3, [r3, #0]
   d5f12:	699b      	ldr	r3, [r3, #24]
   d5f14:	9301      	str	r3, [sp, #4]
   d5f16:	bd08      	pop	{r3, pc}
   d5f18:	0003024c 	.word	0x0003024c

000d5f1c <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
   d5f1c:	b508      	push	{r3, lr}
   d5f1e:	4b02      	ldr	r3, [pc, #8]	; (d5f28 <HAL_USB_USART_Send_Data+0xc>)
   d5f20:	681b      	ldr	r3, [r3, #0]
   d5f22:	69db      	ldr	r3, [r3, #28]
   d5f24:	9301      	str	r3, [sp, #4]
   d5f26:	bd08      	pop	{r3, pc}
   d5f28:	0003024c 	.word	0x0003024c

000d5f2c <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
   d5f2c:	b508      	push	{r3, lr}
   d5f2e:	4b02      	ldr	r3, [pc, #8]	; (d5f38 <HAL_USB_USART_Flush_Data+0xc>)
   d5f30:	681b      	ldr	r3, [r3, #0]
   d5f32:	6a1b      	ldr	r3, [r3, #32]
   d5f34:	9301      	str	r3, [sp, #4]
   d5f36:	bd08      	pop	{r3, pc}
   d5f38:	0003024c 	.word	0x0003024c

000d5f3c <panic_>:
DYNALIB_FN(9, services, LED_Toggle, void(Led_TypeDef))
DYNALIB_FN(10, services, LED_Fade, void(Led_TypeDef))
DYNALIB_FN(11, services, Get_LED_Brightness, uint8_t(void))

DYNALIB_FN(12, services, set_logger_output, void(debug_output_fn, LoggerOutputLevel)) // Deprecated
DYNALIB_FN(13, services, panic_, void(ePanicCode, void*, void(*)(uint32_t)))
   d5f3c:	b508      	push	{r3, lr}
   d5f3e:	4b02      	ldr	r3, [pc, #8]	; (d5f48 <panic_+0xc>)
   d5f40:	681b      	ldr	r3, [r3, #0]
   d5f42:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   d5f44:	9301      	str	r3, [sp, #4]
   d5f46:	bd08      	pop	{r3, pc}
   d5f48:	00030260 	.word	0x00030260

000d5f4c <log_message>:
DYNALIB_FN(16, services, log_print_, void(int, int, const char*, const char*, const char*, ...)) // Deprecated
DYNALIB_FN(17, services, LED_RGB_SetChangeHandler, void(led_update_handler_fn, void*))
DYNALIB_FN(18, services, log_print_direct_, void(int, void*, const char*, ...)) // Deprecated
DYNALIB_FN(19, services, LED_GetColor, uint32_t(uint32_t, void*))

DYNALIB_FN(20, services, log_message, void(int, const char*, LogAttributes*, void*, const char*, ...))
   d5f4c:	b508      	push	{r3, lr}
   d5f4e:	4b02      	ldr	r3, [pc, #8]	; (d5f58 <log_message+0xc>)
   d5f50:	681b      	ldr	r3, [r3, #0]
   d5f52:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   d5f54:	9301      	str	r3, [sp, #4]
   d5f56:	bd08      	pop	{r3, pc}
   d5f58:	00030260 	.word	0x00030260

000d5f5c <log_message_v>:
DYNALIB_FN(21, services, log_message_v, void(int, const char*, LogAttributes*, void*, const char*, va_list))
   d5f5c:	b508      	push	{r3, lr}
   d5f5e:	4b02      	ldr	r3, [pc, #8]	; (d5f68 <log_message_v+0xc>)
   d5f60:	681b      	ldr	r3, [r3, #0]
   d5f62:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   d5f64:	9301      	str	r3, [sp, #4]
   d5f66:	bd08      	pop	{r3, pc}
   d5f68:	00030260 	.word	0x00030260

000d5f6c <system_mode>:
#include "system_power.h"
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
   d5f6c:	b508      	push	{r3, lr}
   d5f6e:	4b02      	ldr	r3, [pc, #8]	; (d5f78 <system_mode+0xc>)
   d5f70:	681b      	ldr	r3, [r3, #0]
   d5f72:	681b      	ldr	r3, [r3, #0]
   d5f74:	9301      	str	r3, [sp, #4]
   d5f76:	bd08      	pop	{r3, pc}
   d5f78:	00030220 	.word	0x00030220

000d5f7c <set_system_mode>:
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
   d5f7c:	b508      	push	{r3, lr}
   d5f7e:	4b02      	ldr	r3, [pc, #8]	; (d5f88 <set_system_mode+0xc>)
   d5f80:	681b      	ldr	r3, [r3, #0]
   d5f82:	685b      	ldr	r3, [r3, #4]
   d5f84:	9301      	str	r3, [sp, #4]
   d5f86:	bd08      	pop	{r3, pc}
   d5f88:	00030220 	.word	0x00030220

000d5f8c <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
   d5f8c:	b508      	push	{r3, lr}
   d5f8e:	4b02      	ldr	r3, [pc, #8]	; (d5f98 <system_delay_ms+0xc>)
   d5f90:	681b      	ldr	r3, [r3, #0]
   d5f92:	695b      	ldr	r3, [r3, #20]
   d5f94:	9301      	str	r3, [sp, #4]
   d5f96:	bd08      	pop	{r3, pc}
   d5f98:	00030220 	.word	0x00030220

000d5f9c <system_thread_get_state>:
DYNALIB_FN(18, system, Spark_Finish_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))

DYNALIB_FN(19, system, application_thread_current, uint8_t(void*))
DYNALIB_FN(20, system, system_thread_current, uint8_t(void*))
DYNALIB_FN(21, system, application_thread_invoke, uint8_t(void(*)(void*), void*, void*))
DYNALIB_FN(22, system, system_thread_get_state, spark::feature::State(void*))
   d5f9c:	b508      	push	{r3, lr}
   d5f9e:	4b02      	ldr	r3, [pc, #8]	; (d5fa8 <system_thread_get_state+0xc>)
   d5fa0:	681b      	ldr	r3, [r3, #0]
   d5fa2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   d5fa4:	9301      	str	r3, [sp, #4]
   d5fa6:	bd08      	pop	{r3, pc}
   d5fa8:	00030220 	.word	0x00030220

000d5fac <system_ctrl_set_app_request_handler>:
DYNALIB_FN(BASE_IDX + 6, system, led_pattern_period, uint16_t(int, int, void*))
DYNALIB_FN(BASE_IDX + 7, system, system_set_tester_handlers, int(system_tester_handlers_t*, void*))
DYNALIB_FN(BASE_IDX + 8, system, system_format_diag_data, int(const uint16_t*, size_t, unsigned, appender_fn, void*, void*))

// Control requests
DYNALIB_FN(BASE_IDX + 9, system, system_ctrl_set_app_request_handler, int(ctrl_request_handler_fn, void*))
   d5fac:	b508      	push	{r3, lr}
   d5fae:	4b03      	ldr	r3, [pc, #12]	; (d5fbc <system_ctrl_set_app_request_handler+0x10>)
   d5fb0:	681b      	ldr	r3, [r3, #0]
   d5fb2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   d5fb6:	9301      	str	r3, [sp, #4]
   d5fb8:	bd08      	pop	{r3, pc}
   d5fba:	0000      	.short	0x0000
   d5fbc:	00030220 	.word	0x00030220

000d5fc0 <system_ctrl_set_result>:
DYNALIB_FN(BASE_IDX + 10, system, system_ctrl_alloc_reply_data, int(ctrl_request*, size_t, void*))
DYNALIB_FN(BASE_IDX + 11, system, system_ctrl_free_request_data, void(ctrl_request*, void*))
DYNALIB_FN(BASE_IDX + 12, system, system_ctrl_set_result, void(ctrl_request*, int, ctrl_completion_handler_fn, void*, void*))
   d5fc0:	b508      	push	{r3, lr}
   d5fc2:	4b03      	ldr	r3, [pc, #12]	; (d5fd0 <system_ctrl_set_result+0x10>)
   d5fc4:	681b      	ldr	r3, [r3, #0]
   d5fc6:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
   d5fca:	9301      	str	r3, [sp, #4]
   d5fcc:	bd08      	pop	{r3, pc}
   d5fce:	0000      	.short	0x0000
   d5fd0:	00030220 	.word	0x00030220

000d5fd4 <network_config>:
#include "system_network.h"
#endif

DYNALIB_BEGIN(system_net)

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
   d5fd4:	b508      	push	{r3, lr}
   d5fd6:	4b02      	ldr	r3, [pc, #8]	; (d5fe0 <network_config+0xc>)
   d5fd8:	681b      	ldr	r3, [r3, #0]
   d5fda:	681b      	ldr	r3, [r3, #0]
   d5fdc:	9301      	str	r3, [sp, #4]
   d5fde:	bd08      	pop	{r3, pc}
   d5fe0:	00030240 	.word	0x00030240

000d5fe4 <network_connect>:
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
   d5fe4:	b508      	push	{r3, lr}
   d5fe6:	4b02      	ldr	r3, [pc, #8]	; (d5ff0 <network_connect+0xc>)
   d5fe8:	681b      	ldr	r3, [r3, #0]
   d5fea:	685b      	ldr	r3, [r3, #4]
   d5fec:	9301      	str	r3, [sp, #4]
   d5fee:	bd08      	pop	{r3, pc}
   d5ff0:	00030240 	.word	0x00030240

000d5ff4 <network_connecting>:
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
   d5ff4:	b508      	push	{r3, lr}
   d5ff6:	4b02      	ldr	r3, [pc, #8]	; (d6000 <network_connecting+0xc>)
   d5ff8:	681b      	ldr	r3, [r3, #0]
   d5ffa:	689b      	ldr	r3, [r3, #8]
   d5ffc:	9301      	str	r3, [sp, #4]
   d5ffe:	bd08      	pop	{r3, pc}
   d6000:	00030240 	.word	0x00030240

000d6004 <network_disconnect>:
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
   d6004:	b508      	push	{r3, lr}
   d6006:	4b02      	ldr	r3, [pc, #8]	; (d6010 <network_disconnect+0xc>)
   d6008:	681b      	ldr	r3, [r3, #0]
   d600a:	68db      	ldr	r3, [r3, #12]
   d600c:	9301      	str	r3, [sp, #4]
   d600e:	bd08      	pop	{r3, pc}
   d6010:	00030240 	.word	0x00030240

000d6014 <network_ready>:
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
   d6014:	b508      	push	{r3, lr}
   d6016:	4b02      	ldr	r3, [pc, #8]	; (d6020 <network_ready+0xc>)
   d6018:	681b      	ldr	r3, [r3, #0]
   d601a:	691b      	ldr	r3, [r3, #16]
   d601c:	9301      	str	r3, [sp, #4]
   d601e:	bd08      	pop	{r3, pc}
   d6020:	00030240 	.word	0x00030240

000d6024 <network_on>:
DYNALIB_FN(5, system_net, network_on, void(network_handle_t, uint32_t, uint32_t, void*))
   d6024:	b508      	push	{r3, lr}
   d6026:	4b02      	ldr	r3, [pc, #8]	; (d6030 <network_on+0xc>)
   d6028:	681b      	ldr	r3, [r3, #0]
   d602a:	695b      	ldr	r3, [r3, #20]
   d602c:	9301      	str	r3, [sp, #4]
   d602e:	bd08      	pop	{r3, pc}
   d6030:	00030240 	.word	0x00030240

000d6034 <network_off>:
DYNALIB_FN(6, system_net, network_off, void(network_handle_t, uint32_t, uint32_t, void*))
   d6034:	b508      	push	{r3, lr}
   d6036:	4b02      	ldr	r3, [pc, #8]	; (d6040 <network_off+0xc>)
   d6038:	681b      	ldr	r3, [r3, #0]
   d603a:	699b      	ldr	r3, [r3, #24]
   d603c:	9301      	str	r3, [sp, #4]
   d603e:	bd08      	pop	{r3, pc}
   d6040:	00030240 	.word	0x00030240

000d6044 <network_listen>:
DYNALIB_FN(7, system_net, network_listen, void(network_handle_t, uint32_t, void*))
   d6044:	b508      	push	{r3, lr}
   d6046:	4b02      	ldr	r3, [pc, #8]	; (d6050 <network_listen+0xc>)
   d6048:	681b      	ldr	r3, [r3, #0]
   d604a:	69db      	ldr	r3, [r3, #28]
   d604c:	9301      	str	r3, [sp, #4]
   d604e:	bd08      	pop	{r3, pc}
   d6050:	00030240 	.word	0x00030240

000d6054 <network_listening>:
DYNALIB_FN(8, system_net, network_listening, bool(network_handle_t, uint32_t, void*))
   d6054:	b508      	push	{r3, lr}
   d6056:	4b02      	ldr	r3, [pc, #8]	; (d6060 <network_listening+0xc>)
   d6058:	681b      	ldr	r3, [r3, #0]
   d605a:	6a1b      	ldr	r3, [r3, #32]
   d605c:	9301      	str	r3, [sp, #4]
   d605e:	bd08      	pop	{r3, pc}
   d6060:	00030240 	.word	0x00030240

000d6064 <network_set_listen_timeout>:
DYNALIB_FN(9, system_net, network_has_credentials, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(10, system_net, network_set_credentials, int(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(11, system_net, network_clear_credentials, bool(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(12, system_net, network_set_listen_timeout, void(network_handle_t, uint16_t, void*))
   d6064:	b508      	push	{r3, lr}
   d6066:	4b02      	ldr	r3, [pc, #8]	; (d6070 <network_set_listen_timeout+0xc>)
   d6068:	681b      	ldr	r3, [r3, #0]
   d606a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   d606c:	9301      	str	r3, [sp, #4]
   d606e:	bd08      	pop	{r3, pc}
   d6070:	00030240 	.word	0x00030240

000d6074 <network_get_listen_timeout>:
DYNALIB_FN(13, system_net, network_get_listen_timeout, uint16_t(network_handle_t, uint32_t, void*))
   d6074:	b508      	push	{r3, lr}
   d6076:	4b02      	ldr	r3, [pc, #8]	; (d6080 <network_get_listen_timeout+0xc>)
   d6078:	681b      	ldr	r3, [r3, #0]
   d607a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   d607c:	9301      	str	r3, [sp, #4]
   d607e:	bd08      	pop	{r3, pc}
   d6080:	00030240 	.word	0x00030240

000d6084 <spark_variable>:
#endif


DYNALIB_BEGIN(system_cloud)

DYNALIB_FN(0, system_cloud, spark_variable, bool(const char*, const void*, Spark_Data_TypeDef, spark_variable_t*))
   d6084:	b508      	push	{r3, lr}
   d6086:	4b02      	ldr	r3, [pc, #8]	; (d6090 <spark_variable+0xc>)
   d6088:	681b      	ldr	r3, [r3, #0]
   d608a:	681b      	ldr	r3, [r3, #0]
   d608c:	9301      	str	r3, [sp, #4]
   d608e:	bd08      	pop	{r3, pc}
   d6090:	00030244 	.word	0x00030244

000d6094 <spark_function>:
DYNALIB_FN(1, system_cloud, spark_function, bool(const char*, p_user_function_int_str_t, void*))
   d6094:	b508      	push	{r3, lr}
   d6096:	4b02      	ldr	r3, [pc, #8]	; (d60a0 <spark_function+0xc>)
   d6098:	681b      	ldr	r3, [r3, #0]
   d609a:	685b      	ldr	r3, [r3, #4]
   d609c:	9301      	str	r3, [sp, #4]
   d609e:	bd08      	pop	{r3, pc}
   d60a0:	00030244 	.word	0x00030244

000d60a4 <spark_process>:
DYNALIB_FN(2, system_cloud, spark_process, void(void))
   d60a4:	b508      	push	{r3, lr}
   d60a6:	4b02      	ldr	r3, [pc, #8]	; (d60b0 <spark_process+0xc>)
   d60a8:	681b      	ldr	r3, [r3, #0]
   d60aa:	689b      	ldr	r3, [r3, #8]
   d60ac:	9301      	str	r3, [sp, #4]
   d60ae:	bd08      	pop	{r3, pc}
   d60b0:	00030244 	.word	0x00030244

000d60b4 <spark_cloud_flag_connected>:
DYNALIB_FN(3, system_cloud, spark_cloud_flag_connect, void(void))
DYNALIB_FN(4, system_cloud, spark_cloud_flag_disconnect, void(void))
DYNALIB_FN(5, system_cloud, spark_cloud_flag_connected, bool(void))
   d60b4:	b508      	push	{r3, lr}
   d60b6:	4b02      	ldr	r3, [pc, #8]	; (d60c0 <spark_cloud_flag_connected+0xc>)
   d60b8:	681b      	ldr	r3, [r3, #0]
   d60ba:	695b      	ldr	r3, [r3, #20]
   d60bc:	9301      	str	r3, [sp, #4]
   d60be:	bd08      	pop	{r3, pc}
   d60c0:	00030244 	.word	0x00030244

000d60c4 <spark_sync_time_pending>:
DYNALIB_FN(7, system_cloud, spark_deviceID, String(void))
DYNALIB_FN(8, system_cloud, spark_send_event, bool(const char*, const char*, int, uint32_t, void*))
DYNALIB_FN(9, system_cloud, spark_subscribe, bool(const char*, EventHandler, void*, Spark_Subscription_Scope_TypeDef, const char*, void*))
DYNALIB_FN(10, system_cloud, spark_unsubscribe, void(void*))
DYNALIB_FN(11, system_cloud, spark_sync_time, bool(void*))
DYNALIB_FN(12, system_cloud, spark_sync_time_pending, bool(void*))
   d60c4:	b508      	push	{r3, lr}
   d60c6:	4b02      	ldr	r3, [pc, #8]	; (d60d0 <spark_sync_time_pending+0xc>)
   d60c8:	681b      	ldr	r3, [r3, #0]
   d60ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   d60cc:	9301      	str	r3, [sp, #4]
   d60ce:	bd08      	pop	{r3, pc}
   d60d0:	00030244 	.word	0x00030244

000d60d4 <spark_set_random_seed_from_cloud_handler>:
DYNALIB_FN(13, system_cloud, spark_sync_time_last, system_tick_t(time_t*, void*))
DYNALIB_FN(14, system_cloud, spark_set_connection_property, int(unsigned, unsigned, particle::protocol::connection_properties_t*, void*))
DYNALIB_FN(15, system_cloud, spark_set_random_seed_from_cloud_handler, int(void (*handler)(unsigned int), void*))
   d60d4:	b508      	push	{r3, lr}
   d60d6:	4b02      	ldr	r3, [pc, #8]	; (d60e0 <spark_set_random_seed_from_cloud_handler+0xc>)
   d60d8:	681b      	ldr	r3, [r3, #0]
   d60da:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   d60dc:	9301      	str	r3, [sp, #4]
   d60de:	bd08      	pop	{r3, pc}
   d60e0:	00030244 	.word	0x00030244

000d60e4 <malloc>:
#include <assert.h>
#endif

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
   d60e4:	b508      	push	{r3, lr}
   d60e6:	4b02      	ldr	r3, [pc, #8]	; (d60f0 <malloc+0xc>)
   d60e8:	681b      	ldr	r3, [r3, #0]
   d60ea:	681b      	ldr	r3, [r3, #0]
   d60ec:	9301      	str	r3, [sp, #4]
   d60ee:	bd08      	pop	{r3, pc}
   d60f0:	0003021c 	.word	0x0003021c

000d60f4 <free>:
DYNALIB_FN(1, rt, free, void(void*))
   d60f4:	b508      	push	{r3, lr}
   d60f6:	4b02      	ldr	r3, [pc, #8]	; (d6100 <free+0xc>)
   d60f8:	681b      	ldr	r3, [r3, #0]
   d60fa:	685b      	ldr	r3, [r3, #4]
   d60fc:	9301      	str	r3, [sp, #4]
   d60fe:	bd08      	pop	{r3, pc}
   d6100:	0003021c 	.word	0x0003021c

000d6104 <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
   d6104:	b508      	push	{r3, lr}
   d6106:	4b02      	ldr	r3, [pc, #8]	; (d6110 <realloc+0xc>)
   d6108:	681b      	ldr	r3, [r3, #0]
   d610a:	689b      	ldr	r3, [r3, #8]
   d610c:	9301      	str	r3, [sp, #4]
   d610e:	bd08      	pop	{r3, pc}
   d6110:	0003021c 	.word	0x0003021c

000d6114 <siprintf>:
DYNALIB_FN(3, rt, sprintf, int(char*, const char*, ...))
DYNALIB_FN(4, rt, siprintf, int(char*, const char*, ...))
   d6114:	b508      	push	{r3, lr}
   d6116:	4b02      	ldr	r3, [pc, #8]	; (d6120 <siprintf+0xc>)
   d6118:	681b      	ldr	r3, [r3, #0]
   d611a:	691b      	ldr	r3, [r3, #16]
   d611c:	9301      	str	r3, [sp, #4]
   d611e:	bd08      	pop	{r3, pc}
   d6120:	0003021c 	.word	0x0003021c

000d6124 <sscanf>:
DYNALIB_FN(5, rt, sscanf, int(const char*, const char*, ...))
   d6124:	b508      	push	{r3, lr}
   d6126:	4b02      	ldr	r3, [pc, #8]	; (d6130 <sscanf+0xc>)
   d6128:	681b      	ldr	r3, [r3, #0]
   d612a:	695b      	ldr	r3, [r3, #20]
   d612c:	9301      	str	r3, [sp, #4]
   d612e:	bd08      	pop	{r3, pc}
   d6130:	0003021c 	.word	0x0003021c

000d6134 <siscanf>:
DYNALIB_FN(6, rt, siscanf, int(const char*, const char*, ...))
   d6134:	b508      	push	{r3, lr}
   d6136:	4b02      	ldr	r3, [pc, #8]	; (d6140 <siscanf+0xc>)
   d6138:	681b      	ldr	r3, [r3, #0]
   d613a:	699b      	ldr	r3, [r3, #24]
   d613c:	9301      	str	r3, [sp, #4]
   d613e:	bd08      	pop	{r3, pc}
   d6140:	0003021c 	.word	0x0003021c

000d6144 <snprintf>:
DYNALIB_FN(7, rt, snprintf, int(char*, size_t, const char*, ...))
   d6144:	b508      	push	{r3, lr}
   d6146:	4b02      	ldr	r3, [pc, #8]	; (d6150 <snprintf+0xc>)
   d6148:	681b      	ldr	r3, [r3, #0]
   d614a:	69db      	ldr	r3, [r3, #28]
   d614c:	9301      	str	r3, [sp, #4]
   d614e:	bd08      	pop	{r3, pc}
   d6150:	0003021c 	.word	0x0003021c

000d6154 <sniprintf>:
DYNALIB_FN(8, rt, sniprintf, int(char*, size_t, const char*, ...))
   d6154:	b508      	push	{r3, lr}
   d6156:	4b02      	ldr	r3, [pc, #8]	; (d6160 <sniprintf+0xc>)
   d6158:	681b      	ldr	r3, [r3, #0]
   d615a:	6a1b      	ldr	r3, [r3, #32]
   d615c:	9301      	str	r3, [sp, #4]
   d615e:	bd08      	pop	{r3, pc}
   d6160:	0003021c 	.word	0x0003021c

000d6164 <_malloc_r>:
DYNALIB_FN(9, rt, vsnprintf, int(char*, size_t, const char*, va_list))
DYNALIB_FN(10, rt, vsniprintf, int(char*, size_t, const char*, va_list))
DYNALIB_FN(11, rt, abort, void(void))
DYNALIB_FN(12, rt, _malloc_r, void*(struct _reent*, size_t))
   d6164:	b508      	push	{r3, lr}
   d6166:	4b02      	ldr	r3, [pc, #8]	; (d6170 <_malloc_r+0xc>)
   d6168:	681b      	ldr	r3, [r3, #0]
   d616a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   d616c:	9301      	str	r3, [sp, #4]
   d616e:	bd08      	pop	{r3, pc}
   d6170:	0003021c 	.word	0x0003021c

000d6174 <__errno>:
DYNALIB_FN(13, rt, _free_r, void(struct _reent*, void*))
DYNALIB_FN(14, rt, _realloc_r, void*(struct _reent*, void*, size_t))
DYNALIB_FN(15, rt, __errno, int*())
   d6174:	b508      	push	{r3, lr}
   d6176:	4b02      	ldr	r3, [pc, #8]	; (d6180 <__errno+0xc>)
   d6178:	681b      	ldr	r3, [r3, #0]
   d617a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   d617c:	9301      	str	r3, [sp, #4]
   d617e:	bd08      	pop	{r3, pc}
   d6180:	0003021c 	.word	0x0003021c

000d6184 <_ZN5spark13EthernetClass9listeningEv>:
    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
    }

    bool listening(void) {
        return network_listening(*this, 0, NULL);
   d6184:	2200      	movs	r2, #0
   d6186:	4611      	mov	r1, r2
   d6188:	6840      	ldr	r0, [r0, #4]
   d618a:	f7ff bf63 	b.w	d6054 <network_listening>

000d618e <_ZN5spark13EthernetClass16getListenTimeoutEv>:
    void setListenTimeout(uint16_t timeout) {
        network_set_listen_timeout(*this, timeout, NULL);
    }

    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
   d618e:	2200      	movs	r2, #0
   d6190:	4611      	mov	r1, r2
   d6192:	6840      	ldr	r0, [r0, #4]
   d6194:	f7ff bf6e 	b.w	d6074 <network_get_listen_timeout>

000d6198 <_ZN5spark13EthernetClass16setListenTimeoutEt>:
    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
    }

    void setListenTimeout(uint16_t timeout) {
        network_set_listen_timeout(*this, timeout, NULL);
   d6198:	2200      	movs	r2, #0
   d619a:	6840      	ldr	r0, [r0, #4]
   d619c:	f7ff bf62 	b.w	d6064 <network_set_listen_timeout>

000d61a0 <_ZN5spark13EthernetClass6listenEb>:
    void disconnect() {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
    }

    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
   d61a0:	2200      	movs	r2, #0
   d61a2:	f081 0101 	eor.w	r1, r1, #1
   d61a6:	6840      	ldr	r0, [r0, #4]
   d61a8:	f7ff bf4c 	b.w	d6044 <network_listen>

000d61ac <_ZN5spark13EthernetClass3offEv>:
    void on() {
        network_on(*this, 0, 0, NULL);
    }

    void off() {
        network_off(*this, 0, 0, NULL);
   d61ac:	2300      	movs	r3, #0
   d61ae:	461a      	mov	r2, r3
   d61b0:	4619      	mov	r1, r3
   d61b2:	6840      	ldr	r0, [r0, #4]
   d61b4:	f7ff bf3e 	b.w	d6034 <network_off>

000d61b8 <_ZN5spark13EthernetClass2onEv>:
    EthernetClass() :
            NetworkClass(NETWORK_INTERFACE_ETHERNET) {
    }

    void on() {
        network_on(*this, 0, 0, NULL);
   d61b8:	2300      	movs	r3, #0
   d61ba:	461a      	mov	r2, r3
   d61bc:	4619      	mov	r1, r3
   d61be:	6840      	ldr	r0, [r0, #4]
   d61c0:	f7ff bf30 	b.w	d6024 <network_on>

000d61c4 <_ZN5spark13EthernetClass5readyEv>:
    bool listening(void) {
        return network_listening(*this, 0, NULL);
    }

    bool ready() {
        return network_ready(*this, 0,  NULL);
   d61c4:	2200      	movs	r2, #0
   d61c6:	4611      	mov	r1, r2
   d61c8:	6840      	ldr	r0, [r0, #4]
   d61ca:	f7ff bf23 	b.w	d6014 <network_ready>

000d61ce <_ZN5spark13EthernetClass10connectingEv>:
    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
    }

    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
   d61ce:	2200      	movs	r2, #0
   d61d0:	4611      	mov	r1, r2
   d61d2:	6840      	ldr	r0, [r0, #4]
   d61d4:	f7ff bf0e 	b.w	d5ff4 <network_connecting>

000d61d8 <_ZN5spark13EthernetClass10disconnectEv>:
    }

    void disconnect() {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
   d61d8:	2200      	movs	r2, #0
   d61da:	2102      	movs	r1, #2
   d61dc:	6840      	ldr	r0, [r0, #4]
   d61de:	f7ff bf11 	b.w	d6004 <network_disconnect>

000d61e2 <_ZN5spark13EthernetClass7connectEj>:
    void off() {
        network_off(*this, 0, 0, NULL);
    }

    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
   d61e2:	2300      	movs	r3, #0
   d61e4:	461a      	mov	r2, r3
   d61e6:	6840      	ldr	r0, [r0, #4]
   d61e8:	f7ff befc 	b.w	d5fe4 <network_connect>

000d61ec <_GLOBAL__sub_I__ZN5spark8EthernetE>:
    static NetworkClass& from(network_interface_t nif);

    virtual IPAddress resolve(const char* name);

    explicit NetworkClass(network_interface_t iface)
            : iface_(iface) {
   d61ec:	4b02      	ldr	r3, [pc, #8]	; (d61f8 <_GLOBAL__sub_I__ZN5spark8EthernetE+0xc>)
   d61ee:	2203      	movs	r2, #3
   d61f0:	605a      	str	r2, [r3, #4]
    }

class EthernetClass : public NetworkClass {
public:
    EthernetClass() :
            NetworkClass(NETWORK_INTERFACE_ETHERNET) {
   d61f2:	4a02      	ldr	r2, [pc, #8]	; (d61fc <_GLOBAL__sub_I__ZN5spark8EthernetE+0x10>)
   d61f4:	601a      	str	r2, [r3, #0]
   d61f6:	4770      	bx	lr
   d61f8:	2003e298 	.word	0x2003e298
   d61fc:	000da5a0 	.word	0x000da5a0

000d6200 <_ZN8SPIClassC1E17HAL_SPI_Interface>:
    }
    return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}
} // namespace

SPIClass::SPIClass(HAL_SPI_Interface spi)
   d6200:	b510      	push	{r4, lr}
   d6202:	4604      	mov	r4, r0
{
    _spi = spi;
   d6204:	7001      	strb	r1, [r0, #0]
    HAL_SPI_Init(_spi);
   d6206:	4608      	mov	r0, r1
   d6208:	f7ff fd00 	bl	d5c0c <HAL_SPI_Init>
    _dividerReference = SPI_CLK_SYSTEM; // 0 indicates the system clock
   d620c:	2300      	movs	r3, #0
   d620e:	6063      	str	r3, [r4, #4]
}
   d6210:	4620      	mov	r0, r4
   d6212:	bd10      	pop	{r4, pc}

000d6214 <_ZN8SPIClass9isEnabledEv>:
bool SPIClass::isEnabled()
{
    // XXX: pinAvailable() will call this method potentially even from
    // interrupt context. `enabled` flag in HAL is usually just a volatile
    // variable, so it's fine not to acquire the lock here.
    return HAL_SPI_Is_Enabled(_spi);
   d6214:	7800      	ldrb	r0, [r0, #0]
   d6216:	f7ff bd01 	b.w	d5c1c <HAL_SPI_Is_Enabled>

000d621a <_ZN17SystemSleepResult22freeWakeupSourceMemoryEv.isra.2>:
    operator SleepResult() {
        return toSleepResult();
    }

private:
    void freeWakeupSourceMemory() {
   d621a:	b510      	push	{r4, lr}
   d621c:	4604      	mov	r4, r0
        if (wakeupSource_) {
   d621e:	6800      	ldr	r0, [r0, #0]
   d6220:	b118      	cbz	r0, d622a <_ZN17SystemSleepResult22freeWakeupSourceMemoryEv.isra.2+0x10>
            free(wakeupSource_);
   d6222:	f7ff ff67 	bl	d60f4 <free>
            wakeupSource_ = nullptr;
   d6226:	2300      	movs	r3, #0
   d6228:	6023      	str	r3, [r4, #0]
   d622a:	bd10      	pop	{r4, pc}

000d622c <_ZN11SystemClassD1Ev>:
    system_error_t error_;
    SleepResult compatResult_;
};


class SystemClass {
   d622c:	b510      	push	{r4, lr}
   d622e:	4604      	mov	r4, r0
        }
        return *this;
    }

    ~SystemSleepResult() {
        freeWakeupSourceMemory();
   d6230:	f7ff fff3 	bl	d621a <_ZN17SystemSleepResult22freeWakeupSourceMemoryEv.isra.2>
    system_error_t error_;
    SleepResult compatResult_;
};


class SystemClass {
   d6234:	4620      	mov	r0, r4
   d6236:	bd10      	pop	{r4, pc}

000d6238 <_GLOBAL__sub_I_System>:
    return wokenUpByRtc();
}

system_error_t SleepResult::error() const {
    return err_;
   d6238:	b510      	push	{r4, lr}

class SystemSleepResult {
public:
    SystemSleepResult()
            : wakeupSource_(nullptr),
              error_(SYSTEM_ERROR_NONE) {
   d623a:	4c09      	ldr	r4, [pc, #36]	; (d6260 <_GLOBAL__sub_I_System+0x28>)
   d623c:	2000      	movs	r0, #0
    WAKEUP_REASON_PIN_OR_RTC = 3,
    WAKEUP_REASON_UNKNOWN = 4
};

struct SleepResult {
    SleepResult() {}
   d623e:	f64f 73ff 	movw	r3, #65535	; 0xffff

class SystemSleepResult {
public:
    SystemSleepResult()
            : wakeupSource_(nullptr),
              error_(SYSTEM_ERROR_NONE) {
   d6242:	6020      	str	r0, [r4, #0]
   d6244:	80a0      	strh	r0, [r4, #4]
    WAKEUP_REASON_PIN_OR_RTC = 3,
    WAKEUP_REASON_UNKNOWN = 4
};

struct SleepResult {
    SleepResult() {}
   d6246:	71a0      	strb	r0, [r4, #6]
   d6248:	8120      	strh	r0, [r4, #8]
   d624a:	8163      	strh	r3, [r4, #10]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
   d624c:	f7ff fe96 	bl	d5f7c <set_system_mode>

#if Wiring_LogConfig
extern void(*log_process_ctrl_request_callback)(ctrl_request* req);
#endif

SystemClass System;
   d6250:	4620      	mov	r0, r4
   d6252:	4a04      	ldr	r2, [pc, #16]	; (d6264 <_GLOBAL__sub_I_System+0x2c>)
   d6254:	4904      	ldr	r1, [pc, #16]	; (d6268 <_GLOBAL__sub_I_System+0x30>)
    return wokenUpByRtc();
}

system_error_t SleepResult::error() const {
    return err_;
   d6256:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

#if Wiring_LogConfig
extern void(*log_process_ctrl_request_callback)(ctrl_request* req);
#endif

SystemClass System;
   d625a:	f001 bc47 	b.w	d7aec <__aeabi_atexit>
   d625e:	bf00      	nop
   d6260:	2003e2a0 	.word	0x2003e2a0
   d6264:	20034a40 	.word	0x20034a40
   d6268:	000d622d 	.word	0x000d622d

000d626c <_ZN21StringPrintableHelperD1Ev>:
{
	if (buffer) return float(atof(buffer));
	return 0;
}

class StringPrintableHelper : public Print
   d626c:	4770      	bx	lr

000d626e <_ZN21StringPrintableHelperD0Ev>:
   d626e:	b510      	push	{r4, lr}
   d6270:	210c      	movs	r1, #12
   d6272:	4604      	mov	r4, r0
   d6274:	f001 fc48 	bl	d7b08 <_ZdlPvj>
   d6278:	4620      	mov	r0, r4
   d627a:	bd10      	pop	{r4, pc}

000d627c <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
   d627c:	b510      	push	{r4, lr}
   d627e:	4604      	mov	r4, r0
{
	free(buffer);
   d6280:	6800      	ldr	r0, [r0, #0]
   d6282:	f7ff ff37 	bl	d60f4 <free>
}
   d6286:	4620      	mov	r0, r4
   d6288:	bd10      	pop	{r4, pc}

000d628a <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
   d628a:	b510      	push	{r4, lr}
   d628c:	4604      	mov	r4, r0
	if (buffer) free(buffer);
   d628e:	6800      	ldr	r0, [r0, #0]
   d6290:	b108      	cbz	r0, d6296 <_ZN6String10invalidateEv+0xc>
   d6292:	f7ff ff2f 	bl	d60f4 <free>
	buffer = NULL;
   d6296:	2300      	movs	r3, #0
   d6298:	6023      	str	r3, [r4, #0]
	capacity = len = 0;
   d629a:	60a3      	str	r3, [r4, #8]
   d629c:	6063      	str	r3, [r4, #4]
   d629e:	bd10      	pop	{r4, pc}

000d62a0 <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
   d62a0:	b538      	push	{r3, r4, r5, lr}
   d62a2:	4604      	mov	r4, r0
   d62a4:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
   d62a6:	6800      	ldr	r0, [r0, #0]
   d62a8:	3101      	adds	r1, #1
   d62aa:	f7ff ff2b 	bl	d6104 <realloc>
	if (newbuffer) {
   d62ae:	b110      	cbz	r0, d62b6 <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
   d62b0:	e884 0021 	stmia.w	r4, {r0, r5}
		return 1;
   d62b4:	2001      	movs	r0, #1
	}
	return 0;
}
   d62b6:	bd38      	pop	{r3, r4, r5, pc}

000d62b8 <_ZN6String7reserveEj>:
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
   d62b8:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
   d62ba:	6803      	ldr	r3, [r0, #0]
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
   d62bc:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
   d62be:	b113      	cbz	r3, d62c6 <_ZN6String7reserveEj+0xe>
   d62c0:	6843      	ldr	r3, [r0, #4]
   d62c2:	428b      	cmp	r3, r1
   d62c4:	d207      	bcs.n	d62d6 <_ZN6String7reserveEj+0x1e>
	if (changeBuffer(size)) {
   d62c6:	4620      	mov	r0, r4
   d62c8:	f7ff ffea 	bl	d62a0 <_ZN6String12changeBufferEj>
   d62cc:	b120      	cbz	r0, d62d8 <_ZN6String7reserveEj+0x20>
		if (len == 0) buffer[0] = 0;
   d62ce:	68a3      	ldr	r3, [r4, #8]
   d62d0:	b90b      	cbnz	r3, d62d6 <_ZN6String7reserveEj+0x1e>
   d62d2:	6822      	ldr	r2, [r4, #0]
   d62d4:	7013      	strb	r3, [r2, #0]
   d62d6:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
   d62d8:	bd10      	pop	{r4, pc}

000d62da <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
   d62da:	b570      	push	{r4, r5, r6, lr}
   d62dc:	460e      	mov	r6, r1
	if (!reserve(length)) {
   d62de:	4611      	mov	r1, r2
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
   d62e0:	4604      	mov	r4, r0
   d62e2:	4615      	mov	r5, r2
	if (!reserve(length)) {
   d62e4:	f7ff ffe8 	bl	d62b8 <_ZN6String7reserveEj>
   d62e8:	b918      	cbnz	r0, d62f2 <_ZN6String4copyEPKcj+0x18>
		invalidate();
   d62ea:	4620      	mov	r0, r4
   d62ec:	f7ff ffcd 	bl	d628a <_ZN6String10invalidateEv>
		return *this;
   d62f0:	e009      	b.n	d6306 <_ZN6String4copyEPKcj+0x2c>
	}
	len = length;
	memcpy(buffer, cstr, length);
   d62f2:	462a      	mov	r2, r5
   d62f4:	4631      	mov	r1, r6
{
	if (!reserve(length)) {
		invalidate();
		return *this;
	}
	len = length;
   d62f6:	60a5      	str	r5, [r4, #8]
	memcpy(buffer, cstr, length);
   d62f8:	6820      	ldr	r0, [r4, #0]
   d62fa:	f001 fea7 	bl	d804c <memcpy>
	buffer[len] = 0;
   d62fe:	6822      	ldr	r2, [r4, #0]
   d6300:	68a3      	ldr	r3, [r4, #8]
   d6302:	2100      	movs	r1, #0
   d6304:	54d1      	strb	r1, [r2, r3]
	return *this;
}
   d6306:	4620      	mov	r0, r4
   d6308:	bd70      	pop	{r4, r5, r6, pc}

000d630a <_ZN6StringC1EPK19__FlashStringHelper>:
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
   d630a:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
   d630c:	2300      	movs	r3, #0
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
   d630e:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
   d6310:	6003      	str	r3, [r0, #0]
	capacity = 0;
   d6312:	6043      	str	r3, [r0, #4]
	len = 0;
   d6314:	6083      	str	r3, [r0, #8]
	flags = 0;
   d6316:	7303      	strb	r3, [r0, #12]

String::String(const __FlashStringHelper *pstr)
{
	init();
	const char* cstr = reinterpret_cast<const char*>(pstr);
	if (cstr) copy(cstr, strlen(cstr));
   d6318:	460d      	mov	r5, r1
   d631a:	b139      	cbz	r1, d632c <_ZN6StringC1EPK19__FlashStringHelper+0x22>
   d631c:	4608      	mov	r0, r1
   d631e:	f002 fc05 	bl	d8b2c <strlen>
   d6322:	4629      	mov	r1, r5
   d6324:	4602      	mov	r2, r0
   d6326:	4620      	mov	r0, r4
   d6328:	f7ff ffd7 	bl	d62da <_ZN6String4copyEPKcj>
}
   d632c:	4620      	mov	r0, r4
   d632e:	bd38      	pop	{r3, r4, r5, pc}

000d6330 <_ZN6StringaSERKS_>:
}
#endif

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
   d6330:	4288      	cmp	r0, r1
	rhs.len = 0;
}
#endif

String & String::operator = (const String &rhs)
{
   d6332:	b510      	push	{r4, lr}
   d6334:	460b      	mov	r3, r1
   d6336:	4604      	mov	r4, r0
	if (this == &rhs) return *this;
   d6338:	d007      	beq.n	d634a <_ZN6StringaSERKS_+0x1a>

	if (rhs.buffer) copy(rhs.buffer, rhs.len);
   d633a:	6809      	ldr	r1, [r1, #0]
   d633c:	b119      	cbz	r1, d6346 <_ZN6StringaSERKS_+0x16>
   d633e:	689a      	ldr	r2, [r3, #8]
   d6340:	f7ff ffcb 	bl	d62da <_ZN6String4copyEPKcj>
   d6344:	e001      	b.n	d634a <_ZN6StringaSERKS_+0x1a>
	else invalidate();
   d6346:	f7ff ffa0 	bl	d628a <_ZN6String10invalidateEv>

	return *this;
}
   d634a:	4620      	mov	r0, r4
   d634c:	bd10      	pop	{r4, pc}

000d634e <_ZN6StringC1ERKS_>:
{
	init();
	if (cstr) copy(cstr, length);
}

String::String(const String &value)
   d634e:	b510      	push	{r4, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
   d6350:	2300      	movs	r3, #0
{
	init();
	if (cstr) copy(cstr, length);
}

String::String(const String &value)
   d6352:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
   d6354:	6003      	str	r3, [r0, #0]
	capacity = 0;
   d6356:	6043      	str	r3, [r0, #4]
	len = 0;
   d6358:	6083      	str	r3, [r0, #8]
	flags = 0;
   d635a:	7303      	strb	r3, [r0, #12]
}

String::String(const String &value)
{
	init();
	*this = value;
   d635c:	f7ff ffe8 	bl	d6330 <_ZN6StringaSERKS_>
}
   d6360:	4620      	mov	r0, r4
   d6362:	bd10      	pop	{r4, pc}

000d6364 <_ZN6String6concatEPKcj>:
{
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
   d6364:	b570      	push	{r4, r5, r6, lr}
   d6366:	4604      	mov	r4, r0
	unsigned int newlen = len + length;
	if (!cstr) return 0;
   d6368:	460e      	mov	r6, r1
   d636a:	b909      	cbnz	r1, d6370 <_ZN6String6concatEPKcj+0xc>
   d636c:	2000      	movs	r0, #0
   d636e:	bd70      	pop	{r4, r5, r6, pc}
	if (length == 0) return 1;
   d6370:	b16a      	cbz	r2, d638e <_ZN6String6concatEPKcj+0x2a>
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
   d6372:	6883      	ldr	r3, [r0, #8]
   d6374:	18d5      	adds	r5, r2, r3
	if (!cstr) return 0;
	if (length == 0) return 1;
	if (!reserve(newlen)) return 0;
   d6376:	4629      	mov	r1, r5
   d6378:	f7ff ff9e 	bl	d62b8 <_ZN6String7reserveEj>
   d637c:	2800      	cmp	r0, #0
   d637e:	d0f5      	beq.n	d636c <_ZN6String6concatEPKcj+0x8>
	strcpy(buffer + len, cstr);
   d6380:	6820      	ldr	r0, [r4, #0]
   d6382:	68a3      	ldr	r3, [r4, #8]
   d6384:	4631      	mov	r1, r6
   d6386:	4418      	add	r0, r3
   d6388:	f001 feb4 	bl	d80f4 <strcpy>
	len = newlen;
   d638c:	60a5      	str	r5, [r4, #8]

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
	if (!cstr) return 0;
	if (length == 0) return 1;
   d638e:	2001      	movs	r0, #1
	if (!reserve(newlen)) return 0;
	strcpy(buffer + len, cstr);
	len = newlen;
	return 1;
}
   d6390:	bd70      	pop	{r4, r5, r6, pc}

000d6392 <_ZN21StringPrintableHelper5writeEPKhj>:

    StringPrintableHelper(String& s_) : s(s_) {
        s.reserve(20);
    }

    virtual size_t write(const uint8_t *buffer, size_t size) override
   d6392:	b538      	push	{r3, r4, r5, lr}
   d6394:	4604      	mov	r4, r0
    {
        unsigned len = s.length();
   d6396:	6880      	ldr	r0, [r0, #8]
   d6398:	6885      	ldr	r5, [r0, #8]
        s.concat((const char*)buffer, size);
   d639a:	f7ff ffe3 	bl	d6364 <_ZN6String6concatEPKcj>
   d639e:	68a3      	ldr	r3, [r4, #8]
        return s.length()-len;
   d63a0:	6898      	ldr	r0, [r3, #8]
    }
   d63a2:	1b40      	subs	r0, r0, r5
   d63a4:	bd38      	pop	{r3, r4, r5, pc}

000d63a6 <_ZN6String6concatEc>:
unsigned char String::concat(const __FlashStringHelper * str) {
	return concat(reinterpret_cast<const char*>(str));
}

unsigned char String::concat(char c)
{
   d63a6:	b507      	push	{r0, r1, r2, lr}
	char buf[2];
	buf[0] = c;
	buf[1] = 0;
   d63a8:	2300      	movs	r3, #0
}

unsigned char String::concat(char c)
{
	char buf[2];
	buf[0] = c;
   d63aa:	f88d 1004 	strb.w	r1, [sp, #4]
	buf[1] = 0;
	return concat(buf, 1);
   d63ae:	2201      	movs	r2, #1
   d63b0:	a901      	add	r1, sp, #4

unsigned char String::concat(char c)
{
	char buf[2];
	buf[0] = c;
	buf[1] = 0;
   d63b2:	f88d 3005 	strb.w	r3, [sp, #5]
	return concat(buf, 1);
   d63b6:	f7ff ffd5 	bl	d6364 <_ZN6String6concatEPKcj>
}
   d63ba:	b003      	add	sp, #12
   d63bc:	f85d fb04 	ldr.w	pc, [sp], #4

000d63c0 <_ZN21StringPrintableHelper5writeEh>:
        unsigned len = s.length();
        s.concat((const char*)buffer, size);
        return s.length()-len;
    }

    virtual size_t write(uint8_t c) override
   d63c0:	b508      	push	{r3, lr}
    {
        return s.concat((char)c);
   d63c2:	6880      	ldr	r0, [r0, #8]
   d63c4:	f7ff ffef 	bl	d63a6 <_ZN6String6concatEc>
    }
   d63c8:	bd08      	pop	{r3, pc}

000d63ca <_ZNK6String16equalsIgnoreCaseERKS_>:
	return compareTo(rhs) >= 0;
}

unsigned char String::equalsIgnoreCase( const String &s2 ) const
{
	if (this == &s2) return 1;
   d63ca:	4288      	cmp	r0, r1
{
	return compareTo(rhs) >= 0;
}

unsigned char String::equalsIgnoreCase( const String &s2 ) const
{
   d63cc:	b570      	push	{r4, r5, r6, lr}
	if (this == &s2) return 1;
   d63ce:	d015      	beq.n	d63fc <_ZNK6String16equalsIgnoreCaseERKS_+0x32>
	if (len != s2.len) return 0;
   d63d0:	6883      	ldr	r3, [r0, #8]
   d63d2:	688a      	ldr	r2, [r1, #8]
   d63d4:	4293      	cmp	r3, r2
   d63d6:	d10f      	bne.n	d63f8 <_ZNK6String16equalsIgnoreCaseERKS_+0x2e>
	if (len == 0) return 1;
   d63d8:	b183      	cbz	r3, d63fc <_ZNK6String16equalsIgnoreCaseERKS_+0x32>
   d63da:	6804      	ldr	r4, [r0, #0]
	const char *p1 = buffer;
	const char *p2 = s2.buffer;
   d63dc:	680d      	ldr	r5, [r1, #0]
   d63de:	3c01      	subs	r4, #1
	while (*p1) {
   d63e0:	f814 0f01 	ldrb.w	r0, [r4, #1]!
   d63e4:	b150      	cbz	r0, d63fc <_ZNK6String16equalsIgnoreCaseERKS_+0x32>
		if (tolower(*p1++) != tolower(*p2++)) return 0;
   d63e6:	f002 fcf9 	bl	d8ddc <tolower>
   d63ea:	4606      	mov	r6, r0
   d63ec:	f815 0b01 	ldrb.w	r0, [r5], #1
   d63f0:	f002 fcf4 	bl	d8ddc <tolower>
   d63f4:	4286      	cmp	r6, r0
   d63f6:	d0f3      	beq.n	d63e0 <_ZNK6String16equalsIgnoreCaseERKS_+0x16>
}

unsigned char String::equalsIgnoreCase( const String &s2 ) const
{
	if (this == &s2) return 1;
	if (len != s2.len) return 0;
   d63f8:	2000      	movs	r0, #0
   d63fa:	bd70      	pop	{r4, r5, r6, pc}
	return compareTo(rhs) >= 0;
}

unsigned char String::equalsIgnoreCase( const String &s2 ) const
{
	if (this == &s2) return 1;
   d63fc:	2001      	movs	r0, #1
	const char *p2 = s2.buffer;
	while (*p1) {
		if (tolower(*p1++) != tolower(*p2++)) return 0;
	}
	return 1;
}
   d63fe:	bd70      	pop	{r4, r5, r6, pc}

000d6400 <_ZN6StringC1ERK9Printable>:
    {
        return s.concat((char)c);
    }
};

String::String(const Printable& printable)
   d6400:	b530      	push	{r4, r5, lr}
   d6402:	b085      	sub	sp, #20
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
   d6404:	2300      	movs	r3, #0
    {
        return s.concat((char)c);
    }
};

String::String(const Printable& printable)
   d6406:	460d      	mov	r5, r1
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
   d6408:	9302      	str	r3, [sp, #8]
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
   d640a:	6003      	str	r3, [r0, #0]
	capacity = 0;
   d640c:	6043      	str	r3, [r0, #4]
	len = 0;
   d640e:	6083      	str	r3, [r0, #8]
	flags = 0;
   d6410:	7303      	strb	r3, [r0, #12]
    String& s;

public:

    StringPrintableHelper(String& s_) : s(s_) {
        s.reserve(20);
   d6412:	2114      	movs	r1, #20
{
    String& s;

public:

    StringPrintableHelper(String& s_) : s(s_) {
   d6414:	4b06      	ldr	r3, [pc, #24]	; (d6430 <_ZN6StringC1ERK9Printable+0x30>)
   d6416:	9301      	str	r3, [sp, #4]
    {
        return s.concat((char)c);
    }
};

String::String(const Printable& printable)
   d6418:	4604      	mov	r4, r0
{
    String& s;

public:

    StringPrintableHelper(String& s_) : s(s_) {
   d641a:	9003      	str	r0, [sp, #12]
        s.reserve(20);
   d641c:	f7ff ff4c 	bl	d62b8 <_ZN6String7reserveEj>

String::String(const Printable& printable)
{
    init();
    StringPrintableHelper help(*this);
    printable.printTo(help);
   d6420:	682b      	ldr	r3, [r5, #0]
   d6422:	a901      	add	r1, sp, #4
   d6424:	681b      	ldr	r3, [r3, #0]
   d6426:	4628      	mov	r0, r5
   d6428:	4798      	blx	r3
}
   d642a:	4620      	mov	r0, r4
   d642c:	b005      	add	sp, #20
   d642e:	bd30      	pop	{r4, r5, pc}
   d6430:	000da5d4 	.word	0x000da5d4

000d6434 <_ZN14RecursiveMutexD1Ev>:
    RecursiveMutex() : handle_(nullptr)
    {
        os_mutex_recursive_create(&handle_);
    }

    ~RecursiveMutex() {
   d6434:	b510      	push	{r4, lr}
   d6436:	4604      	mov	r4, r0
        dispose();
    }

    void dispose()
    {
        if (handle_) {
   d6438:	6800      	ldr	r0, [r0, #0]
   d643a:	b108      	cbz	r0, d6440 <_ZN14RecursiveMutexD1Ev+0xc>
            os_mutex_recursive_destroy(handle_);
   d643c:	f7ff fc4e 	bl	d5cdc <os_mutex_recursive_destroy>
        os_mutex_recursive_create(&handle_);
    }

    ~RecursiveMutex() {
        dispose();
    }
   d6440:	4620      	mov	r0, r4
   d6442:	bd10      	pop	{r4, pc}

000d6444 <_GLOBAL__sub_I__ZN8particle3ble13WiringBleLock6mutex_E>:
BleCharacteristic BleLocalDevice::addCharacteristic(const String& desc, EnumFlags<BleCharacteristicProperty> properties, BleOnDataReceivedCallback callback, void* context) {
    WiringBleLock lk;
    return addCharacteristic(desc.c_str(), properties, callback, context);
}

} /* namespace particle */
   d6444:	b510      	push	{r4, lr}
    /**
     * Creates a shared mutex.
     */
    RecursiveMutex(os_mutex_recursive_t handle) : handle_(handle) {}

    RecursiveMutex() : handle_(nullptr)
   d6446:	4c06      	ldr	r4, [pc, #24]	; (d6460 <_GLOBAL__sub_I__ZN8particle3ble13WiringBleLock6mutex_E+0x1c>)
   d6448:	2300      	movs	r3, #0
    {
        os_mutex_recursive_create(&handle_);
   d644a:	4620      	mov	r0, r4
    /**
     * Creates a shared mutex.
     */
    RecursiveMutex(os_mutex_recursive_t handle) : handle_(handle) {}

    RecursiveMutex() : handle_(nullptr)
   d644c:	6023      	str	r3, [r4, #0]
    {
        os_mutex_recursive_create(&handle_);
   d644e:	f7ff fc3d 	bl	d5ccc <os_mutex_recursive_create>
private:
    bool locked_;
    static RecursiveMutex mutex_;
};

RecursiveMutex WiringBleLock::mutex_;
   d6452:	4620      	mov	r0, r4
   d6454:	4a03      	ldr	r2, [pc, #12]	; (d6464 <_GLOBAL__sub_I__ZN8particle3ble13WiringBleLock6mutex_E+0x20>)
   d6456:	4904      	ldr	r1, [pc, #16]	; (d6468 <_GLOBAL__sub_I__ZN8particle3ble13WiringBleLock6mutex_E+0x24>)
BleCharacteristic BleLocalDevice::addCharacteristic(const String& desc, EnumFlags<BleCharacteristicProperty> properties, BleOnDataReceivedCallback callback, void* context) {
    WiringBleLock lk;
    return addCharacteristic(desc.c_str(), properties, callback, context);
}

} /* namespace particle */
   d6458:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
private:
    bool locked_;
    static RecursiveMutex mutex_;
};

RecursiveMutex WiringBleLock::mutex_;
   d645c:	f001 bb46 	b.w	d7aec <__aeabi_atexit>
   d6460:	2003e2ac 	.word	0x2003e2ac
   d6464:	20034a40 	.word	0x20034a40
   d6468:	000d6435 	.word	0x000d6435

000d646c <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
   d646c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   d646e:	4606      	mov	r6, r0
   d6470:	460d      	mov	r5, r1
   d6472:	188f      	adds	r7, r1, r2
  size_t n = 0;
   d6474:	2400      	movs	r4, #0
  while (size--) {
   d6476:	42bd      	cmp	r5, r7
   d6478:	d00c      	beq.n	d6494 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
   d647a:	6833      	ldr	r3, [r6, #0]
   d647c:	f815 1b01 	ldrb.w	r1, [r5], #1
   d6480:	689b      	ldr	r3, [r3, #8]
   d6482:	4630      	mov	r0, r6
   d6484:	4798      	blx	r3
     if (chunk>=0)
   d6486:	2800      	cmp	r0, #0
   d6488:	db01      	blt.n	d648e <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
   d648a:	4404      	add	r4, r0

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
   d648c:	e7f3      	b.n	d6476 <_ZN5Print5writeEPKhj+0xa>
     int chunk = write(*buffer++);
   d648e:	2c00      	cmp	r4, #0
   d6490:	bf08      	it	eq
   d6492:	4604      	moveq	r4, r0
             n = chunk;
         break;
     }
  }
  return n;
}
   d6494:	4620      	mov	r0, r4
   d6496:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000d6498 <_ZN5Print5printEPKc>:
   d6498:	b508      	push	{r3, lr}
   d649a:	f7ff f8df 	bl	d565c <_ZN5Print5writeEPKc>
   d649e:	bd08      	pop	{r3, pc}

000d64a0 <_ZN5Print5printEc>:
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
   d64a0:	6803      	ldr	r3, [r0, #0]
   d64a2:	689b      	ldr	r3, [r3, #8]
   d64a4:	4718      	bx	r3

000d64a6 <_ZN5Print11printNumberEmh>:
  return println(reinterpret_cast<const char*>(str));
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
   d64a6:	b530      	push	{r4, r5, lr}
   d64a8:	b08b      	sub	sp, #44	; 0x2c
   d64aa:	460b      	mov	r3, r1
  char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
   d64ac:	2100      	movs	r1, #0
   d64ae:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
   d64b2:	2a01      	cmp	r2, #1
   d64b4:	bf98      	it	ls
   d64b6:	220a      	movls	r2, #10
   d64b8:	f10d 0423 	add.w	r4, sp, #35	; 0x23

  do {
   decltype(n) m = n;
   n /= base;
   d64bc:	fbb3 f5f2 	udiv	r5, r3, r2
   char c = m - base * n;
   d64c0:	fb05 3312 	mls	r3, r5, r2, r3
   d64c4:	f003 03ff 	and.w	r3, r3, #255	; 0xff
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
   d64c8:	2b09      	cmp	r3, #9
   d64ca:	bf94      	ite	ls
   d64cc:	3330      	addls	r3, #48	; 0x30
   d64ce:	3337      	addhi	r3, #55	; 0x37
   d64d0:	b2db      	uxtb	r3, r3
   d64d2:	4621      	mov	r1, r4
   d64d4:	f804 3901 	strb.w	r3, [r4], #-1
   d64d8:	462b      	mov	r3, r5
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
   d64da:	2d00      	cmp	r5, #0
   d64dc:	d1ee      	bne.n	d64bc <_ZN5Print11printNumberEmh+0x16>
   n /= base;
   char c = m - base * n;
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
   d64de:	f7ff f8bd 	bl	d565c <_ZN5Print5writeEPKc>
}
   d64e2:	b00b      	add	sp, #44	; 0x2c
   d64e4:	bd30      	pop	{r4, r5, pc}

000d64e6 <_ZN6Stream9timedReadEv>:
#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field

// private method to read stream with timeout
int Stream::timedRead()
{
   d64e6:	b510      	push	{r4, lr}
   d64e8:	4604      	mov	r4, r0

#ifdef __cplusplus
extern "C" {
#endif

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
   d64ea:	f7ff fbb7 	bl	d5c5c <HAL_Timer_Get_Milli_Seconds>
  int c;
  _startMillis = millis();
   d64ee:	60e0      	str	r0, [r4, #12]
  do {
    c = read();
   d64f0:	6823      	ldr	r3, [r4, #0]
   d64f2:	4620      	mov	r0, r4
   d64f4:	695b      	ldr	r3, [r3, #20]
   d64f6:	4798      	blx	r3
    if (c >= 0) return c;
   d64f8:	2800      	cmp	r0, #0
   d64fa:	da08      	bge.n	d650e <_ZN6Stream9timedReadEv+0x28>
   d64fc:	f7ff fbae 	bl	d5c5c <HAL_Timer_Get_Milli_Seconds>
// private method to read stream with timeout
int Stream::timedRead()
{
  int c;
  _startMillis = millis();
  do {
   d6500:	68e3      	ldr	r3, [r4, #12]
   d6502:	1ac0      	subs	r0, r0, r3
   d6504:	68a3      	ldr	r3, [r4, #8]
   d6506:	4298      	cmp	r0, r3
   d6508:	d3f2      	bcc.n	d64f0 <_ZN6Stream9timedReadEv+0xa>
    c = read();
    if (c >= 0) return c;
  } while(millis() - _startMillis < _timeout);
  return -1;     // -1 indicates timeout
   d650a:	f04f 30ff 	mov.w	r0, #4294967295
}
   d650e:	bd10      	pop	{r4, pc}

000d6510 <_ZN6Stream10setTimeoutEm>:
// Public Methods
//////////////////////////////////////////////////////////////

void Stream::setTimeout(system_tick_t timeout)  // sets the maximum number of milliseconds to wait
{
  _timeout = timeout;
   d6510:	6081      	str	r1, [r0, #8]
   d6512:	4770      	bx	lr

000d6514 <_ZN6Stream9readBytesEPcj>:
// terminates if length characters have been read, or timeout (see setTimeout)
// returns the number of characters placed in the buffer
// the buffer is NOT null terminated.
//
size_t Stream::readBytes(char *buffer, size_t length)
{
   d6514:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   d6518:	4680      	mov	r8, r0
   d651a:	460d      	mov	r5, r1
   d651c:	188f      	adds	r7, r1, r2
   d651e:	460c      	mov	r4, r1
  size_t count = 0;
  while (count < length) {
   d6520:	42bc      	cmp	r4, r7
   d6522:	eba4 0605 	sub.w	r6, r4, r5
   d6526:	d007      	beq.n	d6538 <_ZN6Stream9readBytesEPcj+0x24>
    int c = timedRead();
   d6528:	4640      	mov	r0, r8
   d652a:	f7ff ffdc 	bl	d64e6 <_ZN6Stream9timedReadEv>
    if (c < 0) break;
   d652e:	2800      	cmp	r0, #0
   d6530:	db02      	blt.n	d6538 <_ZN6Stream9readBytesEPcj+0x24>
    *buffer++ = (char)c;
   d6532:	f804 0b01 	strb.w	r0, [r4], #1
// the buffer is NOT null terminated.
//
size_t Stream::readBytes(char *buffer, size_t length)
{
  size_t count = 0;
  while (count < length) {
   d6536:	e7f3      	b.n	d6520 <_ZN6Stream9readBytesEPcj+0xc>
    if (c < 0) break;
    *buffer++ = (char)c;
    count++;
  }
  return count;
}
   d6538:	4630      	mov	r0, r6
   d653a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

000d6540 <_GLOBAL__sub_I__ZN5spark3LogE>:
    // This handler doesn't support direct logging
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
   d6540:	4b01      	ldr	r3, [pc, #4]	; (d6548 <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
   d6542:	4a02      	ldr	r2, [pc, #8]	; (d654c <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
   d6544:	601a      	str	r2, [r3, #0]
   d6546:	4770      	bx	lr
   d6548:	2003e2b0 	.word	0x2003e2b0
   d654c:	000da668 	.word	0x000da668

000d6550 <_ZN10CloudClass12syncTimeDoneEv.isra.1>:
    bool syncTimePending(void)
    {
        return connected() && spark_sync_time_pending(nullptr);
    }

    bool syncTimeDone(void)
   d6550:	b508      	push	{r3, lr}
    {
        return !spark_sync_time_pending(nullptr) || disconnected();
   d6552:	2000      	movs	r0, #0
   d6554:	f7ff fdb6 	bl	d60c4 <spark_sync_time_pending>
   d6558:	b128      	cbz	r0, d6566 <_ZN10CloudClass12syncTimeDoneEv.isra.1+0x16>
    static void sleep(Spark_Sleep_TypeDef sleepMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(sleepMode, seconds); }
    static void sleep(uint16_t wakeUpPin, InterruptMode edgeTriggerMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
   d655a:	f7ff fdab 	bl	d60b4 <spark_cloud_flag_connected>
        return connected() && spark_sync_time_pending(nullptr);
    }

    bool syncTimeDone(void)
    {
        return !spark_sync_time_pending(nullptr) || disconnected();
   d655e:	f080 0001 	eor.w	r0, r0, #1
   d6562:	b2c0      	uxtb	r0, r0
   d6564:	bd08      	pop	{r3, pc}
   d6566:	2001      	movs	r0, #1
    }
   d6568:	bd08      	pop	{r3, pc}
	...

000d656c <_ZN9TimeClass5localEv>:
    (void)isValid();
	return HAL_RTC_Get_UnixTime();
}

time_t TimeClass::local()
{
   d656c:	b508      	push	{r3, lr}
	return HAL_RTC_Get_UnixTime()+time_zone_cache+dst_current_cache;
   d656e:	f7ff fb7d 	bl	d5c6c <HAL_RTC_Get_UnixTime>
   d6572:	4b03      	ldr	r3, [pc, #12]	; (d6580 <_ZN9TimeClass5localEv+0x14>)
   d6574:	681b      	ldr	r3, [r3, #0]
   d6576:	4418      	add	r0, r3
   d6578:	4b02      	ldr	r3, [pc, #8]	; (d6584 <_ZN9TimeClass5localEv+0x18>)
   d657a:	681b      	ldr	r3, [r3, #0]
}
   d657c:	4418      	add	r0, r3
   d657e:	bd08      	pop	{r3, pc}
   d6580:	2003e2bc 	.word	0x2003e2bc
   d6584:	2003e2b8 	.word	0x2003e2b8

000d6588 <_ZN9TimeClass4zoneEf>:

/* set the time zone (+/-) offset from GMT */
void TimeClass::zone(float GMT_Offset)
{
	if(GMT_Offset < -12 || GMT_Offset > 14)
   d6588:	eefa 7a08 	vmov.f32	s15, #168	; 0xc1400000 -12.0
   d658c:	eeb4 0ae7 	vcmpe.f32	s0, s15
   d6590:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   d6594:	d40f      	bmi.n	d65b6 <_ZN9TimeClass4zoneEf+0x2e>
   d6596:	eef2 7a0c 	vmov.f32	s15, #44	; 0x41600000  14.0
   d659a:	eeb4 0ae7 	vcmpe.f32	s0, s15
   d659e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   d65a2:	dc08      	bgt.n	d65b6 <_ZN9TimeClass4zoneEf+0x2e>
	{
		return;
	}
	time_zone_cache = GMT_Offset * 3600;
   d65a4:	eddf 7a04 	vldr	s15, [pc, #16]	; d65b8 <_ZN9TimeClass4zoneEf+0x30>
   d65a8:	4b04      	ldr	r3, [pc, #16]	; (d65bc <_ZN9TimeClass4zoneEf+0x34>)
   d65aa:	ee20 0a27 	vmul.f32	s0, s0, s15
   d65ae:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   d65b2:	ed83 0a00 	vstr	s0, [r3]
   d65b6:	4770      	bx	lr
   d65b8:	45610000 	.word	0x45610000
   d65bc:	2003e2bc 	.word	0x2003e2bc

000d65c0 <_ZN9TimeClass7timeStrEl>:
    system_notify_time_changed((uint32_t)time_changed_manually, nullptr, nullptr);
}

/* return string representation for the given time */
String TimeClass::timeStr(time_t t)
{
   d65c0:	b537      	push	{r0, r1, r2, r4, r5, lr}
	t += time_zone_cache;
    t += dst_current_cache;
   d65c2:	4b0e      	ldr	r3, [pc, #56]	; (d65fc <_ZN9TimeClass7timeStrEl+0x3c>)
   d65c4:	681b      	ldr	r3, [r3, #0]
   d65c6:	4419      	add	r1, r3
   d65c8:	4b0d      	ldr	r3, [pc, #52]	; (d6600 <_ZN9TimeClass7timeStrEl+0x40>)
   d65ca:	681b      	ldr	r3, [r3, #0]
    system_notify_time_changed((uint32_t)time_changed_manually, nullptr, nullptr);
}

/* return string representation for the given time */
String TimeClass::timeStr(time_t t)
{
   d65cc:	4604      	mov	r4, r0
	t += time_zone_cache;
    t += dst_current_cache;
   d65ce:	a802      	add	r0, sp, #8
   d65d0:	4419      	add	r1, r3
   d65d2:	f840 1d04 	str.w	r1, [r0, #-4]!
	tm* calendar_time = localtime(&t);
   d65d6:	f001 fc41 	bl	d7e5c <localtime>
        char* ascstr = asctime(calendar_time);
   d65da:	f001 fbf1 	bl	d7dc0 <asctime>
   d65de:	4605      	mov	r5, r0
        int len = strlen(ascstr);
   d65e0:	f002 faa4 	bl	d8b2c <strlen>
        ascstr[len-1] = 0; // remove final newline
   d65e4:	4428      	add	r0, r5
   d65e6:	2300      	movs	r3, #0
   d65e8:	f800 3c01 	strb.w	r3, [r0, #-1]
	return String(ascstr);
   d65ec:	4629      	mov	r1, r5
   d65ee:	4620      	mov	r0, r4
   d65f0:	f7ff fe8b 	bl	d630a <_ZN6StringC1EPK19__FlashStringHelper>
}
   d65f4:	4620      	mov	r0, r4
   d65f6:	b003      	add	sp, #12
   d65f8:	bd30      	pop	{r4, r5, pc}
   d65fa:	bf00      	nop
   d65fc:	2003e2bc 	.word	0x2003e2bc
   d6600:	2003e2b8 	.word	0x2003e2b8

000d6604 <_ZN9TimeClass14timeFormatImplEP2tmPKci>:
    tm* calendar_time = localtime(&t);
    return timeFormatImpl(calendar_time, format_spec, time_zone_cache + dst_current_cache);
}

String TimeClass::timeFormatImpl(tm* calendar_time, const char* format, int time_zone)
{
   d6604:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   d6608:	b0a4      	sub	sp, #144	; 0x90
    char format_str[64];
    // only copy up to n-1 to dest if no null terminator found
    strncpy(format_str, format, sizeof(format_str) - 1); // Flawfinder: ignore (ch42318)
   d660a:	ac14      	add	r4, sp, #80	; 0x50
    tm* calendar_time = localtime(&t);
    return timeFormatImpl(calendar_time, format_spec, time_zone_cache + dst_current_cache);
}

String TimeClass::timeFormatImpl(tm* calendar_time, const char* format, int time_zone)
{
   d660c:	4607      	mov	r7, r0
   d660e:	4689      	mov	r9, r1
    char format_str[64];
    // only copy up to n-1 to dest if no null terminator found
    strncpy(format_str, format, sizeof(format_str) - 1); // Flawfinder: ignore (ch42318)
   d6610:	4620      	mov	r0, r4
    tm* calendar_time = localtime(&t);
    return timeFormatImpl(calendar_time, format_spec, time_zone_cache + dst_current_cache);
}

String TimeClass::timeFormatImpl(tm* calendar_time, const char* format, int time_zone)
{
   d6612:	4611      	mov	r1, r2
    char format_str[64];
    // only copy up to n-1 to dest if no null terminator found
    strncpy(format_str, format, sizeof(format_str) - 1); // Flawfinder: ignore (ch42318)
   d6614:	223f      	movs	r2, #63	; 0x3f
    tm* calendar_time = localtime(&t);
    return timeFormatImpl(calendar_time, format_spec, time_zone_cache + dst_current_cache);
}

String TimeClass::timeFormatImpl(tm* calendar_time, const char* format, int time_zone)
{
   d6616:	461d      	mov	r5, r3
    char format_str[64];
    // only copy up to n-1 to dest if no null terminator found
    strncpy(format_str, format, sizeof(format_str) - 1); // Flawfinder: ignore (ch42318)
   d6618:	f002 faa5 	bl	d8b66 <strncpy>
    format_str[sizeof(format_str) - 1] = '\0'; // ensure null termination
   d661c:	2300      	movs	r3, #0
    size_t len = strlen(format_str); // Flawfinder: ignore (ch42318)
   d661e:	4620      	mov	r0, r4
String TimeClass::timeFormatImpl(tm* calendar_time, const char* format, int time_zone)
{
    char format_str[64];
    // only copy up to n-1 to dest if no null terminator found
    strncpy(format_str, format, sizeof(format_str) - 1); // Flawfinder: ignore (ch42318)
    format_str[sizeof(format_str) - 1] = '\0'; // ensure null termination
   d6620:	f88d 308f 	strb.w	r3, [sp, #143]	; 0x8f
    size_t len = strlen(format_str); // Flawfinder: ignore (ch42318)
   d6624:	f002 fa82 	bl	d8b2c <strlen>
   d6628:	4680      	mov	r8, r0

    char time_zone_str[16];
    // while we are not using stdlib for managing the timezone, we have to do this manually
    if (!time_zone) {
   d662a:	b925      	cbnz	r5, d6636 <_ZN9TimeClass14timeFormatImplEP2tmPKci+0x32>
        strcpy(time_zone_str, "Z");
   d662c:	4924      	ldr	r1, [pc, #144]	; (d66c0 <_ZN9TimeClass14timeFormatImplEP2tmPKci+0xbc>)
   d662e:	a803      	add	r0, sp, #12
   d6630:	f001 fd60 	bl	d80f4 <strcpy>
   d6634:	e013      	b.n	d665e <_ZN9TimeClass14timeFormatImplEP2tmPKci+0x5a>
    }
    else {
        snprintf(time_zone_str, sizeof(time_zone_str), "%+03d:%02u", time_zone/3600, abs(time_zone/60)%60);
   d6636:	213c      	movs	r1, #60	; 0x3c
   d6638:	fb95 f2f1 	sdiv	r2, r5, r1
   d663c:	2a00      	cmp	r2, #0
   d663e:	bfb8      	it	lt
   d6640:	4252      	neglt	r2, r2
   d6642:	fb92 f3f1 	sdiv	r3, r2, r1
   d6646:	fb01 2213 	mls	r2, r1, r3, r2
   d664a:	9200      	str	r2, [sp, #0]
   d664c:	f44f 6361 	mov.w	r3, #3600	; 0xe10
   d6650:	4a1c      	ldr	r2, [pc, #112]	; (d66c4 <_ZN9TimeClass14timeFormatImplEP2tmPKci+0xc0>)
   d6652:	fb95 f3f3 	sdiv	r3, r5, r3
   d6656:	2110      	movs	r1, #16
   d6658:	a803      	add	r0, sp, #12
   d665a:	f7ff fd73 	bl	d6144 <snprintf>
    tm* calendar_time = localtime(&t);
    return timeFormatImpl(calendar_time, format_spec, time_zone_cache + dst_current_cache);
}

String TimeClass::timeFormatImpl(tm* calendar_time, const char* format, int time_zone)
{
   d665e:	4625      	mov	r5, r4
   d6660:	1b2e      	subs	r6, r5, r4
    else {
        snprintf(time_zone_str, sizeof(time_zone_str), "%+03d:%02u", time_zone/3600, abs(time_zone/60)%60);
    }

    // replace %z with the timezone
    for (size_t i=0; i<len-1; i++)
   d6662:	f108 3aff 	add.w	sl, r8, #4294967295
   d6666:	45b2      	cmp	sl, r6
   d6668:	d91b      	bls.n	d66a2 <_ZN9TimeClass14timeFormatImplEP2tmPKci+0x9e>
    {
        if (format_str[i]=='%' && format_str[i+1]=='z')
   d666a:	782b      	ldrb	r3, [r5, #0]
   d666c:	2b25      	cmp	r3, #37	; 0x25
   d666e:	d116      	bne.n	d669e <_ZN9TimeClass14timeFormatImplEP2tmPKci+0x9a>
   d6670:	786b      	ldrb	r3, [r5, #1]
   d6672:	2b7a      	cmp	r3, #122	; 0x7a
   d6674:	d113      	bne.n	d669e <_ZN9TimeClass14timeFormatImplEP2tmPKci+0x9a>
        {
            size_t tzlen = strlen(time_zone_str);
   d6676:	a803      	add	r0, sp, #12
   d6678:	f002 fa58 	bl	d8b2c <strlen>
   d667c:	4680      	mov	r8, r0
            memcpy(format_str+i+tzlen, format_str+i+2, len-i-1);    // +1 include the 0 char
   d667e:	4430      	add	r0, r6
   d6680:	ebc6 020a 	rsb	r2, r6, sl
   d6684:	1ca9      	adds	r1, r5, #2
   d6686:	4420      	add	r0, r4
   d6688:	f001 fce0 	bl	d804c <memcpy>
            memcpy(format_str+i, time_zone_str, tzlen);
   d668c:	4642      	mov	r2, r8
   d668e:	a903      	add	r1, sp, #12
   d6690:	4628      	mov	r0, r5
   d6692:	f001 fcdb 	bl	d804c <memcpy>
            len = strlen(format_str);
   d6696:	4620      	mov	r0, r4
   d6698:	f002 fa48 	bl	d8b2c <strlen>
   d669c:	4680      	mov	r8, r0
   d669e:	3501      	adds	r5, #1
    else {
        snprintf(time_zone_str, sizeof(time_zone_str), "%+03d:%02u", time_zone/3600, abs(time_zone/60)%60);
    }

    // replace %z with the timezone
    for (size_t i=0; i<len-1; i++)
   d66a0:	e7de      	b.n	d6660 <_ZN9TimeClass14timeFormatImplEP2tmPKci+0x5c>
            len = strlen(format_str);
        }
    }

    char buf[50];
    strftime(buf, 50, format_str, calendar_time);
   d66a2:	464b      	mov	r3, r9
   d66a4:	4622      	mov	r2, r4
   d66a6:	2132      	movs	r1, #50	; 0x32
   d66a8:	a807      	add	r0, sp, #28
   d66aa:	f001 fd8b 	bl	d81c4 <strftime>
    return String(buf);
   d66ae:	a907      	add	r1, sp, #28
   d66b0:	4638      	mov	r0, r7
   d66b2:	f7ff fe2a 	bl	d630a <_ZN6StringC1EPK19__FlashStringHelper>
}
   d66b6:	4638      	mov	r0, r7
   d66b8:	b024      	add	sp, #144	; 0x90
   d66ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   d66be:	bf00      	nop
   d66c0:	000dae2d 	.word	0x000dae2d
   d66c4:	000da6d0 	.word	0x000da6d0

000d66c8 <_ZN9TimeClass6formatElPKc>:
        ascstr[len-1] = 0; // remove final newline
	return String(ascstr);
}

String TimeClass::format(time_t t, const char* format_spec)
{
   d66c8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   d66ca:	4605      	mov	r5, r0
   d66cc:	9201      	str	r2, [sp, #4]
    if (format_spec==NULL)
   d66ce:	461c      	mov	r4, r3
   d66d0:	b913      	cbnz	r3, d66d8 <_ZN9TimeClass6formatElPKc+0x10>
        format_spec = this->format_spec;
   d66d2:	4b12      	ldr	r3, [pc, #72]	; (d671c <_ZN9TimeClass6formatElPKc+0x54>)
   d66d4:	681c      	ldr	r4, [r3, #0]

    if (!format_spec || !strcmp(format_spec,TIME_FORMAT_DEFAULT)) {
   d66d6:	b12c      	cbz	r4, d66e4 <_ZN9TimeClass6formatElPKc+0x1c>
   d66d8:	4b11      	ldr	r3, [pc, #68]	; (d6720 <_ZN9TimeClass6formatElPKc+0x58>)
   d66da:	4620      	mov	r0, r4
   d66dc:	6819      	ldr	r1, [r3, #0]
   d66de:	f001 fcff 	bl	d80e0 <strcmp>
   d66e2:	b920      	cbnz	r0, d66ee <_ZN9TimeClass6formatElPKc+0x26>
        return timeStr(t);
   d66e4:	9901      	ldr	r1, [sp, #4]
   d66e6:	4628      	mov	r0, r5
   d66e8:	f7ff ff6a 	bl	d65c0 <_ZN9TimeClass7timeStrEl>
   d66ec:	e013      	b.n	d6716 <_ZN9TimeClass6formatElPKc+0x4e>
    }
    t += time_zone_cache;
   d66ee:	4f0d      	ldr	r7, [pc, #52]	; (d6724 <_ZN9TimeClass6formatElPKc+0x5c>)
    t += dst_current_cache;
   d66f0:	9a01      	ldr	r2, [sp, #4]
   d66f2:	683b      	ldr	r3, [r7, #0]
   d66f4:	4e0c      	ldr	r6, [pc, #48]	; (d6728 <_ZN9TimeClass6formatElPKc+0x60>)
   d66f6:	441a      	add	r2, r3
   d66f8:	6833      	ldr	r3, [r6, #0]
   d66fa:	a802      	add	r0, sp, #8
   d66fc:	4413      	add	r3, r2
   d66fe:	f840 3d04 	str.w	r3, [r0, #-4]!
    tm* calendar_time = localtime(&t);
   d6702:	f001 fbab 	bl	d7e5c <localtime>
    return timeFormatImpl(calendar_time, format_spec, time_zone_cache + dst_current_cache);
   d6706:	683a      	ldr	r2, [r7, #0]
   d6708:	6833      	ldr	r3, [r6, #0]
   d670a:	4601      	mov	r1, r0
   d670c:	4413      	add	r3, r2
   d670e:	4628      	mov	r0, r5
   d6710:	4622      	mov	r2, r4
   d6712:	f7ff ff77 	bl	d6604 <_ZN9TimeClass14timeFormatImplEP2tmPKci>
}
   d6716:	4628      	mov	r0, r5
   d6718:	b003      	add	sp, #12
   d671a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   d671c:	2003e2b4 	.word	0x2003e2b4
   d6720:	20034988 	.word	0x20034988
   d6724:	2003e2bc 	.word	0x2003e2bc
   d6728:	2003e2b8 	.word	0x2003e2b8

000d672c <_ZN9TimeClass7isValidEv>:
    strftime(buf, 50, format_str, calendar_time);
    return String(buf);
}

bool TimeClass::isValid()
{
   d672c:	b510      	push	{r4, lr}
    bool rtcstate = HAL_RTC_Time_Is_Valid(nullptr);
   d672e:	2000      	movs	r0, #0
   d6730:	f7ff faa4 	bl	d5c7c <HAL_RTC_Time_Is_Valid>
    if (rtcstate)
   d6734:	4604      	mov	r4, r0
   d6736:	b968      	cbnz	r0, d6754 <_ZN9TimeClass7isValidEv+0x28>
    }

    static System_Mode_TypeDef mode(void) {
        return system_mode();
   d6738:	f7ff fc18 	bl	d5f6c <system_mode>
        return rtcstate;
    if (System.mode() == AUTOMATIC && system_thread_get_state(nullptr) == spark::feature::DISABLED)
   d673c:	2801      	cmp	r0, #1
   d673e:	d10b      	bne.n	d6758 <_ZN9TimeClass7isValidEv+0x2c>
   d6740:	4620      	mov	r0, r4
   d6742:	f7ff fc2b 	bl	d5f9c <system_thread_get_state>
   d6746:	b938      	cbnz	r0, d6758 <_ZN9TimeClass7isValidEv+0x2c>
    {
        waitUntil(Particle.syncTimeDone);
   d6748:	f7ff ff02 	bl	d6550 <_ZN10CloudClass12syncTimeDoneEv.isra.1>


    static uint32_t freeMemory();

    template<typename Condition, typename While> static bool waitConditionWhile(Condition _condition, While _while) {
        while (_while() && !_condition()) {
   d674c:	b930      	cbnz	r0, d675c <_ZN9TimeClass7isValidEv+0x30>
            spark_process();
   d674e:	f7ff fca9 	bl	d60a4 <spark_process>
   d6752:	e7f9      	b.n	d6748 <_ZN9TimeClass7isValidEv+0x1c>

bool TimeClass::isValid()
{
    bool rtcstate = HAL_RTC_Time_Is_Valid(nullptr);
    if (rtcstate)
        return rtcstate;
   d6754:	2001      	movs	r0, #1
   d6756:	bd10      	pop	{r4, pc}
    if (System.mode() == AUTOMATIC && system_thread_get_state(nullptr) == spark::feature::DISABLED)
    {
        waitUntil(Particle.syncTimeDone);
        return HAL_RTC_Time_Is_Valid(nullptr);
    }
    return rtcstate;
   d6758:	2000      	movs	r0, #0
   d675a:	bd10      	pop	{r4, pc}
    bool rtcstate = HAL_RTC_Time_Is_Valid(nullptr);
    if (rtcstate)
        return rtcstate;
    if (System.mode() == AUTOMATIC && system_thread_get_state(nullptr) == spark::feature::DISABLED)
    {
        waitUntil(Particle.syncTimeDone);
   d675c:	f7ff fef8 	bl	d6550 <_ZN10CloudClass12syncTimeDoneEv.isra.1>
        return HAL_RTC_Time_Is_Valid(nullptr);
   d6760:	2000      	movs	r0, #0
   d6762:	f7ff fa8b 	bl	d5c7c <HAL_RTC_Time_Is_Valid>
   d6766:	3000      	adds	r0, #0
   d6768:	bf18      	it	ne
   d676a:	2001      	movne	r0, #1
    }
    return rtcstate;
}
   d676c:	bd10      	pop	{r4, pc}

000d676e <_ZN9TimeClass3nowEv>:
	return calendar_time_cache.tm_year;
}

/* return the current time as seconds since Jan 1 1970 */
time_t TimeClass::now()
{
   d676e:	b508      	push	{r3, lr}
    (void)isValid();
   d6770:	f7ff ffdc 	bl	d672c <_ZN9TimeClass7isValidEv>
	return HAL_RTC_Get_UnixTime();
}
   d6774:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

/* return the current time as seconds since Jan 1 1970 */
time_t TimeClass::now()
{
    (void)isValid();
	return HAL_RTC_Get_UnixTime();
   d6778:	f7ff ba78 	b.w	d5c6c <HAL_RTC_Get_UnixTime>

000d677c <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
   d677c:	4b02      	ldr	r3, [pc, #8]	; (d6788 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
   d677e:	681a      	ldr	r2, [r3, #0]
   d6780:	4b02      	ldr	r3, [pc, #8]	; (d678c <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
   d6782:	601a      	str	r2, [r3, #0]
   d6784:	4770      	bx	lr
   d6786:	bf00      	nop
   d6788:	20034988 	.word	0x20034988
   d678c:	2003e2b4 	.word	0x2003e2b4

000d6790 <delay>:
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
   d6790:	2100      	movs	r1, #0
   d6792:	f7ff bbfb 	b.w	d5f8c <system_delay_ms>

000d6796 <_ZN9TCPServer5writeEhm>:
    }

    return _client;
}

size_t TCPServer::write(uint8_t b, system_tick_t timeout) {
   d6796:	b537      	push	{r0, r1, r2, r4, r5, lr}
   d6798:	ac02      	add	r4, sp, #8
    return write(&b, sizeof(b), timeout);
   d679a:	6803      	ldr	r3, [r0, #0]
    }

    return _client;
}

size_t TCPServer::write(uint8_t b, system_tick_t timeout) {
   d679c:	f804 1d01 	strb.w	r1, [r4, #-1]!
    return write(&b, sizeof(b), timeout);
   d67a0:	699d      	ldr	r5, [r3, #24]
   d67a2:	4621      	mov	r1, r4
   d67a4:	4613      	mov	r3, r2
   d67a6:	2201      	movs	r2, #1
   d67a8:	47a8      	blx	r5
}
   d67aa:	b003      	add	sp, #12
   d67ac:	bd30      	pop	{r4, r5, pc}

000d67ae <_ZN9TCPServer5writeEh>:
    size_t ret = _client.write(buf, size, timeout);
    setWriteError(_client.getWriteError());
    return ret;
}

size_t TCPServer::write(uint8_t b) {
   d67ae:	b513      	push	{r0, r1, r4, lr}
   d67b0:	ab02      	add	r3, sp, #8
    return write(&b, 1);
   d67b2:	6802      	ldr	r2, [r0, #0]
    size_t ret = _client.write(buf, size, timeout);
    setWriteError(_client.getWriteError());
    return ret;
}

size_t TCPServer::write(uint8_t b) {
   d67b4:	f803 1d01 	strb.w	r1, [r3, #-1]!
    return write(&b, 1);
   d67b8:	68d4      	ldr	r4, [r2, #12]
   d67ba:	4619      	mov	r1, r3
   d67bc:	2201      	movs	r2, #1
   d67be:	47a0      	blx	r4
}
   d67c0:	b002      	add	sp, #8
   d67c2:	bd10      	pop	{r4, pc}

000d67c4 <_ZN9TCPServer5writeEPKhj>:

size_t TCPServer::write(const uint8_t *buffer, size_t size) {
   d67c4:	b410      	push	{r4}
    return write(buffer, size, SOCKET_WAIT_FOREVER);
   d67c6:	6803      	ldr	r3, [r0, #0]
   d67c8:	699c      	ldr	r4, [r3, #24]
   d67ca:	f04f 33ff 	mov.w	r3, #4294967295
   d67ce:	46a4      	mov	ip, r4
}
   d67d0:	f85d 4b04 	ldr.w	r4, [sp], #4
size_t TCPServer::write(uint8_t b) {
    return write(&b, 1);
}

size_t TCPServer::write(const uint8_t *buffer, size_t size) {
    return write(buffer, size, SOCKET_WAIT_FOREVER);
   d67d4:	4760      	bx	ip

000d67d6 <_ZN9TCPServer5writeEPKhjm>:

size_t TCPServer::write(uint8_t b, system_tick_t timeout) {
    return write(&b, sizeof(b), timeout);
}

size_t TCPServer::write(const uint8_t *buf, size_t size, system_tick_t timeout) {
   d67d6:	b510      	push	{r4, lr}
   d67d8:	4604      	mov	r4, r0

    size_t printNumber(unsigned long, uint8_t);
    size_t printNumber(unsigned long long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
   d67da:	2000      	movs	r0, #0
   d67dc:	61a0      	str	r0, [r4, #24]
    _client.clearWriteError();
    size_t ret = _client.write(buf, size, timeout);
   d67de:	f104 0014 	add.w	r0, r4, #20
   d67e2:	f000 fd89 	bl	d72f8 <_ZN9TCPClient5writeEPKhjm>
   d67e6:	69a3      	ldr	r3, [r4, #24]
   d67e8:	6063      	str	r3, [r4, #4]
    setWriteError(_client.getWriteError());
    return ret;
}
   d67ea:	bd10      	pop	{r4, pc}

000d67ec <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.4.constprop.12>:
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
   d67ec:	b510      	push	{r4, lr}
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
   d67ee:	6803      	ldr	r3, [r0, #0]
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
   d67f0:	4604      	mov	r4, r0
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
   d67f2:	689b      	ldr	r3, [r3, #8]
   d67f4:	4798      	blx	r3
          if (--_M_weak_count == 0)
   d67f6:	68a3      	ldr	r3, [r4, #8]
   d67f8:	3b01      	subs	r3, #1
   d67fa:	60a3      	str	r3, [r4, #8]
   d67fc:	b92b      	cbnz	r3, d680a <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.4.constprop.12+0x1e>
            _M_destroy();
   d67fe:	6823      	ldr	r3, [r4, #0]
   d6800:	4620      	mov	r0, r4
   d6802:	68db      	ldr	r3, [r3, #12]
        }
    }
   d6804:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
   d6808:	4718      	bx	r3
   d680a:	bd10      	pop	{r4, pc}

000d680c <_ZN15TCPServerClient8remoteIPEv>:
class TCPServerClient : public TCPClient {
public:
    TCPServerClient(sock_handle_t sock) : TCPClient(sock) {
    }

    virtual IPAddress remoteIP() override {
   d680c:	b570      	push	{r4, r5, r6, lr}
        IPAddress addr;
        struct sockaddr_storage saddr = {};
   d680e:	241c      	movs	r4, #28
class TCPServerClient : public TCPClient {
public:
    TCPServerClient(sock_handle_t sock) : TCPClient(sock) {
    }

    virtual IPAddress remoteIP() override {
   d6810:	b094      	sub	sp, #80	; 0x50
   d6812:	460d      	mov	r5, r1
   d6814:	4606      	mov	r6, r0
        IPAddress addr;
   d6816:	f000 fab3 	bl	d6d80 <_ZN9IPAddressC1Ev>
        struct sockaddr_storage saddr = {};
   d681a:	4622      	mov	r2, r4
   d681c:	2100      	movs	r1, #0
   d681e:	a80d      	add	r0, sp, #52	; 0x34
   d6820:	f001 fc1f 	bl	d8062 <memset>
        socklen_t len = sizeof(saddr);
   d6824:	aa14      	add	r2, sp, #80	; 0x50
    friend class TCPServer;

    using Print::write;

protected:
    inline sock_handle_t sock_handle() { return d_->sock; }
   d6826:	696b      	ldr	r3, [r5, #20]
   d6828:	f842 4d4c 	str.w	r4, [r2, #-76]!
        if (!sock_getpeername(sock_handle(), (struct sockaddr*)&saddr, &len)) {
   d682c:	a90d      	add	r1, sp, #52	; 0x34
   d682e:	6818      	ldr	r0, [r3, #0]
   d6830:	f7ff fb0c 	bl	d5e4c <sock_getpeername>
   d6834:	4601      	mov	r1, r0
   d6836:	bb68      	cbnz	r0, d6894 <_ZN15TCPServerClient8remoteIPEv+0x88>
namespace spark {

namespace detail {

inline void sockaddrToIpAddressPort(const struct sockaddr* saddr, IPAddress& addr, uint16_t* port) {
    if (saddr->sa_family == AF_INET) {
   d6838:	f89d 3035 	ldrb.w	r3, [sp, #53]	; 0x35
   d683c:	2b02      	cmp	r3, #2
   d683e:	d101      	bne.n	d6844 <_ZN15TCPServerClient8remoteIPEv+0x38>
        const struct sockaddr_in* inaddr = (const struct sockaddr_in*)saddr;
        addr = (const uint8_t*)(&inaddr->sin_addr.s_addr);
   d6840:	a90e      	add	r1, sp, #56	; 0x38
   d6842:	e024      	b.n	d688e <_ZN15TCPServerClient8remoteIPEv+0x82>
        if (port) {
            *port = ntohs(inaddr->sin_port);
        }
    }
#if HAL_IPv6
    else if (saddr->sa_family == AF_INET6) {
   d6844:	2b0a      	cmp	r3, #10
   d6846:	d125      	bne.n	d6894 <_ZN15TCPServerClient8remoteIPEv+0x88>
        const struct sockaddr_in6* in6addr = (const struct sockaddr_in6*)saddr;
        HAL_IPAddress a = {};
   d6848:	ac02      	add	r4, sp, #8
   d684a:	2211      	movs	r2, #17
   d684c:	4620      	mov	r0, r4
   d684e:	f001 fc08 	bl	d8062 <memset>
        if (!IN6_IS_ADDR_V4MAPPED(&in6addr->sin6_addr)) {
   d6852:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   d6854:	b943      	cbnz	r3, d6868 <_ZN15TCPServerClient8remoteIPEv+0x5c>
   d6856:	9b10      	ldr	r3, [sp, #64]	; 0x40
   d6858:	b933      	cbnz	r3, d6868 <_ZN15TCPServerClient8remoteIPEv+0x5c>
   d685a:	f64f 70ff 	movw	r0, #65535	; 0xffff
   d685e:	9d11      	ldr	r5, [sp, #68]	; 0x44
   d6860:	f7ff fa4c 	bl	d5cfc <inet_htonl>
   d6864:	4285      	cmp	r5, r0
   d6866:	d011      	beq.n	d688c <_ZN15TCPServerClient8remoteIPEv+0x80>
            memcpy(a.ipv6, in6addr->sin6_addr.s6_addr, sizeof(a.ipv6));
   d6868:	ab0f      	add	r3, sp, #60	; 0x3c
   d686a:	cb0f      	ldmia	r3, {r0, r1, r2, r3}

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
   d686c:	ad08      	add	r5, sp, #32
   d686e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
            a.v = 6;
   d6872:	2306      	movs	r3, #6
            addr = IPAddress(a);
   d6874:	4621      	mov	r1, r4
   d6876:	a807      	add	r0, sp, #28
    else if (saddr->sa_family == AF_INET6) {
        const struct sockaddr_in6* in6addr = (const struct sockaddr_in6*)saddr;
        HAL_IPAddress a = {};
        if (!IN6_IS_ADDR_V4MAPPED(&in6addr->sin6_addr)) {
            memcpy(a.ipv6, in6addr->sin6_addr.s6_addr, sizeof(a.ipv6));
            a.v = 6;
   d6878:	f88d 3018 	strb.w	r3, [sp, #24]
            addr = IPAddress(a);
   d687c:	f000 fa8e 	bl	d6d9c <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
   d6880:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   d6882:	1d34      	adds	r4, r6, #4
   d6884:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   d6886:	682b      	ldr	r3, [r5, #0]
   d6888:	7023      	strb	r3, [r4, #0]
   d688a:	e003      	b.n	d6894 <_ZN15TCPServerClient8remoteIPEv+0x88>
        } else {
            auto ptr = (const uint32_t*)(in6addr->sin6_addr.s6_addr);
            addr = (const uint8_t*)(&ptr[3]);
   d688c:	a912      	add	r1, sp, #72	; 0x48
   d688e:	4630      	mov	r0, r6
   d6890:	f000 fac6 	bl	d6e20 <_ZN9IPAddressaSEPKh>
            detail::sockaddrToIpAddressPort((const struct sockaddr*)&saddr, addr, nullptr);
        }
        return addr;
    }
   d6894:	4630      	mov	r0, r6
   d6896:	b014      	add	sp, #80	; 0x50
   d6898:	bd70      	pop	{r4, r5, r6, pc}
	...

000d689c <_ZN15TCPServerClientD1Ev>:

using namespace spark;

static TCPClient* s_invalid_client = nullptr;

class TCPServerClient : public TCPClient {
   d689c:	b510      	push	{r4, lr}
   d689e:	4b03      	ldr	r3, [pc, #12]	; (d68ac <_ZN15TCPServerClientD1Ev+0x10>)
   d68a0:	6003      	str	r3, [r0, #0]
   d68a2:	4604      	mov	r4, r0
   d68a4:	f7fd fc62 	bl	d416c <_ZN9TCPClientD1Ev>
   d68a8:	4620      	mov	r0, r4
   d68aa:	bd10      	pop	{r4, pc}
   d68ac:	000da768 	.word	0x000da768

000d68b0 <_ZN15TCPServerClientD0Ev>:
   d68b0:	b510      	push	{r4, lr}
   d68b2:	4604      	mov	r4, r0
   d68b4:	f7ff fff2 	bl	d689c <_ZN15TCPServerClientD1Ev>
   d68b8:	4620      	mov	r0, r4
   d68ba:	211c      	movs	r1, #28
   d68bc:	f001 f924 	bl	d7b08 <_ZdlPvj>
   d68c0:	4620      	mov	r0, r4
   d68c2:	bd10      	pop	{r4, pc}

000d68c4 <_ZN9TCPServerC1Etm>:
        }
        return addr;
    }
};

TCPServer::TCPServer(uint16_t port, network_interface_t nif)
   d68c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
   d68c6:	2500      	movs	r5, #0
        : _port(port),
          _nif(nif),
          _sock(-1),
          _client(-1) {
   d68c8:	4b11      	ldr	r3, [pc, #68]	; (d6910 <_ZN9TCPServerC1Etm+0x4c>)
   d68ca:	6003      	str	r3, [r0, #0]
   d68cc:	f04f 36ff 	mov.w	r6, #4294967295
   d68d0:	60c2      	str	r2, [r0, #12]
   d68d2:	6045      	str	r5, [r0, #4]
   d68d4:	8101      	strh	r1, [r0, #8]
   d68d6:	6106      	str	r6, [r0, #16]
   d68d8:	4631      	mov	r1, r6
        }
        return addr;
    }
};

TCPServer::TCPServer(uint16_t port, network_interface_t nif)
   d68da:	4604      	mov	r4, r0
        : _port(port),
          _nif(nif),
          _sock(-1),
          _client(-1) {
   d68dc:	3014      	adds	r0, #20
   d68de:	f000 ff33 	bl	d7748 <_ZN9TCPClientC1Ei>
typedef std::function<os_thread_return_t(void)> wiring_thread_fn_t;

class SingleThreadedSection {
public:
    SingleThreadedSection() {
        os_thread_scheduling(false, NULL);
   d68e2:	4629      	mov	r1, r5
   d68e4:	4628      	mov	r0, r5
   d68e6:	f7ff f9e9 	bl	d5cbc <os_thread_scheduling>
    SINGLE_THREADED_BLOCK() {
        if (!s_invalid_client) {
   d68ea:	4b0a      	ldr	r3, [pc, #40]	; (d6914 <_ZN9TCPServerC1Etm+0x50>)
   d68ec:	681a      	ldr	r2, [r3, #0]
   d68ee:	461d      	mov	r5, r3
   d68f0:	b942      	cbnz	r2, d6904 <_ZN9TCPServerC1Etm+0x40>
            s_invalid_client = new TCPClient(-1);
   d68f2:	201c      	movs	r0, #28
   d68f4:	f7fd fbcf 	bl	d4096 <_Znwj>
   d68f8:	4607      	mov	r7, r0
   d68fa:	b110      	cbz	r0, d6902 <_ZN9TCPServerC1Etm+0x3e>
   d68fc:	4631      	mov	r1, r6
   d68fe:	f000 ff23 	bl	d7748 <_ZN9TCPClientC1Ei>
   d6902:	602f      	str	r7, [r5, #0]
    }

    ~SingleThreadedSection() {
        os_thread_scheduling(true, NULL);
   d6904:	2100      	movs	r1, #0
   d6906:	2001      	movs	r0, #1
   d6908:	f7ff f9d8 	bl	d5cbc <os_thread_scheduling>
        }
    }
}
   d690c:	4620      	mov	r0, r4
   d690e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   d6910:	000da7b4 	.word	0x000da7b4
   d6914:	2003e2c4 	.word	0x2003e2c4

000d6918 <_ZN9TCPServer4stopEv>:
    done.dismiss();

    return true;
}

void TCPServer::stop() {
   d6918:	b510      	push	{r4, lr}
   d691a:	4604      	mov	r4, r0
    _client.stop();
   d691c:	3014      	adds	r0, #20
   d691e:	f000 fe91 	bl	d7644 <_ZN9TCPClient4stopEv>
    sock_close(_sock);
   d6922:	6920      	ldr	r0, [r4, #16]
   d6924:	f7ff faa2 	bl	d5e6c <sock_close>
    _sock = -1;
   d6928:	f04f 33ff 	mov.w	r3, #4294967295
   d692c:	6123      	str	r3, [r4, #16]
   d692e:	bd10      	pop	{r4, pc}

000d6930 <_ZN9TCPServer5beginEv>:
            s_invalid_client = new TCPClient(-1);
        }
    }
}

bool TCPServer::begin() {
   d6930:	b570      	push	{r4, r5, r6, lr}
   d6932:	4604      	mov	r4, r0
   d6934:	b08c      	sub	sp, #48	; 0x30
    stop();
   d6936:	f7ff ffef 	bl	d6918 <_ZN9TCPServer4stopEv>

    if (socket_handle_valid(_sock)) {
   d693a:	6923      	ldr	r3, [r4, #16]
   d693c:	2b00      	cmp	r3, #0
   d693e:	da5a      	bge.n	d69f6 <_ZN9TCPServer5beginEv+0xc6>
    NAMED_SCOPE_GUARD(done, {
        stop();
    });

#if HAL_IPv6
    struct sockaddr_in6 saddr = {};
   d6940:	251c      	movs	r5, #28
   d6942:	462a      	mov	r2, r5
   d6944:	2100      	movs	r1, #0
   d6946:	a805      	add	r0, sp, #20
   d6948:	f001 fb8b 	bl	d8062 <memset>
    saddr.sin6_len = sizeof(saddr);
   d694c:	f88d 5014 	strb.w	r5, [sp, #20]
    saddr.sin6_family = AF_INET6;
    saddr.sin6_port = htons(_port);
   d6950:	8920      	ldrh	r0, [r4, #8]
    });

#if HAL_IPv6
    struct sockaddr_in6 saddr = {};
    saddr.sin6_len = sizeof(saddr);
    saddr.sin6_family = AF_INET6;
   d6952:	250a      	movs	r5, #10
   d6954:	f88d 5015 	strb.w	r5, [sp, #21]
    saddr.sin6_port = htons(_port);
   d6958:	f7ff f9d8 	bl	d5d0c <inet_htons>
    saddr.sin_port = htons(_port);
    saddr.sin_addr.s_addr = INADDR_ANY;
#endif // HAL_IPv6

    // Create socket
    _sock = sock_socket(HAL_IPv6 ? AF_INET6 : AF_INET, SOCK_STREAM, IPPROTO_TCP);
   d695c:	2206      	movs	r2, #6

#if HAL_IPv6
    struct sockaddr_in6 saddr = {};
    saddr.sin6_len = sizeof(saddr);
    saddr.sin6_family = AF_INET6;
    saddr.sin6_port = htons(_port);
   d695e:	f8ad 0016 	strh.w	r0, [sp, #22]
    saddr.sin_port = htons(_port);
    saddr.sin_addr.s_addr = INADDR_ANY;
#endif // HAL_IPv6

    // Create socket
    _sock = sock_socket(HAL_IPv6 ? AF_INET6 : AF_INET, SOCK_STREAM, IPPROTO_TCP);
   d6962:	2101      	movs	r1, #1
   d6964:	4628      	mov	r0, r5
   d6966:	f7ff faa9 	bl	d5ebc <sock_socket>
    CHECK_TRUE(_sock >= 0, false);
   d696a:	2800      	cmp	r0, #0
    saddr.sin_port = htons(_port);
    saddr.sin_addr.s_addr = INADDR_ANY;
#endif // HAL_IPv6

    // Create socket
    _sock = sock_socket(HAL_IPv6 ? AF_INET6 : AF_INET, SOCK_STREAM, IPPROTO_TCP);
   d696c:	6120      	str	r0, [r4, #16]
    CHECK_TRUE(_sock >= 0, false);
   d696e:	db30      	blt.n	d69d2 <_ZN9TCPServer5beginEv+0xa2>

    const int one = 1;
   d6970:	ab0c      	add	r3, sp, #48	; 0x30
   d6972:	2201      	movs	r2, #1
    CHECK_TRUE(sock_setsockopt(_sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) == 0, false);
   d6974:	2604      	movs	r6, #4

    // Create socket
    _sock = sock_socket(HAL_IPv6 ? AF_INET6 : AF_INET, SOCK_STREAM, IPPROTO_TCP);
    CHECK_TRUE(_sock >= 0, false);

    const int one = 1;
   d6976:	f843 2d28 	str.w	r2, [r3, #-40]!
    CHECK_TRUE(sock_setsockopt(_sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) == 0, false);
   d697a:	f640 71ff 	movw	r1, #4095	; 0xfff
   d697e:	9600      	str	r6, [sp, #0]
   d6980:	4632      	mov	r2, r6
   d6982:	f7ff fa6b 	bl	d5e5c <sock_setsockopt>
   d6986:	4605      	mov	r5, r0
   d6988:	bb18      	cbnz	r0, d69d2 <_ZN9TCPServer5beginEv+0xa2>

    int flags = sock_fcntl(_sock, F_GETFL, 0);
   d698a:	4602      	mov	r2, r0
   d698c:	2103      	movs	r1, #3
   d698e:	6920      	ldr	r0, [r4, #16]
   d6990:	f7ff fa9c 	bl	d5ecc <sock_fcntl>
    CHECK_TRUE(flags >= 0, false);
   d6994:	1e02      	subs	r2, r0, #0
   d6996:	db1c      	blt.n	d69d2 <_ZN9TCPServer5beginEv+0xa2>
    flags |= O_NONBLOCK;
    CHECK_TRUE(sock_fcntl(_sock, F_SETFL, flags) >= 0, false);
   d6998:	f042 0201 	orr.w	r2, r2, #1
   d699c:	4631      	mov	r1, r6
   d699e:	6920      	ldr	r0, [r4, #16]
   d69a0:	f7ff fa94 	bl	d5ecc <sock_fcntl>
   d69a4:	2800      	cmp	r0, #0
   d69a6:	db14      	blt.n	d69d2 <_ZN9TCPServer5beginEv+0xa2>

#if HAL_PLATFORM_IFAPI
    // TODO: provide compatibility headers and use if_indextoname()
    if (_nif != 0) {
   d69a8:	68e0      	ldr	r0, [r4, #12]
   d69aa:	b1b8      	cbz	r0, d69dc <_ZN9TCPServer5beginEv+0xac>
        struct ifreq ifr = {};
        if (if_index_to_name(_nif, ifr.ifr_name)) {
   d69ac:	a903      	add	r1, sp, #12
   d69ae:	b2c0      	uxtb	r0, r0
    CHECK_TRUE(sock_fcntl(_sock, F_SETFL, flags) >= 0, false);

#if HAL_PLATFORM_IFAPI
    // TODO: provide compatibility headers and use if_indextoname()
    if (_nif != 0) {
        struct ifreq ifr = {};
   d69b0:	9503      	str	r5, [sp, #12]
   d69b2:	f8ad 5010 	strh.w	r5, [sp, #16]
        if (if_index_to_name(_nif, ifr.ifr_name)) {
   d69b6:	f7ff f939 	bl	d5c2c <if_index_to_name>
   d69ba:	b950      	cbnz	r0, d69d2 <_ZN9TCPServer5beginEv+0xa2>
            return false;
        }
        if (sock_setsockopt(_sock, SOL_SOCKET, SO_BINDTODEVICE, &ifr, sizeof(ifr))) {
   d69bc:	2306      	movs	r3, #6
   d69be:	9300      	str	r3, [sp, #0]
   d69c0:	f241 020b 	movw	r2, #4107	; 0x100b
   d69c4:	ab03      	add	r3, sp, #12
   d69c6:	f640 71ff 	movw	r1, #4095	; 0xfff
   d69ca:	6920      	ldr	r0, [r4, #16]
   d69cc:	f7ff fa46 	bl	d5e5c <sock_setsockopt>
   d69d0:	b120      	cbz	r0, d69dc <_ZN9TCPServer5beginEv+0xac>

    if (socket_handle_valid(_sock)) {
        return true;
    }

    NAMED_SCOPE_GUARD(done, {
   d69d2:	4620      	mov	r0, r4
#if HAL_PLATFORM_IFAPI
    // TODO: provide compatibility headers and use if_indextoname()
    if (_nif != 0) {
        struct ifreq ifr = {};
        if (if_index_to_name(_nif, ifr.ifr_name)) {
            return false;
   d69d4:	2500      	movs	r5, #0

    if (socket_handle_valid(_sock)) {
        return true;
    }

    NAMED_SCOPE_GUARD(done, {
   d69d6:	f7ff ff9f 	bl	d6918 <_ZN9TCPServer4stopEv>
   d69da:	e00d      	b.n	d69f8 <_ZN9TCPServer5beginEv+0xc8>
            return false;
        }
    }
#endif // HAL_PLATFORM_IFAPI

    int r = sock_bind(_sock, (const struct sockaddr*)&saddr, sizeof(saddr));
   d69dc:	221c      	movs	r2, #28
   d69de:	a905      	add	r1, sp, #20
   d69e0:	6920      	ldr	r0, [r4, #16]
   d69e2:	f7ff fa2b 	bl	d5e3c <sock_bind>
    CHECK_TRUE(!r, false);
   d69e6:	2800      	cmp	r0, #0
   d69e8:	d1f3      	bne.n	d69d2 <_ZN9TCPServer5beginEv+0xa2>

    r = sock_listen(_sock, 5);
   d69ea:	2105      	movs	r1, #5
   d69ec:	6920      	ldr	r0, [r4, #16]
   d69ee:	f7ff fa4d 	bl	d5e8c <sock_listen>
    CHECK_TRUE(!r, false);
   d69f2:	2800      	cmp	r0, #0
   d69f4:	d1ed      	bne.n	d69d2 <_ZN9TCPServer5beginEv+0xa2>

bool TCPServer::begin() {
    stop();

    if (socket_handle_valid(_sock)) {
        return true;
   d69f6:	2501      	movs	r5, #1
    CHECK_TRUE(!r, false);

    done.dismiss();

    return true;
}
   d69f8:	4628      	mov	r0, r5
   d69fa:	b00c      	add	sp, #48	; 0x30
   d69fc:	bd70      	pop	{r4, r5, r6, pc}
	...

000d6a00 <_ZN9TCPServerD1Ev>:
    sock_handle_t _sock;
    TCPClient _client;

public:
    TCPServer(uint16_t, network_interface_t nif=0);
    ~TCPServer() { stop(); }
   d6a00:	b538      	push	{r3, r4, r5, lr}
   d6a02:	4604      	mov	r4, r0
   d6a04:	4b05      	ldr	r3, [pc, #20]	; (d6a1c <_ZN9TCPServerD1Ev+0x1c>)
   d6a06:	f844 3b14 	str.w	r3, [r4], #20
   d6a0a:	4605      	mov	r5, r0
   d6a0c:	f7ff ff84 	bl	d6918 <_ZN9TCPServer4stopEv>
   d6a10:	4620      	mov	r0, r4
   d6a12:	f7fd fbab 	bl	d416c <_ZN9TCPClientD1Ev>
   d6a16:	4628      	mov	r0, r5
   d6a18:	bd38      	pop	{r3, r4, r5, pc}
   d6a1a:	bf00      	nop
   d6a1c:	000da7b4 	.word	0x000da7b4

000d6a20 <_ZN9TCPServerD0Ev>:
   d6a20:	b510      	push	{r4, lr}
   d6a22:	4604      	mov	r4, r0
   d6a24:	f7ff ffec 	bl	d6a00 <_ZN9TCPServerD1Ev>
   d6a28:	4620      	mov	r0, r4
   d6a2a:	2130      	movs	r1, #48	; 0x30
   d6a2c:	f001 f86c 	bl	d7b08 <_ZdlPvj>
   d6a30:	4620      	mov	r0, r4
   d6a32:	bd10      	pop	{r4, pc}

000d6a34 <_ZN9TCPClientaSERKS_>:

#define TCPCLIENT_BUF_MAX_SIZE  128
/* 30 seconds */
#define SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT (30000)

class TCPClient : public Client {
   d6a34:	b538      	push	{r3, r4, r5, lr}
   d6a36:	684b      	ldr	r3, [r1, #4]
const unsigned char BIN = 2;

class String;
class __FlashStringHelper;

class Print
   d6a38:	6043      	str	r3, [r0, #4]
#define   getFloat(skipChar)  parseFloat(skipChar)
#define   getString( pre_string, post_string, buffer, length)
readBytesBetween( pre_string, terminator, buffer, length)
*/

class Stream : public Print
   d6a3a:	688b      	ldr	r3, [r1, #8]
   d6a3c:	6083      	str	r3, [r0, #8]
   d6a3e:	68cb      	ldr	r3, [r1, #12]
   d6a40:	60c3      	str	r3, [r0, #12]
#include "system_network.h"
#include "spark_wiring_print.h"
#include "spark_wiring_stream.h"
#include "spark_wiring_ipaddress.h"

class Client : public Stream {
   d6a42:	690b      	ldr	r3, [r1, #16]
   d6a44:	6103      	str	r3, [r0, #16]
    __enable_shared_from_this_helper(const __shared_count<_Lp>&, ...) noexcept
    { }


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
   d6a46:	694b      	ldr	r3, [r1, #20]
   d6a48:	6143      	str	r3, [r0, #20]
      }

      __shared_count&
      operator=(const __shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
   d6a4a:	698d      	ldr	r5, [r1, #24]
	if (__tmp != _M_pi)
   d6a4c:	6983      	ldr	r3, [r0, #24]
   d6a4e:	429d      	cmp	r5, r3
   d6a50:	4604      	mov	r4, r0
   d6a52:	d00c      	beq.n	d6a6e <_ZN9TCPClientaSERKS_+0x3a>
	  {
	    if (__tmp != 0)
   d6a54:	b115      	cbz	r5, d6a5c <_ZN9TCPClientaSERKS_+0x28>
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }
   d6a56:	686b      	ldr	r3, [r5, #4]
   d6a58:	3301      	adds	r3, #1
   d6a5a:	606b      	str	r3, [r5, #4]
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	if (__tmp != _M_pi)
	  {
	    if (__tmp != 0)
	      __tmp->_M_add_ref_copy();
	    if (_M_pi != 0)
   d6a5c:	69a0      	ldr	r0, [r4, #24]
   d6a5e:	b128      	cbz	r0, d6a6c <_ZN9TCPClientaSERKS_+0x38>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
   d6a60:	6843      	ldr	r3, [r0, #4]
   d6a62:	3b01      	subs	r3, #1
   d6a64:	6043      	str	r3, [r0, #4]
   d6a66:	b90b      	cbnz	r3, d6a6c <_ZN9TCPClientaSERKS_+0x38>
   d6a68:	f7ff fec0 	bl	d67ec <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.4.constprop.12>
	  {
	    if (__tmp != 0)
	      __tmp->_M_add_ref_copy();
	    if (_M_pi != 0)
	      _M_pi->_M_release();
	    _M_pi = __tmp;
   d6a6c:	61a5      	str	r5, [r4, #24]
   d6a6e:	4620      	mov	r0, r4
   d6a70:	bd38      	pop	{r3, r4, r5, pc}
	...

000d6a74 <_ZN9TCPClientC1ERKS_>:
   d6a74:	4b0c      	ldr	r3, [pc, #48]	; (d6aa8 <_ZN9TCPClientC1ERKS_+0x34>)
   d6a76:	6003      	str	r3, [r0, #0]
   d6a78:	684b      	ldr	r3, [r1, #4]
   d6a7a:	6043      	str	r3, [r0, #4]
   d6a7c:	4b0b      	ldr	r3, [pc, #44]	; (d6aac <_ZN9TCPClientC1ERKS_+0x38>)
   d6a7e:	6003      	str	r3, [r0, #0]
   d6a80:	688b      	ldr	r3, [r1, #8]
   d6a82:	6083      	str	r3, [r0, #8]
   d6a84:	68cb      	ldr	r3, [r1, #12]
   d6a86:	60c3      	str	r3, [r0, #12]
   d6a88:	4b09      	ldr	r3, [pc, #36]	; (d6ab0 <_ZN9TCPClientC1ERKS_+0x3c>)
   d6a8a:	6003      	str	r3, [r0, #0]
   d6a8c:	690b      	ldr	r3, [r1, #16]
   d6a8e:	6103      	str	r3, [r0, #16]
   d6a90:	4b08      	ldr	r3, [pc, #32]	; (d6ab4 <_ZN9TCPClientC1ERKS_+0x40>)
   d6a92:	6003      	str	r3, [r0, #0]
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
   d6a94:	694b      	ldr	r3, [r1, #20]
   d6a96:	6143      	str	r3, [r0, #20]
	if (_M_pi != nullptr)
	  _M_pi->_M_release();
      }

      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
   d6a98:	698b      	ldr	r3, [r1, #24]
   d6a9a:	6183      	str	r3, [r0, #24]
      {
	if (_M_pi != 0)
   d6a9c:	b113      	cbz	r3, d6aa4 <_ZN9TCPClientC1ERKS_+0x30>
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }
   d6a9e:	685a      	ldr	r2, [r3, #4]
   d6aa0:	3201      	adds	r2, #1
   d6aa2:	605a      	str	r2, [r3, #4]
   d6aa4:	4770      	bx	lr
   d6aa6:	bf00      	nop
   d6aa8:	000da5ec 	.word	0x000da5ec
   d6aac:	000da700 	.word	0x000da700
   d6ab0:	000da728 	.word	0x000da728
   d6ab4:	000da8c4 	.word	0x000da8c4

000d6ab8 <_ZN9TCPServer9availableEv>:
    _client.stop();
    sock_close(_sock);
    _sock = -1;
}

TCPClient TCPServer::available() {
   d6ab8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (_sock < 0) {
   d6abc:	690b      	ldr	r3, [r1, #16]
   d6abe:	2b00      	cmp	r3, #0
    _client.stop();
    sock_close(_sock);
    _sock = -1;
}

TCPClient TCPServer::available() {
   d6ac0:	b096      	sub	sp, #88	; 0x58
   d6ac2:	4607      	mov	r7, r0
   d6ac4:	460c      	mov	r4, r1
    if (_sock < 0) {
   d6ac6:	da03      	bge.n	d6ad0 <_ZN9TCPServer9availableEv+0x18>
        begin();
   d6ac8:	680b      	ldr	r3, [r1, #0]
   d6aca:	4608      	mov	r0, r1
   d6acc:	691b      	ldr	r3, [r3, #16]
   d6ace:	4798      	blx	r3
    }

    if (_sock < 0) {
   d6ad0:	6925      	ldr	r5, [r4, #16]
   d6ad2:	2d00      	cmp	r5, #0
   d6ad4:	f104 0614 	add.w	r6, r4, #20
   d6ad8:	da05      	bge.n	d6ae6 <_ZN9TCPServer9availableEv+0x2e>
        _client = *s_invalid_client;
   d6ada:	4b24      	ldr	r3, [pc, #144]	; (d6b6c <_ZN9TCPServer9availableEv+0xb4>)
   d6adc:	4630      	mov	r0, r6
   d6ade:	6819      	ldr	r1, [r3, #0]
   d6ae0:	f7ff ffa8 	bl	d6a34 <_ZN9TCPClientaSERKS_>
   d6ae4:	e036      	b.n	d6b54 <_ZN9TCPServer9availableEv+0x9c>
        return _client;
    }

    struct sockaddr_storage saddr = {};
   d6ae6:	f04f 081c 	mov.w	r8, #28
   d6aea:	4642      	mov	r2, r8
   d6aec:	2100      	movs	r1, #0
   d6aee:	a808      	add	r0, sp, #32
   d6af0:	f001 fab7 	bl	d8062 <memset>
    socklen_t slen = sizeof(saddr);
   d6af4:	aa16      	add	r2, sp, #88	; 0x58
    int s = sock_accept(_sock, (struct sockaddr*)&saddr, &slen);
   d6af6:	a908      	add	r1, sp, #32
        _client = *s_invalid_client;
        return _client;
    }

    struct sockaddr_storage saddr = {};
    socklen_t slen = sizeof(saddr);
   d6af8:	f842 8d54 	str.w	r8, [r2, #-84]!
    int s = sock_accept(_sock, (struct sockaddr*)&saddr, &slen);
   d6afc:	4628      	mov	r0, r5
   d6afe:	f7ff f995 	bl	d5e2c <sock_accept>
    if (s < 0) {
   d6b02:	1e01      	subs	r1, r0, #0
   d6b04:	da0f      	bge.n	d6b26 <_ZN9TCPServer9availableEv+0x6e>
        _client = *s_invalid_client;
   d6b06:	4b19      	ldr	r3, [pc, #100]	; (d6b6c <_ZN9TCPServer9availableEv+0xb4>)
   d6b08:	4630      	mov	r0, r6
   d6b0a:	6819      	ldr	r1, [r3, #0]
   d6b0c:	f7ff ff92 	bl	d6a34 <_ZN9TCPClientaSERKS_>
        if (errno != EAGAIN && errno != EWOULDBLOCK) {
   d6b10:	f7ff fb30 	bl	d6174 <__errno>
   d6b14:	6803      	ldr	r3, [r0, #0]
   d6b16:	2b0b      	cmp	r3, #11
   d6b18:	d01c      	beq.n	d6b54 <_ZN9TCPServer9availableEv+0x9c>
   d6b1a:	f7ff fb2b 	bl	d6174 <__errno>
   d6b1e:	6803      	ldr	r3, [r0, #0]
   d6b20:	2b0b      	cmp	r3, #11
   d6b22:	d11f      	bne.n	d6b64 <_ZN9TCPServer9availableEv+0xac>
   d6b24:	e016      	b.n	d6b54 <_ZN9TCPServer9availableEv+0x9c>

static TCPClient* s_invalid_client = nullptr;

class TCPServerClient : public TCPClient {
public:
    TCPServerClient(sock_handle_t sock) : TCPClient(sock) {
   d6b26:	a80f      	add	r0, sp, #60	; 0x3c
   d6b28:	f000 fe0e 	bl	d7748 <_ZN9TCPClientC1Ei>
   d6b2c:	ad03      	add	r5, sp, #12
   d6b2e:	4b10      	ldr	r3, [pc, #64]	; (d6b70 <_ZN9TCPServer9availableEv+0xb8>)
   d6b30:	930f      	str	r3, [sp, #60]	; 0x3c
        if (errno != EAGAIN && errno != EWOULDBLOCK) {
            stop();
        }
    } else {
        TCPServerClient client = TCPServerClient(s);
        client.d_->remoteIP = client.remoteIP(); // fetch the peer IP ready for the copy operator
   d6b32:	a90f      	add	r1, sp, #60	; 0x3c
   d6b34:	a802      	add	r0, sp, #8
   d6b36:	9c14      	ldr	r4, [sp, #80]	; 0x50
   d6b38:	f7ff fe68 	bl	d680c <_ZN15TCPServerClient8remoteIPEv>
   d6b3c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   d6b3e:	348c      	adds	r4, #140	; 0x8c
   d6b40:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   d6b42:	682b      	ldr	r3, [r5, #0]
   d6b44:	7023      	strb	r3, [r4, #0]
        _client = client;
   d6b46:	a90f      	add	r1, sp, #60	; 0x3c
   d6b48:	4630      	mov	r0, r6
   d6b4a:	f7ff ff73 	bl	d6a34 <_ZN9TCPClientaSERKS_>
        _client = *s_invalid_client;
        if (errno != EAGAIN && errno != EWOULDBLOCK) {
            stop();
        }
    } else {
        TCPServerClient client = TCPServerClient(s);
   d6b4e:	a80f      	add	r0, sp, #60	; 0x3c
   d6b50:	f7ff fea4 	bl	d689c <_ZN15TCPServerClientD1Ev>
        client.d_->remoteIP = client.remoteIP(); // fetch the peer IP ready for the copy operator
        _client = client;
    }

    return _client;
   d6b54:	4631      	mov	r1, r6
   d6b56:	4638      	mov	r0, r7
   d6b58:	f7ff ff8c 	bl	d6a74 <_ZN9TCPClientC1ERKS_>
}
   d6b5c:	4638      	mov	r0, r7
   d6b5e:	b016      	add	sp, #88	; 0x58
   d6b60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    socklen_t slen = sizeof(saddr);
    int s = sock_accept(_sock, (struct sockaddr*)&saddr, &slen);
    if (s < 0) {
        _client = *s_invalid_client;
        if (errno != EAGAIN && errno != EWOULDBLOCK) {
            stop();
   d6b64:	4620      	mov	r0, r4
   d6b66:	f7ff fed7 	bl	d6918 <_ZN9TCPServer4stopEv>
   d6b6a:	e7f3      	b.n	d6b54 <_ZN9TCPServer9availableEv+0x9c>
   d6b6c:	2003e2c4 	.word	0x2003e2c4
   d6b70:	000da768 	.word	0x000da768

000d6b74 <_ZNSt14_Function_baseD1Ev>:
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
   d6b74:	b510      	push	{r4, lr}
    {
      if (_M_manager)
   d6b76:	6883      	ldr	r3, [r0, #8]
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
   d6b78:	4604      	mov	r4, r0
    {
      if (_M_manager)
   d6b7a:	b113      	cbz	r3, d6b82 <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
   d6b7c:	2203      	movs	r2, #3
   d6b7e:	4601      	mov	r1, r0
   d6b80:	4798      	blx	r3
    }
   d6b82:	4620      	mov	r0, r4
   d6b84:	bd10      	pop	{r4, pc}

000d6b86 <_ZN8RGBClassD1Ev>:
#include "rgbled.h"

typedef void (raw_rgb_change_handler_t)(uint8_t, uint8_t, uint8_t);
typedef std::function<raw_rgb_change_handler_t> wiring_rgb_change_handler_t;

class RGBClass {
   d6b86:	b510      	push	{r4, lr}
   d6b88:	4604      	mov	r4, r0
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
   d6b8a:	f7ff fff3 	bl	d6b74 <_ZNSt14_Function_baseD1Ev>
   d6b8e:	4620      	mov	r0, r4
   d6b90:	bd10      	pop	{r4, pc}
	...

000d6b94 <_GLOBAL__sub_I_RGB>:
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
   d6b94:	4803      	ldr	r0, [pc, #12]	; (d6ba4 <_GLOBAL__sub_I_RGB+0x10>)
#include "spark_wiring_rgb.h"
#include "spark_wiring_interrupts.h"

#include "core_hal.h"

RGBClass RGB;
   d6b96:	4a04      	ldr	r2, [pc, #16]	; (d6ba8 <_GLOBAL__sub_I_RGB+0x14>)
   d6b98:	4904      	ldr	r1, [pc, #16]	; (d6bac <_GLOBAL__sub_I_RGB+0x18>)
   d6b9a:	2300      	movs	r3, #0
   d6b9c:	6083      	str	r3, [r0, #8]
   d6b9e:	f000 bfa5 	b.w	d7aec <__aeabi_atexit>
   d6ba2:	bf00      	nop
   d6ba4:	2003e2c8 	.word	0x2003e2c8
   d6ba8:	20034a40 	.word	0x20034a40
   d6bac:	000d6b87 	.word	0x000d6b87

000d6bb0 <serialEventRun>:

/**
 * Provides background processing of serial data.
 */
void serialEventRun()
{
   d6bb0:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
   d6bb2:	4b0c      	ldr	r3, [pc, #48]	; (d6be4 <serialEventRun+0x34>)
   d6bb4:	b133      	cbz	r3, d6bc4 <serialEventRun+0x14>
   d6bb6:	f000 f99d 	bl	d6ef4 <_Z16_fetch_usbserialv>
   d6bba:	6803      	ldr	r3, [r0, #0]
   d6bbc:	691b      	ldr	r3, [r3, #16]
   d6bbe:	4798      	blx	r3
   d6bc0:	2800      	cmp	r0, #0
   d6bc2:	dc09      	bgt.n	d6bd8 <serialEventRun+0x28>
        serialEvent();

    if (serialEvent1 && Serial1.available()>0)
   d6bc4:	4b08      	ldr	r3, [pc, #32]	; (d6be8 <serialEventRun+0x38>)
   d6bc6:	b163      	cbz	r3, d6be2 <serialEventRun+0x32>
   d6bc8:	f000 fa20 	bl	d700c <_Z22__fetch_global_Serial1v>
   d6bcc:	6803      	ldr	r3, [r0, #0]
   d6bce:	691b      	ldr	r3, [r3, #16]
   d6bd0:	4798      	blx	r3
   d6bd2:	2800      	cmp	r0, #0
   d6bd4:	dc03      	bgt.n	d6bde <serialEventRun+0x2e>
   d6bd6:	bd08      	pop	{r3, pc}
 * Provides background processing of serial data.
 */
void serialEventRun()
{
    if (serialEvent && Serial.available()>0)
        serialEvent();
   d6bd8:	f3af 8000 	nop.w
   d6bdc:	e7f2      	b.n	d6bc4 <serialEventRun+0x14>

    if (serialEvent1 && Serial1.available()>0)
        serialEvent1();
   d6bde:	f3af 8000 	nop.w
   d6be2:	bd08      	pop	{r3, pc}
	...

000d6bec <_post_loop>:
#if Wiring_Serial5
void serialEvent5() __attribute__((weak));
#endif

void _post_loop()
{
   d6bec:	b508      	push	{r3, lr}
	serialEventRun();
   d6bee:	f7ff ffdf 	bl	d6bb0 <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
   d6bf2:	f7ff f833 	bl	d5c5c <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
   d6bf6:	4b01      	ldr	r3, [pc, #4]	; (d6bfc <_post_loop+0x10>)
   d6bf8:	6018      	str	r0, [r3, #0]
   d6bfa:	bd08      	pop	{r3, pc}
   d6bfc:	2003e608 	.word	0x2003e608

000d6c00 <_Z33system_initialize_user_backup_ramv>:
 * the dynamically linked application module.
 */
void system_initialize_user_backup_ram()
{
    size_t len = &link_global_retained_end-&link_global_retained_start;
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
   d6c00:	4802      	ldr	r0, [pc, #8]	; (d6c0c <_Z33system_initialize_user_backup_ramv+0xc>)
   d6c02:	4a03      	ldr	r2, [pc, #12]	; (d6c10 <_Z33system_initialize_user_backup_ramv+0x10>)
   d6c04:	4903      	ldr	r1, [pc, #12]	; (d6c14 <_Z33system_initialize_user_backup_ramv+0x14>)
   d6c06:	1a12      	subs	r2, r2, r0
   d6c08:	f001 ba20 	b.w	d804c <memcpy>
   d6c0c:	2003f400 	.word	0x2003f400
   d6c10:	2003f404 	.word	0x2003f404
   d6c14:	000daef0 	.word	0x000daef0

000d6c18 <_Z27ctrl_request_custom_handlerP12ctrl_request>:
bool __backup_ram_was_valid() { return false; }

#endif

// Default handler for CTRL_REQUEST_APP_CUSTOM requests
void __attribute((weak)) ctrl_request_custom_handler(ctrl_request* req) {
   d6c18:	b507      	push	{r0, r1, r2, lr}
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
   d6c1a:	2300      	movs	r3, #0
   d6c1c:	9300      	str	r3, [sp, #0]
   d6c1e:	461a      	mov	r2, r3
   d6c20:	f06f 0177 	mvn.w	r1, #119	; 0x77
   d6c24:	f7ff f9cc 	bl	d5fc0 <system_ctrl_set_result>
}
   d6c28:	b003      	add	sp, #12
   d6c2a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000d6c30 <_ZL20ctrl_request_handlerP12ctrl_request>:
// Callback invoked to process a logging configuration request
void(*log_process_ctrl_request_callback)(ctrl_request* req) = nullptr;
#endif

// Application handler for control requests
static void ctrl_request_handler(ctrl_request* req) {
   d6c30:	b507      	push	{r0, r1, r2, lr}
    switch (req->type) {
   d6c32:	8843      	ldrh	r3, [r0, #2]
   d6c34:	2b0a      	cmp	r3, #10
   d6c36:	d008      	beq.n	d6c4a <_ZL20ctrl_request_handlerP12ctrl_request+0x1a>
   d6c38:	2b50      	cmp	r3, #80	; 0x50
   d6c3a:	d109      	bne.n	d6c50 <_ZL20ctrl_request_handlerP12ctrl_request+0x20>
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
   d6c3c:	4b09      	ldr	r3, [pc, #36]	; (d6c64 <_ZL20ctrl_request_handlerP12ctrl_request+0x34>)
   d6c3e:	681b      	ldr	r3, [r3, #0]
   d6c40:	b13b      	cbz	r3, d6c52 <_ZL20ctrl_request_handlerP12ctrl_request+0x22>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
        break;
    }
}
   d6c42:	b003      	add	sp, #12
   d6c44:	f85d eb04 	ldr.w	lr, [sp], #4
static void ctrl_request_handler(ctrl_request* req) {
    switch (req->type) {
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
            log_process_ctrl_request_callback(req);
   d6c48:	4718      	bx	r3
        }
        break;
    }
#endif
    case CTRL_REQUEST_APP_CUSTOM: {
        ctrl_request_custom_handler(req);
   d6c4a:	f7ff ffe5 	bl	d6c18 <_Z27ctrl_request_custom_handlerP12ctrl_request>
        break;
   d6c4e:	e006      	b.n	d6c5e <_ZL20ctrl_request_handlerP12ctrl_request+0x2e>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
   d6c50:	2300      	movs	r3, #0
   d6c52:	9300      	str	r3, [sp, #0]
   d6c54:	461a      	mov	r2, r3
   d6c56:	f06f 0177 	mvn.w	r1, #119	; 0x77
   d6c5a:	f7ff f9b1 	bl	d5fc0 <system_ctrl_set_result>
        break;
    }
}
   d6c5e:	b003      	add	sp, #12
   d6c60:	f85d fb04 	ldr.w	pc, [sp], #4
   d6c64:	2003e2d8 	.word	0x2003e2d8

000d6c68 <module_user_init_hook>:

void module_user_init_hook()
{
   d6c68:	b538      	push	{r3, r4, r5, lr}
#if HAL_PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ =  __backup_sram_signature==signature;
   d6c6a:	4c10      	ldr	r4, [pc, #64]	; (d6cac <module_user_init_hook+0x44>)
   d6c6c:	4d10      	ldr	r5, [pc, #64]	; (d6cb0 <module_user_init_hook+0x48>)
   d6c6e:	6823      	ldr	r3, [r4, #0]
   d6c70:	42ab      	cmp	r3, r5
   d6c72:	4b10      	ldr	r3, [pc, #64]	; (d6cb4 <module_user_init_hook+0x4c>)
   d6c74:	bf0c      	ite	eq
   d6c76:	2201      	moveq	r2, #1
   d6c78:	2200      	movne	r2, #0
   d6c7a:	701a      	strb	r2, [r3, #0]
    if (!backup_ram_was_valid_) {
   d6c7c:	d002      	beq.n	d6c84 <module_user_init_hook+0x1c>
        system_initialize_user_backup_ram();
   d6c7e:	f7ff ffbf 	bl	d6c00 <_Z33system_initialize_user_backup_ramv>
        __backup_sram_signature = signature;
   d6c82:	6025      	str	r5, [r4, #0]
    }
#endif

#if HAL_PLATFORM_RNG
    // Initialize the default stdlib PRNG using hardware RNG as a seed
    const uint32_t seed = HAL_RNG_GetRandomNumber();
   d6c84:	f7fe ffda 	bl	d5c3c <HAL_RNG_GetRandomNumber>
   d6c88:	4604      	mov	r4, r0
    srand(seed);
   d6c8a:	f001 f9f3 	bl	d8074 <srand>

    // If the user defines random_seed_from_cloud, call it with a seed value
    // generated by a hardware RNG as well.
    if (random_seed_from_cloud) {
   d6c8e:	4b0a      	ldr	r3, [pc, #40]	; (d6cb8 <module_user_init_hook+0x50>)
   d6c90:	b113      	cbz	r3, d6c98 <module_user_init_hook+0x30>
        random_seed_from_cloud(seed);
   d6c92:	4620      	mov	r0, r4
   d6c94:	f3af 8000 	nop.w
    }
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);
   d6c98:	2100      	movs	r1, #0
   d6c9a:	4807      	ldr	r0, [pc, #28]	; (d6cb8 <module_user_init_hook+0x50>)
   d6c9c:	f7ff fa1a 	bl	d60d4 <spark_set_random_seed_from_cloud_handler>

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
   d6ca0:	2100      	movs	r1, #0
   d6ca2:	4806      	ldr	r0, [pc, #24]	; (d6cbc <module_user_init_hook+0x54>)
}
   d6ca4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
   d6ca8:	f7ff b980 	b.w	d5fac <system_ctrl_set_app_request_handler>
   d6cac:	2003f400 	.word	0x2003f400
   d6cb0:	9a271c1e 	.word	0x9a271c1e
   d6cb4:	2003e2dc 	.word	0x2003e2dc
   d6cb8:	00000000 	.word	0x00000000
   d6cbc:	000d6c31 	.word	0x000d6c31

000d6cc0 <_ZN10CloudClass22call_raw_user_functionEPvPKcS0_>:
}

} // namespace

int CloudClass::call_raw_user_function(void* data, const char* param, void* reserved)
{
   d6cc0:	b510      	push	{r4, lr}
   d6cc2:	b088      	sub	sp, #32
   d6cc4:	4604      	mov	r4, r0
    user_function_int_str_t* fn = (user_function_int_str_t*)(data);
    String p(param);
   d6cc6:	4668      	mov	r0, sp
   d6cc8:	f7ff fb1f 	bl	d630a <_ZN6StringC1EPK19__FlashStringHelper>
    return (*fn)(p);
   d6ccc:	4669      	mov	r1, sp
   d6cce:	a804      	add	r0, sp, #16
   d6cd0:	f7ff fb3d 	bl	d634e <_ZN6StringC1ERKS_>
   d6cd4:	a804      	add	r0, sp, #16
   d6cd6:	47a0      	blx	r4
   d6cd8:	4604      	mov	r4, r0
   d6cda:	a804      	add	r0, sp, #16
   d6cdc:	f7ff face 	bl	d627c <_ZN6StringD1Ev>
} // namespace

int CloudClass::call_raw_user_function(void* data, const char* param, void* reserved)
{
    user_function_int_str_t* fn = (user_function_int_str_t*)(data);
    String p(param);
   d6ce0:	4668      	mov	r0, sp
   d6ce2:	f7ff facb 	bl	d627c <_ZN6StringD1Ev>
    return (*fn)(p);
}
   d6ce6:	4620      	mov	r0, r4
   d6ce8:	b008      	add	sp, #32
   d6cea:	bd10      	pop	{r4, pc}

000d6cec <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>:
    wiring_event_handler_t* fn = (wiring_event_handler_t*)(handler_data);
    (*fn)(event_name, data);
}

bool CloudClass::register_function(cloud_function_t fn, void* data, const char* funcKey)
{
   d6cec:	b5f0      	push	{r4, r5, r6, r7, lr}
    const char *funcKey;
    cloud_function_t fn;
    void* data;

     cloud_function_descriptor() {
         memset(this, 0, sizeof(*this));
   d6cee:	2410      	movs	r4, #16
   d6cf0:	b085      	sub	sp, #20
   d6cf2:	4607      	mov	r7, r0
   d6cf4:	460e      	mov	r6, r1
   d6cf6:	4615      	mov	r5, r2
   d6cf8:	2100      	movs	r1, #0
   d6cfa:	4622      	mov	r2, r4
   d6cfc:	4668      	mov	r0, sp
   d6cfe:	f001 f9b0 	bl	d8062 <memset>
    cloud_function_descriptor desc = {};
    desc.size = sizeof(desc);
    desc.fn = fn;
    desc.data = (void*)data;
    desc.funcKey = funcKey;
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
   d6d02:	2200      	movs	r2, #0
   d6d04:	4669      	mov	r1, sp
   d6d06:	4610      	mov	r0, r2
         size = sizeof(*this);
   d6d08:	f8ad 4000 	strh.w	r4, [sp]

bool CloudClass::register_function(cloud_function_t fn, void* data, const char* funcKey)
{
    cloud_function_descriptor desc = {};
    desc.size = sizeof(desc);
    desc.fn = fn;
   d6d0c:	9702      	str	r7, [sp, #8]
    desc.data = (void*)data;
   d6d0e:	9603      	str	r6, [sp, #12]
    desc.funcKey = funcKey;
   d6d10:	9501      	str	r5, [sp, #4]
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
   d6d12:	f7ff f9bf 	bl	d6094 <spark_function>
}
   d6d16:	b005      	add	sp, #20
   d6d18:	bdf0      	pop	{r4, r5, r6, r7, pc}

000d6d1a <_ZNK9IPAddress7printToER5Print>:
#endif // Wiring_IPv6
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
   d6d1a:	b5f0      	push	{r4, r5, r6, r7, lr}
#if Wiring_IPv6
#if HAL_USE_INET_HAL_POSIX
	if (address.v==6) {
   d6d1c:	7d03      	ldrb	r3, [r0, #20]
   d6d1e:	2b06      	cmp	r3, #6
#endif // Wiring_IPv6
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
   d6d20:	b08d      	sub	sp, #52	; 0x34
   d6d22:	460e      	mov	r6, r1
   d6d24:	f100 0704 	add.w	r7, r0, #4
   d6d28:	f04f 0400 	mov.w	r4, #0
#if Wiring_IPv6
#if HAL_USE_INET_HAL_POSIX
	if (address.v==6) {
   d6d2c:	d002      	beq.n	d6d34 <_ZNK9IPAddress7printToER5Print+0x1a>
   d6d2e:	f100 0508 	add.w	r5, r0, #8
   d6d32:	e018      	b.n	d6d66 <_ZNK9IPAddress7printToER5Print+0x4c>
		char buf[INET6_ADDRSTRLEN+1];
		buf[0] = 0;
   d6d34:	ad0c      	add	r5, sp, #48	; 0x30
		inet_inet_ntop(AF_INET6, address.ipv6, buf, sizeof(buf));
   d6d36:	4639      	mov	r1, r7
{
#if Wiring_IPv6
#if HAL_USE_INET_HAL_POSIX
	if (address.v==6) {
		char buf[INET6_ADDRSTRLEN+1];
		buf[0] = 0;
   d6d38:	f805 4d30 	strb.w	r4, [r5, #-48]!
		inet_inet_ntop(AF_INET6, address.ipv6, buf, sizeof(buf));
   d6d3c:	232f      	movs	r3, #47	; 0x2f
   d6d3e:	462a      	mov	r2, r5
   d6d40:	200a      	movs	r0, #10
   d6d42:	f7fe ffd3 	bl	d5cec <inet_inet_ntop>
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
   d6d46:	4628      	mov	r0, r5
   d6d48:	f001 fef0 	bl	d8b2c <strlen>
   d6d4c:	6833      	ldr	r3, [r6, #0]
   d6d4e:	4602      	mov	r2, r0
   d6d50:	68db      	ldr	r3, [r3, #12]
   d6d52:	4629      	mov	r1, r5
   d6d54:	4630      	mov	r0, r6
   d6d56:	4798      	blx	r3
   d6d58:	e00f      	b.n	d6d7a <_ZNK9IPAddress7printToER5Print+0x60>
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
    {
        if (n)
   d6d5a:	b124      	cbz	r4, d6d66 <_ZNK9IPAddress7printToER5Print+0x4c>
            n += p.print('.');
   d6d5c:	212e      	movs	r1, #46	; 0x2e
   d6d5e:	4630      	mov	r0, r6
   d6d60:	f7ff fb9e 	bl	d64a0 <_ZN5Print5printEc>
   d6d64:	4404      	add	r4, r0
            t = print('-');
            val = -n;
        } else {
            val = n;
        }
        return printNumber(val, base) + t;
   d6d66:	f815 1d01 	ldrb.w	r1, [r5, #-1]!
   d6d6a:	220a      	movs	r2, #10
   d6d6c:	4630      	mov	r0, r6
   d6d6e:	f7ff fb9a 	bl	d64a6 <_ZN5Print11printNumberEmh>
#else
#pragma message "HAL_USE_INET_HAL_POSIX is required for IPv6 support in IPAddress::printTo()"
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
   d6d72:	42bd      	cmp	r5, r7
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
   d6d74:	4404      	add	r4, r0
#else
#pragma message "HAL_USE_INET_HAL_POSIX is required for IPv6 support in IPAddress::printTo()"
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
   d6d76:	d1f0      	bne.n	d6d5a <_ZNK9IPAddress7printToER5Print+0x40>
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
   d6d78:	4620      	mov	r0, r4
    }
    return n;
}
   d6d7a:	b00d      	add	sp, #52	; 0x34
   d6d7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

000d6d80 <_ZN9IPAddressC1Ev>:

#if HAL_USE_INET_HAL_POSIX
#include <arpa/inet.h>
#endif // HAL_USE_INET_HAL_POSIX

IPAddress::IPAddress()
   d6d80:	b510      	push	{r4, lr}
   d6d82:	4b05      	ldr	r3, [pc, #20]	; (d6d98 <_ZN9IPAddressC1Ev+0x18>)
   d6d84:	4604      	mov	r4, r0
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
   d6d86:	2211      	movs	r2, #17
   d6d88:	f840 3b04 	str.w	r3, [r0], #4
   d6d8c:	2100      	movs	r1, #0
   d6d8e:	f001 f968 	bl	d8062 <memset>
{
    clear();
}
   d6d92:	4620      	mov	r0, r4
   d6d94:	bd10      	pop	{r4, pc}
   d6d96:	bf00      	nop
   d6d98:	000da7d8 	.word	0x000da7d8

000d6d9c <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>:

IPAddress::IPAddress(const HAL_IPAddress& address)
   d6d9c:	4603      	mov	r3, r0
   d6d9e:	4a07      	ldr	r2, [pc, #28]	; (d6dbc <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0x20>)
   d6da0:	b510      	push	{r4, lr}
   d6da2:	f843 2b04 	str.w	r2, [r3], #4
{
    memcpy(&this->address, &address, sizeof(address));
   d6da6:	f101 0210 	add.w	r2, r1, #16
   d6daa:	f851 4b04 	ldr.w	r4, [r1], #4
   d6dae:	f843 4b04 	str.w	r4, [r3], #4
   d6db2:	4291      	cmp	r1, r2
   d6db4:	d1f9      	bne.n	d6daa <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0xe>
   d6db6:	780a      	ldrb	r2, [r1, #0]
   d6db8:	701a      	strb	r2, [r3, #0]
}
   d6dba:	bd10      	pop	{r4, pc}
   d6dbc:	000da7d8 	.word	0x000da7d8

000d6dc0 <_ZNK9IPAddresscvbEv>:
{
    *this = address;
}

IPAddress::operator bool() const
{
   d6dc0:	7d03      	ldrb	r3, [r0, #20]
#if Wiring_IPv6
    if (version() == 4) {
   d6dc2:	2b04      	cmp	r3, #4
   d6dc4:	d101      	bne.n	d6dca <_ZNK9IPAddresscvbEv+0xa>
        return address.ipv4 != 0;
   d6dc6:	6840      	ldr	r0, [r0, #4]
   d6dc8:	e008      	b.n	d6ddc <_ZNK9IPAddresscvbEv+0x1c>
    } else if (version() == 6) {
   d6dca:	2b06      	cmp	r3, #6
   d6dcc:	d10a      	bne.n	d6de4 <_ZNK9IPAddresscvbEv+0x24>
        return address.ipv6[0] != 0 || address.ipv6[1] != 0 || address.ipv6[2] != 0 || address.ipv6[3] != 0;
   d6dce:	6843      	ldr	r3, [r0, #4]
   d6dd0:	b953      	cbnz	r3, d6de8 <_ZNK9IPAddresscvbEv+0x28>
   d6dd2:	6883      	ldr	r3, [r0, #8]
   d6dd4:	b943      	cbnz	r3, d6de8 <_ZNK9IPAddresscvbEv+0x28>
   d6dd6:	68c3      	ldr	r3, [r0, #12]
   d6dd8:	b933      	cbnz	r3, d6de8 <_ZNK9IPAddresscvbEv+0x28>
   d6dda:	6900      	ldr	r0, [r0, #16]
   d6ddc:	3000      	adds	r0, #0
   d6dde:	bf18      	it	ne
   d6de0:	2001      	movne	r0, #1
   d6de2:	4770      	bx	lr
    } else {
        return false;
   d6de4:	2000      	movs	r0, #0
   d6de6:	4770      	bx	lr
{
#if Wiring_IPv6
    if (version() == 4) {
        return address.ipv4 != 0;
    } else if (version() == 6) {
        return address.ipv6[0] != 0 || address.ipv6[1] != 0 || address.ipv6[2] != 0 || address.ipv6[3] != 0;
   d6de8:	2001      	movs	r0, #1
        return false;
    }
#else
    return address.ipv4!=0;
#endif
}
   d6dea:	4770      	bx	lr

000d6dec <_ZN9IPAddress8set_ipv4Ehhhh>:

void IPAddress::set_ipv4(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
   d6dec:	b510      	push	{r4, lr}
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
   d6dee:	f89d 4008 	ldrb.w	r4, [sp, #8]
   d6df2:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
   d6df6:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
   d6dfa:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
        return &address;
    }

    inline void setVersion(uint8_t version) {
#if HAL_IPv6
        address.v = version;
   d6dfe:	2304      	movs	r3, #4
   d6e00:	6041      	str	r1, [r0, #4]
   d6e02:	7503      	strb	r3, [r0, #20]
   d6e04:	bd10      	pop	{r4, pc}
	...

000d6e08 <_ZN9IPAddressC1Ehhhh>:
{
    memcpy(&this->address, &address, sizeof(address));
}


IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
   d6e08:	b537      	push	{r0, r1, r2, r4, r5, lr}
   d6e0a:	4d04      	ldr	r5, [pc, #16]	; (d6e1c <_ZN9IPAddressC1Ehhhh+0x14>)
   d6e0c:	6005      	str	r5, [r0, #0]
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
   d6e0e:	f89d 5018 	ldrb.w	r5, [sp, #24]
   d6e12:	9500      	str	r5, [sp, #0]
   d6e14:	f7ff ffea 	bl	d6dec <_ZN9IPAddress8set_ipv4Ehhhh>
}
   d6e18:	b003      	add	sp, #12
   d6e1a:	bd30      	pop	{r4, r5, pc}
   d6e1c:	000da7d8 	.word	0x000da7d8

000d6e20 <_ZN9IPAddressaSEPKh>:
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
    setVersion(4);
}

IPAddress& IPAddress::operator=(const uint8_t* address)
{
   d6e20:	b537      	push	{r0, r1, r2, r4, r5, lr}
    set_ipv4(address[0], address[1], address[2], address[3]);
   d6e22:	780d      	ldrb	r5, [r1, #0]
   d6e24:	788b      	ldrb	r3, [r1, #2]
   d6e26:	784a      	ldrb	r2, [r1, #1]
   d6e28:	78c9      	ldrb	r1, [r1, #3]
   d6e2a:	9100      	str	r1, [sp, #0]
   d6e2c:	4629      	mov	r1, r5
   d6e2e:	f7ff ffdd 	bl	d6dec <_ZN9IPAddress8set_ipv4Ehhhh>
    return *this;
}
   d6e32:	b003      	add	sp, #12
   d6e34:	bd30      	pop	{r4, r5, pc}

000d6e36 <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
   d6e36:	7441      	strb	r1, [r0, #17]
   d6e38:	4770      	bx	lr

000d6e3a <_ZN9USBSerialD1Ev>:
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"
#include "concurrent_hal.h"

class USBSerial : public Stream
   d6e3a:	4770      	bx	lr

000d6e3c <_ZN9USBSerial4readEv>:
}


// Read data from buffer
int USBSerial::read()
{
   d6e3c:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, false));
   d6e3e:	2100      	movs	r1, #0
   d6e40:	7c00      	ldrb	r0, [r0, #16]
   d6e42:	f7ff f863 	bl	d5f0c <HAL_USB_USART_Receive_Data>
}
   d6e46:	ea30 0020 	bics.w	r0, r0, r0, asr #32
   d6e4a:	bf28      	it	cs
   d6e4c:	f04f 30ff 	movcs.w	r0, #4294967295
   d6e50:	bd08      	pop	{r3, pc}

000d6e52 <_ZN9USBSerial4peekEv>:
{
  _blocking = block;
}

int USBSerial::peek()
{
   d6e52:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, true));
   d6e54:	2101      	movs	r1, #1
   d6e56:	7c00      	ldrb	r0, [r0, #16]
   d6e58:	f7ff f858 	bl	d5f0c <HAL_USB_USART_Receive_Data>
}
   d6e5c:	ea30 0020 	bics.w	r0, r0, r0, asr #32
   d6e60:	bf28      	it	cs
   d6e62:	f04f 30ff 	movcs.w	r0, #4294967295
   d6e66:	bd08      	pop	{r3, pc}

000d6e68 <_ZN9USBSerial17availableForWriteEv>:
{
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, false));
}

int USBSerial::availableForWrite()
{
   d6e68:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USB_USART_Available_Data_For_Write(_serial));
   d6e6a:	7c00      	ldrb	r0, [r0, #16]
   d6e6c:	f7ff f846 	bl	d5efc <HAL_USB_USART_Available_Data_For_Write>
}
   d6e70:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   d6e74:	bd08      	pop	{r3, pc}

000d6e76 <_ZN9USBSerial9availableEv>:

int USBSerial::available()
{
   d6e76:	b508      	push	{r3, lr}
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
   d6e78:	7c00      	ldrb	r0, [r0, #16]
   d6e7a:	f7ff f837 	bl	d5eec <HAL_USB_USART_Available_Data>
}
   d6e7e:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   d6e82:	bd08      	pop	{r3, pc}

000d6e84 <_ZN9USBSerial5flushEv>:
  return 0;
}

void USBSerial::flush()
{
  HAL_USB_USART_Flush_Data(_serial);
   d6e84:	7c00      	ldrb	r0, [r0, #16]
   d6e86:	f7ff b851 	b.w	d5f2c <HAL_USB_USART_Flush_Data>

000d6e8a <_ZN9USBSerialD0Ev>:
   d6e8a:	b510      	push	{r4, lr}
   d6e8c:	2114      	movs	r1, #20
   d6e8e:	4604      	mov	r4, r0
   d6e90:	f000 fe3a 	bl	d7b08 <_ZdlPvj>
   d6e94:	4620      	mov	r0, r4
   d6e96:	bd10      	pop	{r4, pc}

000d6e98 <_ZN9USBSerial5writeEh>:
{
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
}

size_t USBSerial::write(uint8_t byte)
{
   d6e98:	b538      	push	{r3, r4, r5, lr}
   d6e9a:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
   d6e9c:	7c00      	ldrb	r0, [r0, #16]
{
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
}

size_t USBSerial::write(uint8_t byte)
{
   d6e9e:	460d      	mov	r5, r1
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
   d6ea0:	f7ff f82c 	bl	d5efc <HAL_USB_USART_Available_Data_For_Write>
   d6ea4:	2800      	cmp	r0, #0
   d6ea6:	dc01      	bgt.n	d6eac <_ZN9USBSerial5writeEh+0x14>
   d6ea8:	7c60      	ldrb	r0, [r4, #17]
   d6eaa:	b128      	cbz	r0, d6eb8 <_ZN9USBSerial5writeEh+0x20>
    return std::max(0, (int)HAL_USB_USART_Send_Data(_serial, byte));
   d6eac:	4629      	mov	r1, r5
   d6eae:	7c20      	ldrb	r0, [r4, #16]
   d6eb0:	f7ff f834 	bl	d5f1c <HAL_USB_USART_Send_Data>
   d6eb4:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
  }
  return 0;
}
   d6eb8:	bd38      	pop	{r3, r4, r5, pc}
	...

000d6ebc <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:

  HAL_USB_USART_Config conf = acquireSerialBuffer();
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
   d6ebc:	b510      	push	{r4, lr}
   d6ebe:	4604      	mov	r4, r0
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
   d6ec0:	2300      	movs	r3, #0
   d6ec2:	6063      	str	r3, [r4, #4]
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
   d6ec4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   d6ec8:	60a3      	str	r3, [r4, #8]
   d6eca:	4b05      	ldr	r3, [pc, #20]	; (d6ee0 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
   d6ecc:	6023      	str	r3, [r4, #0]
{
  _serial = serial;
  _blocking = true;
   d6ece:	2301      	movs	r3, #1

  HAL_USB_USART_Config conf = acquireSerialBuffer();
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
   d6ed0:	4608      	mov	r0, r1
{
  _serial = serial;
   d6ed2:	7421      	strb	r1, [r4, #16]
  _blocking = true;
   d6ed4:	7463      	strb	r3, [r4, #17]

  HAL_USB_USART_Init(_serial, &conf);
   d6ed6:	4611      	mov	r1, r2
   d6ed8:	f7ff f800 	bl	d5edc <HAL_USB_USART_Init>
}
   d6edc:	4620      	mov	r0, r4
   d6ede:	bd10      	pop	{r4, pc}
   d6ee0:	000da7ec 	.word	0x000da7ec

000d6ee4 <_Z19acquireSerialBufferv>:

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL

HAL_USB_USART_Config __attribute__((weak)) acquireSerialBuffer()
{
   d6ee4:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = {0};
   d6ee6:	2214      	movs	r2, #20

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL

HAL_USB_USART_Config __attribute__((weak)) acquireSerialBuffer()
{
   d6ee8:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
   d6eea:	2100      	movs	r1, #0
   d6eec:	f001 f8b9 	bl	d8062 <memset>
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
   d6ef0:	4620      	mov	r0, r4
   d6ef2:	bd10      	pop	{r4, pc}

000d6ef4 <_Z16_fetch_usbserialv>:

USBSerial& _fetch_usbserial()
{
   d6ef4:	b530      	push	{r4, r5, lr}
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
   d6ef6:	4d0e      	ldr	r5, [pc, #56]	; (d6f30 <_Z16_fetch_usbserialv+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial()
{
   d6ef8:	b087      	sub	sp, #28
  HAL_USB_USART_Config conf = acquireSerialBuffer();
   d6efa:	a801      	add	r0, sp, #4
   d6efc:	f7ff fff2 	bl	d6ee4 <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
   d6f00:	6829      	ldr	r1, [r5, #0]
   d6f02:	f011 0401 	ands.w	r4, r1, #1
   d6f06:	d110      	bne.n	d6f2a <_Z16_fetch_usbserialv+0x36>
   d6f08:	4628      	mov	r0, r5
   d6f0a:	f7fd f8d5 	bl	d40b8 <__cxa_guard_acquire>
   d6f0e:	b160      	cbz	r0, d6f2a <_Z16_fetch_usbserialv+0x36>
   d6f10:	aa01      	add	r2, sp, #4
   d6f12:	4621      	mov	r1, r4
   d6f14:	4807      	ldr	r0, [pc, #28]	; (d6f34 <_Z16_fetch_usbserialv+0x40>)
   d6f16:	f7ff ffd1 	bl	d6ebc <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
   d6f1a:	4628      	mov	r0, r5
   d6f1c:	f7fd f8d1 	bl	d40c2 <__cxa_guard_release>
   d6f20:	4a05      	ldr	r2, [pc, #20]	; (d6f38 <_Z16_fetch_usbserialv+0x44>)
   d6f22:	4906      	ldr	r1, [pc, #24]	; (d6f3c <_Z16_fetch_usbserialv+0x48>)
   d6f24:	4803      	ldr	r0, [pc, #12]	; (d6f34 <_Z16_fetch_usbserialv+0x40>)
   d6f26:	f000 fde1 	bl	d7aec <__aeabi_atexit>
	return _usbserial;
}
   d6f2a:	4802      	ldr	r0, [pc, #8]	; (d6f34 <_Z16_fetch_usbserialv+0x40>)
   d6f2c:	b007      	add	sp, #28
   d6f2e:	bd30      	pop	{r4, r5, pc}
   d6f30:	2003e2e0 	.word	0x2003e2e0
   d6f34:	2003e2e4 	.word	0x2003e2e4
   d6f38:	20034a40 	.word	0x20034a40
   d6f3c:	000d6e3b 	.word	0x000d6e3b

000d6f40 <_ZN11USARTSerialD1Ev>:
private:
  HAL_USART_Serial _serial;
  bool _blocking;
public:
  USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer);
  virtual ~USARTSerial() {};
   d6f40:	4770      	bx	lr

000d6f42 <_ZN11USARTSerial14blockOnOverrunEb>:
    HAL_USART_Half_Duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
   d6f42:	7441      	strb	r1, [r0, #17]
   d6f44:	4770      	bx	lr

000d6f46 <_ZN11USARTSerial17availableForWriteEv>:
}


int USARTSerial::availableForWrite(void)
{
   d6f46:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USART_Available_Data_For_Write(_serial));
   d6f48:	7c00      	ldrb	r0, [r0, #16]
   d6f4a:	f7fe ff27 	bl	d5d9c <HAL_USART_Available_Data_For_Write>
}
   d6f4e:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   d6f52:	bd08      	pop	{r3, pc}

000d6f54 <_ZN11USARTSerial9availableEv>:

int USARTSerial::available(void)
{
   d6f54:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USART_Available_Data(_serial));
   d6f56:	7c00      	ldrb	r0, [r0, #16]
   d6f58:	f7fe fef8 	bl	d5d4c <HAL_USART_Available_Data>
}
   d6f5c:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   d6f60:	bd08      	pop	{r3, pc}

000d6f62 <_ZN11USARTSerial4peekEv>:

int USARTSerial::peek(void)
{
   d6f62:	b508      	push	{r3, lr}
  return std::max(-1, (int)HAL_USART_Peek_Data(_serial));
   d6f64:	7c00      	ldrb	r0, [r0, #16]
   d6f66:	f7fe ff01 	bl	d5d6c <HAL_USART_Peek_Data>
}
   d6f6a:	ea30 0020 	bics.w	r0, r0, r0, asr #32
   d6f6e:	bf28      	it	cs
   d6f70:	f04f 30ff 	movcs.w	r0, #4294967295
   d6f74:	bd08      	pop	{r3, pc}

000d6f76 <_ZN11USARTSerial4readEv>:

int USARTSerial::read(void)
{
   d6f76:	b508      	push	{r3, lr}
  return std::max(-1, (int)HAL_USART_Read_Data(_serial));
   d6f78:	7c00      	ldrb	r0, [r0, #16]
   d6f7a:	f7fe feef 	bl	d5d5c <HAL_USART_Read_Data>
}
   d6f7e:	ea30 0020 	bics.w	r0, r0, r0, asr #32
   d6f82:	bf28      	it	cs
   d6f84:	f04f 30ff 	movcs.w	r0, #4294967295
   d6f88:	bd08      	pop	{r3, pc}

000d6f8a <_ZN11USARTSerial5flushEv>:

void USARTSerial::flush()
{
  HAL_USART_Flush_Data(_serial);
   d6f8a:	7c00      	ldrb	r0, [r0, #16]
   d6f8c:	f7fe bef6 	b.w	d5d7c <HAL_USART_Flush_Data>

000d6f90 <_ZN11USARTSerialD0Ev>:
   d6f90:	b510      	push	{r4, lr}
   d6f92:	2114      	movs	r1, #20
   d6f94:	4604      	mov	r4, r0
   d6f96:	f000 fdb7 	bl	d7b08 <_ZdlPvj>
   d6f9a:	4620      	mov	r0, r4
   d6f9c:	bd10      	pop	{r4, pc}

000d6f9e <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
   d6f9e:	b570      	push	{r4, r5, r6, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
   d6fa0:	7c45      	ldrb	r5, [r0, #17]
{
  HAL_USART_Flush_Data(_serial);
}

size_t USARTSerial::write(uint8_t c)
{
   d6fa2:	4604      	mov	r4, r0
   d6fa4:	460e      	mov	r6, r1
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
   d6fa6:	b925      	cbnz	r5, d6fb2 <_ZN11USARTSerial5writeEh+0x14>
   d6fa8:	7c00      	ldrb	r0, [r0, #16]
   d6faa:	f7fe fef7 	bl	d5d9c <HAL_USART_Available_Data_For_Write>
   d6fae:	2800      	cmp	r0, #0
   d6fb0:	dd05      	ble.n	d6fbe <_ZN11USARTSerial5writeEh+0x20>
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
   d6fb2:	4631      	mov	r1, r6
   d6fb4:	7c20      	ldrb	r0, [r4, #16]
  }
  return 0;
}
   d6fb6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
size_t USARTSerial::write(uint8_t c)
{
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
   d6fba:	f7fe bebf 	b.w	d5d3c <HAL_USART_Write_Data>
  }
  return 0;
}
   d6fbe:	4628      	mov	r0, r5
   d6fc0:	bd70      	pop	{r4, r5, r6, pc}
	...

000d6fc4 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>:
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
   d6fc4:	b510      	push	{r4, lr}
   d6fc6:	4604      	mov	r4, r0
   d6fc8:	4608      	mov	r0, r1
   d6fca:	4611      	mov	r1, r2
   d6fcc:	2200      	movs	r2, #0
   d6fce:	6062      	str	r2, [r4, #4]
   d6fd0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   d6fd4:	60a2      	str	r2, [r4, #8]
   d6fd6:	4a05      	ldr	r2, [pc, #20]	; (d6fec <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_+0x28>)
   d6fd8:	6022      	str	r2, [r4, #0]
{
  _serial = serial;
  // Default is blocking mode
  _blocking = true;
   d6fda:	2201      	movs	r2, #1

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
{
  _serial = serial;
   d6fdc:	7420      	strb	r0, [r4, #16]
  // Default is blocking mode
  _blocking = true;
   d6fde:	7462      	strb	r2, [r4, #17]
  HAL_USART_Init(serial, rx_buffer, tx_buffer);
   d6fe0:	461a      	mov	r2, r3
   d6fe2:	f7fe fe9b 	bl	d5d1c <HAL_USART_Init>
}
   d6fe6:	4620      	mov	r0, r4
   d6fe8:	bd10      	pop	{r4, pc}
   d6fea:	bf00      	nop
   d6fec:	000da81c 	.word	0x000da81c

000d6ff0 <_ZN11USARTSerial5beginEmm>:
  begin(baud, SERIAL_8N1);
}

void USARTSerial::begin(unsigned long baud, uint32_t config)
{
  HAL_USART_BeginConfig(_serial, baud, config, 0);
   d6ff0:	2300      	movs	r3, #0
   d6ff2:	7c00      	ldrb	r0, [r0, #16]
   d6ff4:	f7fe beda 	b.w	d5dac <HAL_USART_BeginConfig>

000d6ff8 <_ZN11USARTSerial5beginEm>:
}
// Public Methods //////////////////////////////////////////////////////////////

void USARTSerial::begin(unsigned long baud)
{
  begin(baud, SERIAL_8N1);
   d6ff8:	2200      	movs	r2, #0
   d6ffa:	f7ff bff9 	b.w	d6ff0 <_ZN11USARTSerial5beginEmm>

000d6ffe <_ZN11USARTSerial3endEv>:
  HAL_USART_BeginConfig(_serial, baud, config, 0);
}

void USARTSerial::end()
{
  HAL_USART_End(_serial);
   d6ffe:	7c00      	ldrb	r0, [r0, #16]
   d7000:	f7fe be94 	b.w	d5d2c <HAL_USART_End>

000d7004 <_ZN11USARTSerial9isEnabledEv>:
USARTSerial::operator bool() {
  return true;
}

bool USARTSerial::isEnabled() {
  return HAL_USART_Is_Enabled(_serial);
   d7004:	7c00      	ldrb	r0, [r0, #16]
   d7006:	f7fe bec1 	b.w	d5d8c <HAL_USART_Is_Enabled>
	...

000d700c <_Z22__fetch_global_Serial1v>:
static Ring_Buffer* serial1_rx_buffer = NULL;
static Ring_Buffer* serial1_tx_buffer = NULL;
#endif

USARTSerial& __fetch_global_Serial1()
{
   d700c:	b538      	push	{r3, r4, r5, lr}
#if ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
   d700e:	4d0c      	ldr	r5, [pc, #48]	; (d7040 <_Z22__fetch_global_Serial1v+0x34>)
   d7010:	6829      	ldr	r1, [r5, #0]
   d7012:	f011 0401 	ands.w	r4, r1, #1
   d7016:	d111      	bne.n	d703c <_Z22__fetch_global_Serial1v+0x30>
   d7018:	4628      	mov	r0, r5
   d701a:	f7fd f84d 	bl	d40b8 <__cxa_guard_acquire>
   d701e:	b168      	cbz	r0, d703c <_Z22__fetch_global_Serial1v+0x30>
   d7020:	4a08      	ldr	r2, [pc, #32]	; (d7044 <_Z22__fetch_global_Serial1v+0x38>)
   d7022:	4b09      	ldr	r3, [pc, #36]	; (d7048 <_Z22__fetch_global_Serial1v+0x3c>)
   d7024:	4809      	ldr	r0, [pc, #36]	; (d704c <_Z22__fetch_global_Serial1v+0x40>)
   d7026:	4621      	mov	r1, r4
   d7028:	f7ff ffcc 	bl	d6fc4 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>
   d702c:	4628      	mov	r0, r5
   d702e:	f7fd f848 	bl	d40c2 <__cxa_guard_release>
   d7032:	4a07      	ldr	r2, [pc, #28]	; (d7050 <_Z22__fetch_global_Serial1v+0x44>)
   d7034:	4907      	ldr	r1, [pc, #28]	; (d7054 <_Z22__fetch_global_Serial1v+0x48>)
   d7036:	4805      	ldr	r0, [pc, #20]	; (d704c <_Z22__fetch_global_Serial1v+0x40>)
   d7038:	f000 fd58 	bl	d7aec <__aeabi_atexit>
    serial1_tx_buffer = new Ring_Buffer();
  }
  static USARTSerial serial1(HAL_USART_SERIAL1, serial1_rx_buffer, serial1_tx_buffer);
#endif
	return serial1;
}
   d703c:	4803      	ldr	r0, [pc, #12]	; (d704c <_Z22__fetch_global_Serial1v+0x40>)
   d703e:	bd38      	pop	{r3, r4, r5, pc}
   d7040:	2003e390 	.word	0x2003e390
   d7044:	2003e394 	.word	0x2003e394
   d7048:	2003e30c 	.word	0x2003e30c
   d704c:	2003e2f8 	.word	0x2003e2f8
   d7050:	20034a40 	.word	0x20034a40
   d7054:	000d6f41 	.word	0x000d6f41

000d7058 <_ZN7TwoWireD1Ev>:
private:
  HAL_I2C_Interface _i2c;

public:
  TwoWire(HAL_I2C_Interface i2c, const HAL_I2C_Config& config);
  virtual ~TwoWire() {};
   d7058:	4770      	bx	lr

000d705a <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
   d705a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   d705c:	4606      	mov	r6, r0
   d705e:	4615      	mov	r5, r2
   d7060:	460c      	mov	r4, r1
   d7062:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
   d7064:	42bc      	cmp	r4, r7
   d7066:	d006      	beq.n	d7076 <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
   d7068:	6833      	ldr	r3, [r6, #0]
   d706a:	f814 1b01 	ldrb.w	r1, [r4], #1
   d706e:	689b      	ldr	r3, [r3, #8]
   d7070:	4630      	mov	r0, r6
   d7072:	4798      	blx	r3
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
   d7074:	e7f6      	b.n	d7064 <_ZN7TwoWire5writeEPKhj+0xa>
  {
    write(data[i]);
  }

  return quantity;
}
   d7076:	4628      	mov	r0, r5
   d7078:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000d707a <_ZN7TwoWire5writeEh>:
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
  return HAL_I2C_Write_Data(_i2c, data, NULL);
   d707a:	2200      	movs	r2, #0
   d707c:	7c00      	ldrb	r0, [r0, #16]
   d707e:	f7fe be9d 	b.w	d5dbc <HAL_I2C_Write_Data>

000d7082 <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return HAL_I2C_Available_Data(_i2c, NULL);
   d7082:	2100      	movs	r1, #0
   d7084:	7c00      	ldrb	r0, [r0, #16]
   d7086:	f7fe bea1 	b.w	d5dcc <HAL_I2C_Available_Data>

000d708a <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return HAL_I2C_Read_Data(_i2c, NULL);
   d708a:	2100      	movs	r1, #0
   d708c:	7c00      	ldrb	r0, [r0, #16]
   d708e:	f7fe bea5 	b.w	d5ddc <HAL_I2C_Read_Data>

000d7092 <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return HAL_I2C_Peek_Data(_i2c, NULL);
   d7092:	2100      	movs	r1, #0
   d7094:	7c00      	ldrb	r0, [r0, #16]
   d7096:	f7fe bea9 	b.w	d5dec <HAL_I2C_Peek_Data>

000d709a <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  HAL_I2C_Flush_Data(_i2c, NULL);
   d709a:	2100      	movs	r1, #0
   d709c:	7c00      	ldrb	r0, [r0, #16]
   d709e:	f7fe bead 	b.w	d5dfc <HAL_I2C_Flush_Data>

000d70a2 <_ZN7TwoWireD0Ev>:
   d70a2:	b510      	push	{r4, lr}
   d70a4:	2114      	movs	r1, #20
   d70a6:	4604      	mov	r4, r0
   d70a8:	f000 fd2e 	bl	d7b08 <_ZdlPvj>
   d70ac:	4620      	mov	r0, r4
   d70ae:	bd10      	pop	{r4, pc}

000d70b0 <_ZN7TwoWireC1E17HAL_I2C_InterfaceRK14HAL_I2C_Config>:
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c, const HAL_I2C_Config& conf)
   d70b0:	b510      	push	{r4, lr}
   d70b2:	4604      	mov	r4, r0
   d70b4:	2300      	movs	r3, #0
   d70b6:	6063      	str	r3, [r4, #4]
   d70b8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   d70bc:	60a3      	str	r3, [r4, #8]
   d70be:	4b04      	ldr	r3, [pc, #16]	; (d70d0 <_ZN7TwoWireC1E17HAL_I2C_InterfaceRK14HAL_I2C_Config+0x20>)
{
  _i2c = i2c;
   d70c0:	7421      	strb	r1, [r4, #16]
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c, const HAL_I2C_Config& conf)
   d70c2:	4608      	mov	r0, r1
   d70c4:	6023      	str	r3, [r4, #0]
{
  _i2c = i2c;
  HAL_I2C_Init(_i2c, &conf);
   d70c6:	4611      	mov	r1, r2
   d70c8:	f7fe fea8 	bl	d5e1c <HAL_I2C_Init>
}
   d70cc:	4620      	mov	r0, r4
   d70ce:	bd10      	pop	{r4, pc}
   d70d0:	000da84c 	.word	0x000da84c

000d70d4 <_ZN7TwoWire9isEnabledEv>:
  HAL_I2C_Set_Callback_On_Request(_i2c, function, NULL);
}

bool TwoWire::isEnabled()
{
  return HAL_I2C_Is_Enabled(_i2c, NULL);
   d70d4:	2100      	movs	r1, #0
   d70d6:	7c00      	ldrb	r0, [r0, #16]
   d70d8:	f7fe be98 	b.w	d5e0c <HAL_I2C_Is_Enabled>

000d70dc <_ZN5spark9MeshClass9listeningEv>:
    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
    }

    bool listening(void) {
        return network_listening(*this, 0, NULL);
   d70dc:	2200      	movs	r2, #0
   d70de:	4611      	mov	r1, r2
   d70e0:	6840      	ldr	r0, [r0, #4]
   d70e2:	f7fe bfb7 	b.w	d6054 <network_listening>

000d70e6 <_ZN5spark9MeshClass16getListenTimeoutEv>:
    void setListenTimeout(uint16_t timeout) {
        network_set_listen_timeout(*this, timeout, NULL);
    }

    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
   d70e6:	2200      	movs	r2, #0
   d70e8:	4611      	mov	r1, r2
   d70ea:	6840      	ldr	r0, [r0, #4]
   d70ec:	f7fe bfc2 	b.w	d6074 <network_get_listen_timeout>

000d70f0 <_ZN5spark9MeshClass16setListenTimeoutEt>:
    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
    }

    void setListenTimeout(uint16_t timeout) {
        network_set_listen_timeout(*this, timeout, NULL);
   d70f0:	2200      	movs	r2, #0
   d70f2:	6840      	ldr	r0, [r0, #4]
   d70f4:	f7fe bfb6 	b.w	d6064 <network_set_listen_timeout>

000d70f8 <_ZN5spark9MeshClass6listenEb>:
    void disconnect() {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
    }

    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
   d70f8:	2200      	movs	r2, #0
   d70fa:	f081 0101 	eor.w	r1, r1, #1
   d70fe:	6840      	ldr	r0, [r0, #4]
   d7100:	f7fe bfa0 	b.w	d6044 <network_listen>

000d7104 <_ZN5spark9MeshClass3offEv>:
    void on() {
        network_on(*this, 0, 0, NULL);
    }

    void off() {
        network_off(*this, 1, 0, NULL);
   d7104:	2300      	movs	r3, #0
   d7106:	461a      	mov	r2, r3
   d7108:	2101      	movs	r1, #1
   d710a:	6840      	ldr	r0, [r0, #4]
   d710c:	f7fe bf92 	b.w	d6034 <network_off>

000d7110 <_ZN5spark9MeshClass2onEv>:
    MeshClass() :
            NetworkClass(NETWORK_INTERFACE_MESH) {
    }

    void on() {
        network_on(*this, 0, 0, NULL);
   d7110:	2300      	movs	r3, #0
   d7112:	461a      	mov	r2, r3
   d7114:	4619      	mov	r1, r3
   d7116:	6840      	ldr	r0, [r0, #4]
   d7118:	f7fe bf84 	b.w	d6024 <network_on>

000d711c <_ZN5spark9MeshClass5readyEv>:
    bool listening(void) {
        return network_listening(*this, 0, NULL);
    }

    bool ready() {
        return network_ready(*this, 0,  NULL);
   d711c:	2200      	movs	r2, #0
   d711e:	4611      	mov	r1, r2
   d7120:	6840      	ldr	r0, [r0, #4]
   d7122:	f7fe bf77 	b.w	d6014 <network_ready>

000d7126 <_ZN5spark9MeshClass10connectingEv>:
    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
    }

    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
   d7126:	2200      	movs	r2, #0
   d7128:	4611      	mov	r1, r2
   d712a:	6840      	ldr	r0, [r0, #4]
   d712c:	f7fe bf62 	b.w	d5ff4 <network_connecting>

000d7130 <_ZN5spark9MeshClass10disconnectEv>:
    }

    void disconnect() {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
   d7130:	2200      	movs	r2, #0
   d7132:	2102      	movs	r1, #2
   d7134:	6840      	ldr	r0, [r0, #4]
   d7136:	f7fe bf65 	b.w	d6004 <network_disconnect>

000d713a <_ZN5spark9MeshClass7connectEj>:
    void off() {
        network_off(*this, 1, 0, NULL);
    }

    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
   d713a:	2300      	movs	r3, #0
   d713c:	461a      	mov	r2, r3
   d713e:	6840      	ldr	r0, [r0, #4]
   d7140:	f7fe bf50 	b.w	d5fe4 <network_connect>

000d7144 <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.6>:
	       enable_if<is_convertible<_Up*, _Tp*>::value>::type>
        default_delete(const default_delete<_Up>&) noexcept { }

      /// Calls @c delete @p __ptr
      void
      operator()(_Tp* __ptr) const
   d7144:	b538      	push	{r3, r4, r5, lr}
      {
	static_assert(!is_void<_Tp>::value,
		      "can't delete pointer to incomplete type");
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
   d7146:	4605      	mov	r5, r0
   d7148:	b188      	cbz	r0, d716e <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.6+0x2a>

      /// Destructor, invokes the deleter if the stored pointer is not null.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
   d714a:	6804      	ldr	r4, [r0, #0]
   d714c:	b14c      	cbz	r4, d7162 <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.6+0x1e>

    ~_Function_base()
    {
      if (_M_manager)
   d714e:	68a3      	ldr	r3, [r4, #8]
   d7150:	b11b      	cbz	r3, d715a <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.6+0x16>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
   d7152:	2203      	movs	r2, #3
   d7154:	4621      	mov	r1, r4
   d7156:	4620      	mov	r0, r4
   d7158:	4798      	blx	r3
      {
	static_assert(!is_void<_Tp>::value,
		      "can't delete pointer to incomplete type");
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
   d715a:	2110      	movs	r1, #16
   d715c:	4620      	mov	r0, r4
   d715e:	f000 fcd3 	bl	d7b08 <_ZdlPvj>
   d7162:	4628      	mov	r0, r5
   d7164:	2114      	movs	r1, #20
      }
   d7166:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      {
	static_assert(!is_void<_Tp>::value,
		      "can't delete pointer to incomplete type");
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
   d716a:	f000 bccd 	b.w	d7b08 <_ZdlPvj>
   d716e:	bd38      	pop	{r3, r4, r5, pc}

000d7170 <_ZNKSt14default_deleteI3UDPEclEPS0_.isra.8.constprop.13>:
   d7170:	b110      	cbz	r0, d7178 <_ZNKSt14default_deleteI3UDPEclEPS0_.isra.8.constprop.13+0x8>
   d7172:	6803      	ldr	r3, [r0, #0]
   d7174:	685b      	ldr	r3, [r3, #4]
   d7176:	4718      	bx	r3
   d7178:	4770      	bx	lr

000d717a <_ZN6ThreadD1Ev>:
    Thread(Thread&& thread)
        : d_(std::move(thread.d_))
    {
    }

    ~Thread()
   d717a:	b510      	push	{r4, lr}
      }

      /// Return the stored pointer.
      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }
   d717c:	6803      	ldr	r3, [r0, #0]
   d717e:	4604      	mov	r4, r0
        dispose();
    }

    void dispose()
    {
        if (!isValid())
   d7180:	b1bb      	cbz	r3, d71b2 <_ZN6ThreadD1Ev+0x38>
        return isCurrent();
    }

    bool isCurrent() const
    {
        return isValid() && os_thread_is_current(d_->handle);
   d7182:	6858      	ldr	r0, [r3, #4]
   d7184:	f7fe fd82 	bl	d5c8c <os_thread_is_current>
   d7188:	b978      	cbnz	r0, d71aa <_ZN6ThreadD1Ev+0x30>
   d718a:	6823      	ldr	r3, [r4, #0]

        // We shouldn't dispose of current thread
        if (isCurrent())
            return;

        if (!d_->exited) {
   d718c:	7c5a      	ldrb	r2, [r3, #17]
   d718e:	b912      	cbnz	r2, d7196 <_ZN6ThreadD1Ev+0x1c>
        d_.reset();
    }

    bool join()
    {
        return isValid() && os_thread_join(d_->handle)==0;
   d7190:	6858      	ldr	r0, [r3, #4]
   d7192:	f7fe fd83 	bl	d5c9c <os_thread_join>

        if (!d_->exited) {
            join();
        }

        os_thread_cleanup(d_->handle);
   d7196:	6823      	ldr	r3, [r4, #0]
   d7198:	6858      	ldr	r0, [r3, #4]
   d719a:	f7fe fd87 	bl	d5cac <os_thread_cleanup>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
   d719e:	6820      	ldr	r0, [r4, #0]
      __a = _GLIBCXX_MOVE(__b);
   d71a0:	2300      	movs	r3, #0
   d71a2:	6023      	str	r3, [r4, #0]
      void
      reset(pointer __p = pointer()) noexcept
      {
	using std::swap;
	swap(std::get<0>(_M_t), __p);
	if (__p != pointer())
   d71a4:	b128      	cbz	r0, d71b2 <_ZN6ThreadD1Ev+0x38>
	  get_deleter()(__p);
   d71a6:	f7ff ffcd 	bl	d7144 <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.6>

      /// Destructor, invokes the deleter if the stored pointer is not null.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
   d71aa:	6820      	ldr	r0, [r4, #0]
   d71ac:	b108      	cbz	r0, d71b2 <_ZN6ThreadD1Ev+0x38>
	  get_deleter()(__ptr);
   d71ae:	f7ff ffc9 	bl	d7144 <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.6>
    }

    ~Thread()
    {
        dispose();
    }
   d71b2:	4620      	mov	r0, r4
   d71b4:	bd10      	pop	{r4, pc}

000d71b6 <_ZN5spark11MeshPublishD1Ev>:
    virtual float getQualityValue() const {
        return 0.0f;
    }
};

class MeshPublish {
   d71b6:	b538      	push	{r3, r4, r5, lr}
   d71b8:	4604      	mov	r4, r0

      /// Destructor, invokes the deleter if the stored pointer is not null.
      ~unique_ptr()
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
   d71ba:	f8d0 01c4 	ldr.w	r0, [r0, #452]	; 0x1c4
   d71be:	b108      	cbz	r0, d71c4 <_ZN5spark11MeshPublishD1Ev+0xe>
      void
      operator()(_Tp* __ptr) const
      {
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete [] __ptr;
   d71c0:	f7fc ff6d 	bl	d409e <_ZdaPv>
        dispose();
    }

    void dispose()
    {
        if (handle_) {
   d71c4:	f8d4 01c0 	ldr.w	r0, [r4, #448]	; 0x1c0
   d71c8:	b108      	cbz	r0, d71ce <_ZN5spark11MeshPublishD1Ev+0x18>
            os_mutex_recursive_destroy(handle_);
   d71ca:	f7fe fd87 	bl	d5cdc <os_mutex_recursive_destroy>

      /// Destructor, invokes the deleter if the stored pointer is not null.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
   d71ce:	f8d4 51bc 	ldr.w	r5, [r4, #444]	; 0x1bc
   d71d2:	b135      	cbz	r5, d71e2 <_ZN5spark11MeshPublishD1Ev+0x2c>
      {
	static_assert(!is_void<_Tp>::value,
		      "can't delete pointer to incomplete type");
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
   d71d4:	4628      	mov	r0, r5
   d71d6:	f7ff ffd0 	bl	d717a <_ZN6ThreadD1Ev>
   d71da:	2104      	movs	r1, #4
   d71dc:	4628      	mov	r0, r5
   d71de:	f000 fc93 	bl	d7b08 <_ZdlPvj>

      /// Destructor, invokes the deleter if the stored pointer is not null.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
   d71e2:	6820      	ldr	r0, [r4, #0]
   d71e4:	b108      	cbz	r0, d71ea <_ZN5spark11MeshPublishD1Ev+0x34>
	  get_deleter()(__ptr);
   d71e6:	f7ff ffc3 	bl	d7170 <_ZNKSt14default_deleteI3UDPEclEPS0_.isra.8.constprop.13>
   d71ea:	4620      	mov	r0, r4
   d71ec:	bd38      	pop	{r3, r4, r5, pc}
	...

000d71f0 <_ZN5spark9MeshClassD1Ev>:
    RecursiveMutex mutex_;
    std::unique_ptr<uint8_t[]> buffer_;
    std::atomic_bool exit_;
};

class MeshClass : public NetworkClass, public MeshPublish {
   d71f0:	b510      	push	{r4, lr}
   d71f2:	4b04      	ldr	r3, [pc, #16]	; (d7204 <_ZN5spark9MeshClassD1Ev+0x14>)
   d71f4:	4604      	mov	r4, r0
   d71f6:	f840 3b08 	str.w	r3, [r0], #8
   d71fa:	f7ff ffdc 	bl	d71b6 <_ZN5spark11MeshPublishD1Ev>
   d71fe:	4620      	mov	r0, r4
   d7200:	bd10      	pop	{r4, pc}
   d7202:	bf00      	nop
   d7204:	000da874 	.word	0x000da874

000d7208 <_GLOBAL__sub_I__ZN5spark11MeshPublish13Subscriptions20event_handler_existsEPKcPFvS3_S3_EPvN17SubscriptionScope4EnumES3_>:

    return addr;
}

MeshClass Mesh;
} // namespace spark
   d7208:	b538      	push	{r3, r4, r5, lr}
   d720a:	4c0e      	ldr	r4, [pc, #56]	; (d7244 <_GLOBAL__sub_I__ZN5spark11MeshPublish13Subscriptions20event_handler_existsEPKcPFvS3_S3_EPvN17SubscriptionScope4EnumES3_+0x3c>)
   d720c:	4b0e      	ldr	r3, [pc, #56]	; (d7248 <_GLOBAL__sub_I__ZN5spark11MeshPublish13Subscriptions20event_handler_existsEPKcPFvS3_S3_EPvN17SubscriptionScope4EnumES3_+0x40>)
   d720e:	6023      	str	r3, [r4, #0]

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }
   d7210:	2500      	movs	r5, #0
   d7212:	2302      	movs	r3, #2
     */
    RecursiveMutex(os_mutex_recursive_t handle) : handle_(handle) {}

    RecursiveMutex() : handle_(nullptr)
    {
        os_mutex_recursive_create(&handle_);
   d7214:	f504 70e4 	add.w	r0, r4, #456	; 0x1c8
   d7218:	6063      	str	r3, [r4, #4]
   d721a:	60a5      	str	r5, [r4, #8]
   d721c:	f8c4 51c4 	str.w	r5, [r4, #452]	; 0x1c4
    /**
     * Creates a shared mutex.
     */
    RecursiveMutex(os_mutex_recursive_t handle) : handle_(handle) {}

    RecursiveMutex() : handle_(nullptr)
   d7220:	f8c4 51c8 	str.w	r5, [r4, #456]	; 0x1c8
    {
        os_mutex_recursive_create(&handle_);
   d7224:	f7fe fd52 	bl	d5ccc <os_mutex_recursive_create>
public:
    MeshClass() :
            NetworkClass(NETWORK_INTERFACE_MESH) {
   d7228:	4b08      	ldr	r3, [pc, #32]	; (d724c <_GLOBAL__sub_I__ZN5spark11MeshPublish13Subscriptions20event_handler_existsEPKcPFvS3_S3_EPvN17SubscriptionScope4EnumES3_+0x44>)
   d722a:	f8c4 51cc 	str.w	r5, [r4, #460]	; 0x1cc
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;

      // Requires __int_type convertible to _M_i.
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
   d722e:	f884 51d0 	strb.w	r5, [r4, #464]	; 0x1d0
   d7232:	6023      	str	r3, [r4, #0]
    }

    return addr;
}

MeshClass Mesh;
   d7234:	4620      	mov	r0, r4
   d7236:	4a06      	ldr	r2, [pc, #24]	; (d7250 <_GLOBAL__sub_I__ZN5spark11MeshPublish13Subscriptions20event_handler_existsEPKcPFvS3_S3_EPvN17SubscriptionScope4EnumES3_+0x48>)
   d7238:	4906      	ldr	r1, [pc, #24]	; (d7254 <_GLOBAL__sub_I__ZN5spark11MeshPublish13Subscriptions20event_handler_existsEPKcPFvS3_S3_EPvN17SubscriptionScope4EnumES3_+0x4c>)
} // namespace spark
   d723a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    }

    return addr;
}

MeshClass Mesh;
   d723e:	f000 bc55 	b.w	d7aec <__aeabi_atexit>
   d7242:	bf00      	nop
   d7244:	2003e418 	.word	0x2003e418
   d7248:	000da95c 	.word	0x000da95c
   d724c:	000da874 	.word	0x000da874
   d7250:	20034a40 	.word	0x20034a40
   d7254:	000d71f1 	.word	0x000d71f1

000d7258 <_ZN9TCPClient5writeEh>:
    done.dismiss();

    return 1; // success
}

size_t TCPClient::write(uint8_t b) {
   d7258:	b537      	push	{r0, r1, r2, r4, r5, lr}
   d725a:	ac02      	add	r4, sp, #8
    return write(&b, 1, SOCKET_WAIT_FOREVER);
   d725c:	6803      	ldr	r3, [r0, #0]
    done.dismiss();

    return 1; // success
}

size_t TCPClient::write(uint8_t b) {
   d725e:	f804 1d01 	strb.w	r1, [r4, #-1]!
    return write(&b, 1, SOCKET_WAIT_FOREVER);
   d7262:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
   d7264:	2201      	movs	r2, #1
   d7266:	f04f 33ff 	mov.w	r3, #4294967295
   d726a:	4621      	mov	r1, r4
   d726c:	47a8      	blx	r5
}
   d726e:	b003      	add	sp, #12
   d7270:	bd30      	pop	{r4, r5, pc}

000d7272 <_ZN9TCPClient5writeEPKhj>:

size_t TCPClient::write(const uint8_t *buffer, size_t size) {
   d7272:	b410      	push	{r4}
    return write(buffer, size, SOCKET_WAIT_FOREVER);
   d7274:	6803      	ldr	r3, [r0, #0]
   d7276:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
   d7278:	f04f 33ff 	mov.w	r3, #4294967295
   d727c:	46a4      	mov	ip, r4
}
   d727e:	f85d 4b04 	ldr.w	r4, [sp], #4
size_t TCPClient::write(uint8_t b) {
    return write(&b, 1, SOCKET_WAIT_FOREVER);
}

size_t TCPClient::write(const uint8_t *buffer, size_t size) {
    return write(buffer, size, SOCKET_WAIT_FOREVER);
   d7282:	4760      	bx	ip

000d7284 <_ZN9TCPClient5writeEhm>:
}

size_t TCPClient::write(uint8_t b, system_tick_t timeout) {
   d7284:	b537      	push	{r0, r1, r2, r4, r5, lr}
   d7286:	ac02      	add	r4, sp, #8
    return write(&b, 1, timeout);
   d7288:	6803      	ldr	r3, [r0, #0]

size_t TCPClient::write(const uint8_t *buffer, size_t size) {
    return write(buffer, size, SOCKET_WAIT_FOREVER);
}

size_t TCPClient::write(uint8_t b, system_tick_t timeout) {
   d728a:	f804 1d01 	strb.w	r1, [r4, #-1]!
    return write(&b, 1, timeout);
   d728e:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
   d7290:	4621      	mov	r1, r4
   d7292:	4613      	mov	r3, r2
   d7294:	2201      	movs	r2, #1
   d7296:	47a8      	blx	r5
}
   d7298:	b003      	add	sp, #12
   d729a:	bd30      	pop	{r4, r5, pc}

000d729c <_ZN9TCPClient5flushEv>:
void TCPClient::flush_buffer() {
    d_->offset = 0;
    d_->total = 0;
}

void TCPClient::flush() {
   d729c:	4770      	bx	lr

000d729e <_ZN9TCPClient9connectedEv>:
    d_->sock = -1;
    d_->remoteIP.clear();
    flush_buffer();
}

uint8_t TCPClient::connected() {
   d729e:	b538      	push	{r3, r4, r5, lr}
   d72a0:	6943      	ldr	r3, [r0, #20]
    bool rv = (status() || bufferCount());
   d72a2:	681a      	ldr	r2, [r3, #0]
   d72a4:	2a00      	cmp	r2, #0
    d_->sock = -1;
    d_->remoteIP.clear();
    flush_buffer();
}

uint8_t TCPClient::connected() {
   d72a6:	4604      	mov	r4, r0
    bool rv = (status() || bufferCount());
   d72a8:	da05      	bge.n	d72b6 <_ZN9TCPClient9connectedEv+0x18>
   d72aa:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
   d72ae:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
   d72b2:	429a      	cmp	r2, r3
   d72b4:	d001      	beq.n	d72ba <_ZN9TCPClient9connectedEv+0x1c>
   d72b6:	2501      	movs	r5, #1
   d72b8:	e00b      	b.n	d72d2 <_ZN9TCPClient9connectedEv+0x34>
    if (!rv) {
        rv = available();
   d72ba:	6803      	ldr	r3, [r0, #0]
   d72bc:	691b      	ldr	r3, [r3, #16]
   d72be:	4798      	blx	r3
   d72c0:	2800      	cmp	r0, #0
   d72c2:	bf14      	ite	ne
   d72c4:	2501      	movne	r5, #1
   d72c6:	2500      	moveq	r5, #0
        if (!rv) {
   d72c8:	d103      	bne.n	d72d2 <_ZN9TCPClient9connectedEv+0x34>
            stop();
   d72ca:	6823      	ldr	r3, [r4, #0]
   d72cc:	4620      	mov	r0, r4
   d72ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   d72d0:	4798      	blx	r3
        }
    }
    return rv;
}
   d72d2:	4628      	mov	r0, r5
   d72d4:	bd38      	pop	{r3, r4, r5, pc}

000d72d6 <_ZN9TCPClientcvbEv>:

uint8_t TCPClient::status() {
    return (isOpen(d_->sock));
   d72d6:	6943      	ldr	r3, [r0, #20]
}

TCPClient::operator bool() {
   return (status() != 0);
   d72d8:	6818      	ldr	r0, [r3, #0]
}
   d72da:	43c0      	mvns	r0, r0
   d72dc:	0fc0      	lsrs	r0, r0, #31
   d72de:	4770      	bx	lr

000d72e0 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EED1Ev>:

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }
   d72e0:	4770      	bx	lr

000d72e2 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE14_M_get_deleterERKSt9type_info>:
	  ? std::__addressof(_M_impl._M_del())
	  : nullptr;
#else
        return nullptr;
#endif
      }
   d72e2:	2000      	movs	r0, #0
   d72e4:	4770      	bx	lr

000d72e6 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EED0Ev>:

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }
   d72e6:	b510      	push	{r4, lr}
   d72e8:	2114      	movs	r1, #20
   d72ea:	4604      	mov	r4, r0
   d72ec:	f000 fc0c 	bl	d7b08 <_ZdlPvj>
   d72f0:	4620      	mov	r0, r4
   d72f2:	bd10      	pop	{r4, pc}

000d72f4 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_destroyEv>:
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
   d72f4:	f7fc bed1 	b.w	d409a <_ZdlPv>

000d72f8 <_ZN9TCPClient5writeEPKhjm>:

size_t TCPClient::write(uint8_t b, system_tick_t timeout) {
    return write(&b, 1, timeout);
}

size_t TCPClient::write(const uint8_t *buffer, size_t size, system_tick_t timeout) {
   d72f8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   d72fa:	4616      	mov	r6, r2

    size_t printNumber(unsigned long, uint8_t);
    size_t printNumber(unsigned long long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
   d72fc:	2200      	movs	r2, #0
   d72fe:	6042      	str	r2, [r0, #4]
    clearWriteError();
    struct timeval tv = {};
   d7300:	9202      	str	r2, [sp, #8]
   d7302:	9203      	str	r2, [sp, #12]
    if (timeout != SOCKET_WAIT_FOREVER) {
   d7304:	1c5a      	adds	r2, r3, #1

size_t TCPClient::write(uint8_t b, system_tick_t timeout) {
    return write(&b, 1, timeout);
}

size_t TCPClient::write(const uint8_t *buffer, size_t size, system_tick_t timeout) {
   d7306:	4604      	mov	r4, r0
   d7308:	460d      	mov	r5, r1
    clearWriteError();
    struct timeval tv = {};
    if (timeout != SOCKET_WAIT_FOREVER) {
   d730a:	d008      	beq.n	d731e <_ZN9TCPClient5writeEPKhjm+0x26>
        tv.tv_sec = timeout / 1000;
   d730c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   d7310:	fbb3 f1f2 	udiv	r1, r3, r2
   d7314:	9102      	str	r1, [sp, #8]
        tv.tv_usec = (timeout % 1000) * 1000;
   d7316:	fb02 3111 	mls	r1, r2, r1, r3
   d731a:	434a      	muls	r2, r1
   d731c:	9203      	str	r2, [sp, #12]
    }
    int ret = sock_setsockopt(d_->sock, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
   d731e:	6960      	ldr	r0, [r4, #20]
   d7320:	2308      	movs	r3, #8
   d7322:	9300      	str	r3, [sp, #0]
   d7324:	f241 0205 	movw	r2, #4101	; 0x1005
   d7328:	446b      	add	r3, sp
   d732a:	f640 71ff 	movw	r1, #4095	; 0xfff
   d732e:	6800      	ldr	r0, [r0, #0]
   d7330:	f7fe fd94 	bl	d5e5c <sock_setsockopt>
    if (ret < 0) {
   d7334:	2800      	cmp	r0, #0
   d7336:	db08      	blt.n	d734a <_ZN9TCPClient5writeEPKhjm+0x52>
        setWriteError(errno);
        return 0;
    }

    ret = sock_send(d_->sock, buffer, size, 0);
   d7338:	6960      	ldr	r0, [r4, #20]
   d733a:	2300      	movs	r3, #0
   d733c:	4632      	mov	r2, r6
   d733e:	4629      	mov	r1, r5
   d7340:	6800      	ldr	r0, [r0, #0]
   d7342:	f7fe fdb3 	bl	d5eac <sock_send>
    if (ret < 0) {
   d7346:	2800      	cmp	r0, #0
   d7348:	da04      	bge.n	d7354 <_ZN9TCPClient5writeEPKhjm+0x5c>
        setWriteError(errno);
   d734a:	f7fe ff13 	bl	d6174 <__errno>
   d734e:	6803      	ldr	r3, [r0, #0]
   d7350:	6063      	str	r3, [r4, #4]
   d7352:	2000      	movs	r0, #0
        return 0;
    }

    return ret;
}
   d7354:	b004      	add	sp, #16
   d7356:	bd70      	pop	{r4, r5, r6, pc}

000d7358 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.4.constprop.31>:
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
   d7358:	b510      	push	{r4, lr}
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
   d735a:	6803      	ldr	r3, [r0, #0]
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
   d735c:	4604      	mov	r4, r0
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
   d735e:	689b      	ldr	r3, [r3, #8]
   d7360:	4798      	blx	r3
          if (--_M_weak_count == 0)
   d7362:	68a3      	ldr	r3, [r4, #8]
   d7364:	3b01      	subs	r3, #1
   d7366:	60a3      	str	r3, [r4, #8]
   d7368:	b92b      	cbnz	r3, d7376 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.4.constprop.31+0x1e>
            _M_destroy();
   d736a:	6823      	ldr	r3, [r4, #0]
   d736c:	4620      	mov	r0, r4
   d736e:	68db      	ldr	r3, [r3, #12]
        }
    }
   d7370:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
   d7374:	4718      	bx	r3
   d7376:	bd10      	pop	{r4, pc}

000d7378 <_ZN9TCPClient8remoteIPEv>:

TCPClient::operator bool() {
   return (status() != 0);
}

IPAddress TCPClient::remoteIP() {
   d7378:	b570      	push	{r4, r5, r6, lr}

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
   d737a:	4604      	mov	r4, r0
   d737c:	694d      	ldr	r5, [r1, #20]
   d737e:	4b05      	ldr	r3, [pc, #20]	; (d7394 <_ZN9TCPClient8remoteIPEv+0x1c>)
   d7380:	f844 3b04 	str.w	r3, [r4], #4
   d7384:	358c      	adds	r5, #140	; 0x8c
   d7386:	4606      	mov	r6, r0
   d7388:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   d738a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   d738c:	682b      	ldr	r3, [r5, #0]
   d738e:	7023      	strb	r3, [r4, #0]
    return d_->remoteIP;
}
   d7390:	4630      	mov	r0, r6
   d7392:	bd70      	pop	{r4, r5, r6, pc}
   d7394:	000da7d8 	.word	0x000da7d8

000d7398 <_ZN9TCPClient4peekEv>:
        d_->offset += read;
    }
    return read;
}

int TCPClient::peek() {
   d7398:	b510      	push	{r4, lr}
   d739a:	6943      	ldr	r3, [r0, #20]
    return (bufferCount() || available()) ? d_->buffer[d_->offset] : -1;
   d739c:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
   d73a0:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
   d73a4:	429a      	cmp	r2, r3
        d_->offset += read;
    }
    return read;
}

int TCPClient::peek() {
   d73a6:	4604      	mov	r4, r0
    return (bufferCount() || available()) ? d_->buffer[d_->offset] : -1;
   d73a8:	d005      	beq.n	d73b6 <_ZN9TCPClient4peekEv+0x1e>
   d73aa:	6962      	ldr	r2, [r4, #20]
   d73ac:	f8b2 3084 	ldrh.w	r3, [r2, #132]	; 0x84
   d73b0:	4413      	add	r3, r2
   d73b2:	7918      	ldrb	r0, [r3, #4]
   d73b4:	bd10      	pop	{r4, pc}
   d73b6:	6803      	ldr	r3, [r0, #0]
   d73b8:	691b      	ldr	r3, [r3, #16]
   d73ba:	4798      	blx	r3
   d73bc:	2800      	cmp	r0, #0
   d73be:	d1f4      	bne.n	d73aa <_ZN9TCPClient4peekEv+0x12>
   d73c0:	f04f 30ff 	mov.w	r0, #4294967295
}
   d73c4:	bd10      	pop	{r4, pc}

000d73c6 <_ZN9TCPClient4readEv>:
    } // isOpen(d_->sock)
    avail = bufferCount();
    return avail;
}

int TCPClient::read() {
   d73c6:	b510      	push	{r4, lr}
   d73c8:	6943      	ldr	r3, [r0, #20]
    return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
   d73ca:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
   d73ce:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
   d73d2:	429a      	cmp	r2, r3
    } // isOpen(d_->sock)
    avail = bufferCount();
    return avail;
}

int TCPClient::read() {
   d73d4:	4604      	mov	r4, r0
    return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
   d73d6:	d008      	beq.n	d73ea <_ZN9TCPClient4readEv+0x24>
   d73d8:	6962      	ldr	r2, [r4, #20]
   d73da:	f8b2 3084 	ldrh.w	r3, [r2, #132]	; 0x84
   d73de:	1c59      	adds	r1, r3, #1
   d73e0:	4413      	add	r3, r2
   d73e2:	f8a2 1084 	strh.w	r1, [r2, #132]	; 0x84
   d73e6:	7918      	ldrb	r0, [r3, #4]
   d73e8:	bd10      	pop	{r4, pc}
   d73ea:	6803      	ldr	r3, [r0, #0]
   d73ec:	691b      	ldr	r3, [r3, #16]
   d73ee:	4798      	blx	r3
   d73f0:	2800      	cmp	r0, #0
   d73f2:	d1f1      	bne.n	d73d8 <_ZN9TCPClient4readEv+0x12>
   d73f4:	f04f 30ff 	mov.w	r0, #4294967295
}
   d73f8:	bd10      	pop	{r4, pc}

000d73fa <_ZN9TCPClient4readEPhj>:

int TCPClient::read(uint8_t *buffer, size_t size) {
   d73fa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   d73fc:	6943      	ldr	r3, [r0, #20]
   d73fe:	4617      	mov	r7, r2
    int read = -1;
    if (bufferCount() || available()) {
   d7400:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
   d7404:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
   d7408:	429a      	cmp	r2, r3

int TCPClient::read() {
    return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
}

int TCPClient::read(uint8_t *buffer, size_t size) {
   d740a:	4605      	mov	r5, r0
   d740c:	460e      	mov	r6, r1
    int read = -1;
    if (bufferCount() || available()) {
   d740e:	d106      	bne.n	d741e <_ZN9TCPClient4readEPhj+0x24>
   d7410:	6803      	ldr	r3, [r0, #0]
   d7412:	691b      	ldr	r3, [r3, #16]
   d7414:	4798      	blx	r3
   d7416:	b910      	cbnz	r0, d741e <_ZN9TCPClient4readEPhj+0x24>
int TCPClient::read() {
    return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
}

int TCPClient::read(uint8_t *buffer, size_t size) {
    int read = -1;
   d7418:	f04f 34ff 	mov.w	r4, #4294967295
   d741c:	e014      	b.n	d7448 <_ZN9TCPClient4readEPhj+0x4e>
   d741e:	6969      	ldr	r1, [r5, #20]

    return ret;
}

int TCPClient::bufferCount() {
    return d_->total - d_->offset;
   d7420:	f8b1 3084 	ldrh.w	r3, [r1, #132]	; 0x84
   d7424:	f8b1 4086 	ldrh.w	r4, [r1, #134]	; 0x86
   d7428:	1ae4      	subs	r4, r4, r3
}

int TCPClient::read(uint8_t *buffer, size_t size) {
    int read = -1;
    if (bufferCount() || available()) {
        read = (size > (size_t) bufferCount()) ? bufferCount() : size;
   d742a:	42bc      	cmp	r4, r7
   d742c:	bf28      	it	cs
   d742e:	463c      	movcs	r4, r7
        memcpy(buffer, &d_->buffer[d_->offset], read);
   d7430:	4419      	add	r1, r3
   d7432:	4622      	mov	r2, r4
   d7434:	3104      	adds	r1, #4
   d7436:	4630      	mov	r0, r6
   d7438:	f000 fe08 	bl	d804c <memcpy>
   d743c:	696a      	ldr	r2, [r5, #20]
        d_->offset += read;
   d743e:	f8b2 3084 	ldrh.w	r3, [r2, #132]	; 0x84
   d7442:	4423      	add	r3, r4
   d7444:	f8a2 3084 	strh.w	r3, [r2, #132]	; 0x84
    }
    return read;
}
   d7448:	4620      	mov	r0, r4
   d744a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000d744c <_ZN9TCPClient7connectEPKctm>:
        : d_(std::make_shared<Data>(sock)) {
    flush_buffer();
}

// return 0 on error, 1 on success
int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif) {
   d744c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   d7450:	4698      	mov	r8, r3
    stop();
   d7452:	6803      	ldr	r3, [r0, #0]
        : d_(std::make_shared<Data>(sock)) {
    flush_buffer();
}

// return 0 on error, 1 on success
int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif) {
   d7454:	b093      	sub	sp, #76	; 0x4c
    stop();
   d7456:	6adb      	ldr	r3, [r3, #44]	; 0x2c
        : d_(std::make_shared<Data>(sock)) {
    flush_buffer();
}

// return 0 on error, 1 on success
int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif) {
   d7458:	460d      	mov	r5, r1
   d745a:	4606      	mov	r6, r0
   d745c:	4617      	mov	r7, r2
    stop();
   d745e:	4798      	blx	r3

    struct addrinfo* ais = nullptr;
   d7460:	ab12      	add	r3, sp, #72	; 0x48
   d7462:	2400      	movs	r4, #0
   d7464:	f843 4d48 	str.w	r4, [r3, #-72]!
    SCOPE_GUARD({
        netdb_freeaddrinfo(ais);
    });
    CHECK_TRUE(netdb_getaddrinfo(host, nullptr, nullptr, &ais) == 0, 0); // return 0
   d7468:	4622      	mov	r2, r4
   d746a:	4621      	mov	r1, r4
   d746c:	4628      	mov	r0, r5
   d746e:	f7fe fba5 	bl	d5bbc <netdb_getaddrinfo>
   d7472:	4681      	mov	r9, r0
   d7474:	2800      	cmp	r0, #0
   d7476:	d13d      	bne.n	d74f4 <_ZN9TCPClient7connectEPKctm+0xa8>

    // FIXME: for now using only the first entry
    if (ais && ais->ai_addr) {
   d7478:	9b00      	ldr	r3, [sp, #0]
   d747a:	2b00      	cmp	r3, #0
   d747c:	d056      	beq.n	d752c <_ZN9TCPClient7connectEPKctm+0xe0>
   d747e:	695b      	ldr	r3, [r3, #20]
   d7480:	2b00      	cmp	r3, #0
   d7482:	d053      	beq.n	d752c <_ZN9TCPClient7connectEPKctm+0xe0>
        IPAddress addr;
   d7484:	a806      	add	r0, sp, #24
   d7486:	f7ff fc7b 	bl	d6d80 <_ZN9IPAddressC1Ev>
        detail::sockaddrToIpAddressPort(ais->ai_addr, addr, nullptr);
   d748a:	9b00      	ldr	r3, [sp, #0]
   d748c:	695c      	ldr	r4, [r3, #20]
namespace spark {

namespace detail {

inline void sockaddrToIpAddressPort(const struct sockaddr* saddr, IPAddress& addr, uint16_t* port) {
    if (saddr->sa_family == AF_INET) {
   d748e:	7863      	ldrb	r3, [r4, #1]
   d7490:	2b02      	cmp	r3, #2
   d7492:	d101      	bne.n	d7498 <_ZN9TCPClient7connectEPKctm+0x4c>
        const struct sockaddr_in* inaddr = (const struct sockaddr_in*)saddr;
        addr = (const uint8_t*)(&inaddr->sin_addr.s_addr);
   d7494:	1d21      	adds	r1, r4, #4
   d7496:	e013      	b.n	d74c0 <_ZN9TCPClient7connectEPKctm+0x74>
        if (port) {
            *port = ntohs(inaddr->sin_port);
        }
    }
#if HAL_IPv6
    else if (saddr->sa_family == AF_INET6) {
   d7498:	2b0a      	cmp	r3, #10
   d749a:	d114      	bne.n	d74c6 <_ZN9TCPClient7connectEPKctm+0x7a>
        const struct sockaddr_in6* in6addr = (const struct sockaddr_in6*)saddr;
        HAL_IPAddress a = {};
   d749c:	2211      	movs	r2, #17
   d749e:	4649      	mov	r1, r9
   d74a0:	a801      	add	r0, sp, #4
   d74a2:	f000 fdde 	bl	d8062 <memset>
        if (!IN6_IS_ADDR_V4MAPPED(&in6addr->sin6_addr)) {
   d74a6:	68a3      	ldr	r3, [r4, #8]
   d74a8:	bb33      	cbnz	r3, d74f8 <_ZN9TCPClient7connectEPKctm+0xac>
   d74aa:	68e3      	ldr	r3, [r4, #12]
   d74ac:	bb23      	cbnz	r3, d74f8 <_ZN9TCPClient7connectEPKctm+0xac>
   d74ae:	f64f 70ff 	movw	r0, #65535	; 0xffff
   d74b2:	6925      	ldr	r5, [r4, #16]
   d74b4:	f7fe fc22 	bl	d5cfc <inet_htonl>
   d74b8:	4285      	cmp	r5, r0
   d74ba:	d11d      	bne.n	d74f8 <_ZN9TCPClient7connectEPKctm+0xac>
            memcpy(a.ipv6, in6addr->sin6_addr.s6_addr, sizeof(a.ipv6));
            a.v = 6;
            addr = IPAddress(a);
        } else {
            auto ptr = (const uint32_t*)(in6addr->sin6_addr.s6_addr);
            addr = (const uint8_t*)(&ptr[3]);
   d74bc:	f104 0114 	add.w	r1, r4, #20
   d74c0:	a806      	add	r0, sp, #24
   d74c2:	f7ff fcad 	bl	d6e20 <_ZN9IPAddressaSEPKh>
    operator bool() const;

    // For some reason, without this non-const overload GCC struggles to pick right operator
    // for bool conversion of a non-const object
    operator bool() {
        return static_cast<const IPAddress*>(this)->operator bool();
   d74c6:	a806      	add	r0, sp, #24
   d74c8:	f7ff fc7a 	bl	d6dc0 <_ZNK9IPAddresscvbEv>
        if (addr) {
   d74cc:	2800      	cmp	r0, #0
   d74ce:	d02d      	beq.n	d752c <_ZN9TCPClient7connectEPKctm+0xe0>
            return connect(addr, port, nif);
   d74d0:	6833      	ldr	r3, [r6, #0]

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
   d74d2:	ad07      	add	r5, sp, #28
   d74d4:	f8d3 9020 	ldr.w	r9, [r3, #32]
   d74d8:	4b18      	ldr	r3, [pc, #96]	; (d753c <_ZN9TCPClient7connectEPKctm+0xf0>)
   d74da:	930c      	str	r3, [sp, #48]	; 0x30
   d74dc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   d74de:	ac0d      	add	r4, sp, #52	; 0x34
   d74e0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   d74e2:	682b      	ldr	r3, [r5, #0]
   d74e4:	7023      	strb	r3, [r4, #0]
   d74e6:	463a      	mov	r2, r7
   d74e8:	4643      	mov	r3, r8
   d74ea:	a90c      	add	r1, sp, #48	; 0x30
   d74ec:	4630      	mov	r0, r6
   d74ee:	47c8      	blx	r9
   d74f0:	4681      	mov	r9, r0
   d74f2:	e01b      	b.n	d752c <_ZN9TCPClient7connectEPKctm+0xe0>

    struct addrinfo* ais = nullptr;
    SCOPE_GUARD({
        netdb_freeaddrinfo(ais);
    });
    CHECK_TRUE(netdb_getaddrinfo(host, nullptr, nullptr, &ais) == 0, 0); // return 0
   d74f4:	46a1      	mov	r9, r4
   d74f6:	e019      	b.n	d752c <_ZN9TCPClient7connectEPKctm+0xe0>
#if HAL_IPv6
    else if (saddr->sa_family == AF_INET6) {
        const struct sockaddr_in6* in6addr = (const struct sockaddr_in6*)saddr;
        HAL_IPAddress a = {};
        if (!IN6_IS_ADDR_V4MAPPED(&in6addr->sin6_addr)) {
            memcpy(a.ipv6, in6addr->sin6_addr.s6_addr, sizeof(a.ipv6));
   d74f8:	f104 0308 	add.w	r3, r4, #8
   d74fc:	ad01      	add	r5, sp, #4
   d74fe:	3418      	adds	r4, #24
   d7500:	6818      	ldr	r0, [r3, #0]
   d7502:	6859      	ldr	r1, [r3, #4]
   d7504:	462a      	mov	r2, r5
   d7506:	c203      	stmia	r2!, {r0, r1}
   d7508:	3308      	adds	r3, #8
   d750a:	42a3      	cmp	r3, r4
   d750c:	4615      	mov	r5, r2
   d750e:	d1f7      	bne.n	d7500 <_ZN9TCPClient7connectEPKctm+0xb4>
            a.v = 6;
   d7510:	2306      	movs	r3, #6
            addr = IPAddress(a);
   d7512:	a901      	add	r1, sp, #4
   d7514:	a80c      	add	r0, sp, #48	; 0x30
   d7516:	ad0d      	add	r5, sp, #52	; 0x34
    else if (saddr->sa_family == AF_INET6) {
        const struct sockaddr_in6* in6addr = (const struct sockaddr_in6*)saddr;
        HAL_IPAddress a = {};
        if (!IN6_IS_ADDR_V4MAPPED(&in6addr->sin6_addr)) {
            memcpy(a.ipv6, in6addr->sin6_addr.s6_addr, sizeof(a.ipv6));
            a.v = 6;
   d7518:	f88d 3014 	strb.w	r3, [sp, #20]
            addr = IPAddress(a);
   d751c:	f7ff fc3e 	bl	d6d9c <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
   d7520:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   d7522:	ac07      	add	r4, sp, #28
   d7524:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   d7526:	682b      	ldr	r3, [r5, #0]
   d7528:	7023      	strb	r3, [r4, #0]
   d752a:	e7cc      	b.n	d74c6 <_ZN9TCPClient7connectEPKctm+0x7a>
// return 0 on error, 1 on success
int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif) {
    stop();

    struct addrinfo* ais = nullptr;
    SCOPE_GUARD({
   d752c:	9800      	ldr	r0, [sp, #0]
   d752e:	f7fe fb3d 	bl	d5bac <netdb_freeaddrinfo>
            return connect(addr, port, nif);
        }
    }

    return 0; // error, could not connect
}
   d7532:	4648      	mov	r0, r9
   d7534:	b013      	add	sp, #76	; 0x4c
   d7536:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   d753a:	bf00      	nop
   d753c:	000da7d8 	.word	0x000da7d8

000d7540 <_ZN9TCPClient12flush_bufferEv>:

int TCPClient::peek() {
    return (bufferCount() || available()) ? d_->buffer[d_->offset] : -1;
}

void TCPClient::flush_buffer() {
   d7540:	6942      	ldr	r2, [r0, #20]
    d_->offset = 0;
   d7542:	2300      	movs	r3, #0
   d7544:	f8a2 3084 	strh.w	r3, [r2, #132]	; 0x84
   d7548:	6942      	ldr	r2, [r0, #20]
    d_->total = 0;
   d754a:	f8a2 3086 	strh.w	r3, [r2, #134]	; 0x86
   d754e:	4770      	bx	lr

000d7550 <_ZN9TCPClient7connectE9IPAddresstm>:

    return 0; // error, could not connect
}

// return 0 on error, 1 on success
int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif) {
   d7550:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   d7554:	461e      	mov	r6, r3
    stop();
   d7556:	6803      	ldr	r3, [r0, #0]

    return 0; // error, could not connect
}

// return 0 on error, 1 on success
int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif) {
   d7558:	460c      	mov	r4, r1
   d755a:	b08a      	sub	sp, #40	; 0x28
    stop();
   d755c:	6adb      	ldr	r3, [r3, #44]	; 0x2c

    return 0; // error, could not connect
}

// return 0 on error, 1 on success
int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif) {
   d755e:	4605      	mov	r5, r0
   d7560:	4617      	mov	r7, r2
    stop();
   d7562:	4798      	blx	r3

    NAMED_SCOPE_GUARD(done, {
        stop();
    });

    d_->sock = sock_socket(ip.version() == 4 ? AF_INET : AF_INET6, SOCK_STREAM, IPPROTO_TCP);
   d7564:	7d23      	ldrb	r3, [r4, #20]
   d7566:	f8d5 8014 	ldr.w	r8, [r5, #20]
   d756a:	2b04      	cmp	r3, #4
   d756c:	bf0c      	ite	eq
   d756e:	2002      	moveq	r0, #2
   d7570:	200a      	movne	r0, #10
   d7572:	2206      	movs	r2, #6
   d7574:	2101      	movs	r1, #1
   d7576:	f7fe fca1 	bl	d5ebc <sock_socket>
   d757a:	f8c8 0000 	str.w	r0, [r8]
    CHECK_TRUE(d_->sock >= 0, 0); // return 0
   d757e:	696b      	ldr	r3, [r5, #20]
   d7580:	681b      	ldr	r3, [r3, #0]
   d7582:	2b00      	cmp	r3, #0
   d7584:	db18      	blt.n	d75b8 <_ZN9TCPClient7connectE9IPAddresstm+0x68>

    flush_buffer();
   d7586:	4628      	mov	r0, r5
   d7588:	f7ff ffda 	bl	d7540 <_ZN9TCPClient12flush_bufferEv>

#if HAL_PLATFORM_IFAPI
    // TODO: provide compatibility headers and use if_indextoname()
    if (nif != 0) {
   d758c:	b1d6      	cbz	r6, d75c4 <_ZN9TCPClient7connectE9IPAddresstm+0x74>
        struct ifreq ifr = {};
   d758e:	2300      	movs	r3, #0
        CHECK_TRUE(if_index_to_name(nif, ifr.ifr_name) == 0, 0); // return 0
   d7590:	a903      	add	r1, sp, #12
   d7592:	b2f0      	uxtb	r0, r6
    flush_buffer();

#if HAL_PLATFORM_IFAPI
    // TODO: provide compatibility headers and use if_indextoname()
    if (nif != 0) {
        struct ifreq ifr = {};
   d7594:	9303      	str	r3, [sp, #12]
   d7596:	f8ad 3010 	strh.w	r3, [sp, #16]
        CHECK_TRUE(if_index_to_name(nif, ifr.ifr_name) == 0, 0); // return 0
   d759a:	f7fe fb47 	bl	d5c2c <if_index_to_name>
   d759e:	b958      	cbnz	r0, d75b8 <_ZN9TCPClient7connectE9IPAddresstm+0x68>
        CHECK_TRUE(sock_setsockopt(d_->sock, SOL_SOCKET, SO_BINDTODEVICE, &ifr, sizeof(ifr)) == 0, 0); // return 0
   d75a0:	6968      	ldr	r0, [r5, #20]
   d75a2:	2306      	movs	r3, #6
   d75a4:	9300      	str	r3, [sp, #0]
   d75a6:	f241 020b 	movw	r2, #4107	; 0x100b
   d75aa:	ab03      	add	r3, sp, #12
   d75ac:	f640 71ff 	movw	r1, #4095	; 0xfff
   d75b0:	6800      	ldr	r0, [r0, #0]
   d75b2:	f7fe fc53 	bl	d5e5c <sock_setsockopt>
   d75b6:	b128      	cbz	r0, d75c4 <_ZN9TCPClient7connectE9IPAddresstm+0x74>

// return 0 on error, 1 on success
int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif) {
    stop();

    NAMED_SCOPE_GUARD(done, {
   d75b8:	682b      	ldr	r3, [r5, #0]
   d75ba:	4628      	mov	r0, r5
   d75bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c

#if HAL_PLATFORM_IFAPI
    // TODO: provide compatibility headers and use if_indextoname()
    if (nif != 0) {
        struct ifreq ifr = {};
        CHECK_TRUE(if_index_to_name(nif, ifr.ifr_name) == 0, 0); // return 0
   d75be:	2400      	movs	r4, #0

// return 0 on error, 1 on success
int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif) {
    stop();

    NAMED_SCOPE_GUARD(done, {
   d75c0:	4798      	blx	r3
   d75c2:	e03b      	b.n	d763c <_ZN9TCPClient7connectE9IPAddresstm+0xec>
        CHECK_TRUE(if_index_to_name(nif, ifr.ifr_name) == 0, 0); // return 0
        CHECK_TRUE(sock_setsockopt(d_->sock, SOL_SOCKET, SO_BINDTODEVICE, &ifr, sizeof(ifr)) == 0, 0); // return 0
    }
#endif // HAL_PLATFORM_IFAPI

    sockaddr_storage saddr = {};
   d75c4:	261c      	movs	r6, #28
   d75c6:	4632      	mov	r2, r6
   d75c8:	2100      	movs	r1, #0
   d75ca:	a803      	add	r0, sp, #12
   d75cc:	f000 fd49 	bl	d8062 <memset>
    if (ip.version() == 4) {
   d75d0:	7d23      	ldrb	r3, [r4, #20]
        auto s = (sockaddr_in*)&saddr;
        s->sin_len = sizeof(saddr);
   d75d2:	f88d 600c 	strb.w	r6, [sp, #12]
        CHECK_TRUE(sock_setsockopt(d_->sock, SOL_SOCKET, SO_BINDTODEVICE, &ifr, sizeof(ifr)) == 0, 0); // return 0
    }
#endif // HAL_PLATFORM_IFAPI

    sockaddr_storage saddr = {};
    if (ip.version() == 4) {
   d75d6:	2b04      	cmp	r3, #4
   d75d8:	d10c      	bne.n	d75f4 <_ZN9TCPClient7connectE9IPAddresstm+0xa4>
        auto s = (sockaddr_in*)&saddr;
        s->sin_len = sizeof(saddr);
        s->sin_family = AF_INET;
   d75da:	2302      	movs	r3, #2
        s->sin_port = htons(port);
   d75dc:	4638      	mov	r0, r7

    sockaddr_storage saddr = {};
    if (ip.version() == 4) {
        auto s = (sockaddr_in*)&saddr;
        s->sin_len = sizeof(saddr);
        s->sin_family = AF_INET;
   d75de:	f88d 300d 	strb.w	r3, [sp, #13]
        s->sin_port = htons(port);
   d75e2:	f7fe fb93 	bl	d5d0c <inet_htons>
   d75e6:	f8ad 000e 	strh.w	r0, [sp, #14]
        s->sin_addr.s_addr = htonl(ip.raw().ipv4);
   d75ea:	6860      	ldr	r0, [r4, #4]
   d75ec:	f7fe fb86 	bl	d5cfc <inet_htonl>
   d75f0:	9004      	str	r0, [sp, #16]
   d75f2:	e013      	b.n	d761c <_ZN9TCPClient7connectE9IPAddresstm+0xcc>
    } else {
        auto s = (sockaddr_in6*)&saddr;
        s->sin6_len = sizeof(saddr);
        s->sin6_family = AF_INET6;
   d75f4:	230a      	movs	r3, #10
        s->sin6_port = htons(port);
   d75f6:	4638      	mov	r0, r7
        s->sin_port = htons(port);
        s->sin_addr.s_addr = htonl(ip.raw().ipv4);
    } else {
        auto s = (sockaddr_in6*)&saddr;
        s->sin6_len = sizeof(saddr);
        s->sin6_family = AF_INET6;
   d75f8:	f88d 300d 	strb.w	r3, [sp, #13]
        s->sin6_port = htons(port);
   d75fc:	f7fe fb86 	bl	d5d0c <inet_htons>
        memcpy(s->sin6_addr.s6_addr, ip.raw().ipv6, sizeof(s->sin6_addr.s6_addr));
   d7600:	ae05      	add	r6, sp, #20
        s->sin_addr.s_addr = htonl(ip.raw().ipv4);
    } else {
        auto s = (sockaddr_in6*)&saddr;
        s->sin6_len = sizeof(saddr);
        s->sin6_family = AF_INET6;
        s->sin6_port = htons(port);
   d7602:	f8ad 000e 	strh.w	r0, [sp, #14]
        memcpy(s->sin6_addr.s6_addr, ip.raw().ipv6, sizeof(s->sin6_addr.s6_addr));
   d7606:	1d23      	adds	r3, r4, #4
   d7608:	f104 0714 	add.w	r7, r4, #20
   d760c:	6818      	ldr	r0, [r3, #0]
   d760e:	6859      	ldr	r1, [r3, #4]
   d7610:	4632      	mov	r2, r6
   d7612:	c203      	stmia	r2!, {r0, r1}
   d7614:	3308      	adds	r3, #8
   d7616:	42bb      	cmp	r3, r7
   d7618:	4616      	mov	r6, r2
   d761a:	d1f7      	bne.n	d760c <_ZN9TCPClient7connectE9IPAddresstm+0xbc>
    }

    // FIXME: timeout?
    CHECK_TRUE(sock_connect(d_->sock, (const sockaddr*)&saddr, sizeof(saddr)) == 0, 0); // return 0
   d761c:	696b      	ldr	r3, [r5, #20]
   d761e:	221c      	movs	r2, #28
   d7620:	a903      	add	r1, sp, #12
   d7622:	6818      	ldr	r0, [r3, #0]
   d7624:	f7fe fc2a 	bl	d5e7c <sock_connect>
   d7628:	2800      	cmp	r0, #0
   d762a:	d1c5      	bne.n	d75b8 <_ZN9TCPClient7connectE9IPAddresstm+0x68>
   d762c:	3404      	adds	r4, #4
   d762e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   d7630:	696d      	ldr	r5, [r5, #20]
   d7632:	358c      	adds	r5, #140	; 0x8c
   d7634:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   d7636:	6823      	ldr	r3, [r4, #0]
   d7638:	702b      	strb	r3, [r5, #0]

    d_->remoteIP = ip;

    done.dismiss();

    return 1; // success
   d763a:	2401      	movs	r4, #1
}
   d763c:	4620      	mov	r0, r4
   d763e:	b00a      	add	sp, #40	; 0x28
   d7640:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000d7644 <_ZN9TCPClient4stopEv>:
}

void TCPClient::flush() {
}

void TCPClient::stop() {
   d7644:	b510      	push	{r4, lr}
    if (isOpen(d_->sock)) {
   d7646:	6943      	ldr	r3, [r0, #20]
}

void TCPClient::flush() {
}

void TCPClient::stop() {
   d7648:	4604      	mov	r4, r0
    if (isOpen(d_->sock)) {
   d764a:	6818      	ldr	r0, [r3, #0]
   d764c:	2800      	cmp	r0, #0
   d764e:	db01      	blt.n	d7654 <_ZN9TCPClient4stopEv+0x10>
        sock_close(d_->sock);
   d7650:	f7fe fc0c 	bl	d5e6c <sock_close>
   d7654:	6963      	ldr	r3, [r4, #20]
    }
    d_->sock = -1;
   d7656:	f04f 32ff 	mov.w	r2, #4294967295
   d765a:	601a      	str	r2, [r3, #0]
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
   d765c:	6960      	ldr	r0, [r4, #20]
   d765e:	2211      	movs	r2, #17
   d7660:	2100      	movs	r1, #0
   d7662:	308c      	adds	r0, #140	; 0x8c
   d7664:	f000 fcfd 	bl	d8062 <memset>
    d_->remoteIP.clear();
    flush_buffer();
   d7668:	4620      	mov	r0, r4
}
   d766a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if (isOpen(d_->sock)) {
        sock_close(d_->sock);
    }
    d_->sock = -1;
    d_->remoteIP.clear();
    flush_buffer();
   d766e:	f7ff bf67 	b.w	d7540 <_ZN9TCPClient12flush_bufferEv>
	...

000d7674 <_ZN9TCPClient9availableEv>:
int TCPClient::bufferCount() {
    return d_->total - d_->offset;
}

int TCPClient::available()
{
   d7674:	b530      	push	{r4, r5, lr}
   d7676:	6942      	ldr	r2, [r0, #20]
    int avail = 0;

    // At EOB => Flush it
    if (d_->total && (d_->offset == d_->total)) {
   d7678:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
int TCPClient::bufferCount() {
    return d_->total - d_->offset;
}

int TCPClient::available()
{
   d767c:	b08b      	sub	sp, #44	; 0x2c
   d767e:	4604      	mov	r4, r0
    int avail = 0;

    // At EOB => Flush it
    if (d_->total && (d_->offset == d_->total)) {
   d7680:	b11b      	cbz	r3, d768a <_ZN9TCPClient9availableEv+0x16>
   d7682:	f8b2 2084 	ldrh.w	r2, [r2, #132]	; 0x84
   d7686:	429a      	cmp	r2, r3
   d7688:	d040      	beq.n	d770c <_ZN9TCPClient9availableEv+0x98>
   d768a:	6963      	ldr	r3, [r4, #20]
        flush_buffer();
    }

    if (isOpen(d_->sock)) {
   d768c:	6818      	ldr	r0, [r3, #0]
   d768e:	2800      	cmp	r0, #0
   d7690:	db3f      	blt.n	d7712 <_ZN9TCPClient9availableEv+0x9e>
        // Have room
        if (d_->total < arraySize(d_->buffer)) {
   d7692:	f8b3 5086 	ldrh.w	r5, [r3, #134]	; 0x86
   d7696:	2d7f      	cmp	r5, #127	; 0x7f
   d7698:	d83b      	bhi.n	d7712 <_ZN9TCPClient9availableEv+0x9e>
            int ret = sock_recv(d_->sock, d_->buffer + d_->total, arraySize(d_->buffer) - d_->total, MSG_DONTWAIT);
   d769a:	1d19      	adds	r1, r3, #4
   d769c:	f1c5 0280 	rsb	r2, r5, #128	; 0x80
   d76a0:	2308      	movs	r3, #8
   d76a2:	4429      	add	r1, r5
   d76a4:	f7fe fbfa 	bl	d5e9c <sock_recv>
            if (ret > 0) {
   d76a8:	2800      	cmp	r0, #0
   d76aa:	dd0c      	ble.n	d76c6 <_ZN9TCPClient9availableEv+0x52>
   d76ac:	6963      	ldr	r3, [r4, #20]
                if (d_->total == 0) {
   d76ae:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
   d76b2:	b90a      	cbnz	r2, d76b8 <_ZN9TCPClient9availableEv+0x44>
                    d_->offset = 0;
   d76b4:	f8a3 2084 	strh.w	r2, [r3, #132]	; 0x84
   d76b8:	6962      	ldr	r2, [r4, #20]
                }
                d_->total += ret;
   d76ba:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
   d76be:	4418      	add	r0, r3
   d76c0:	f8a2 0086 	strh.w	r0, [r2, #134]	; 0x86
   d76c4:	e025      	b.n	d7712 <_ZN9TCPClient9availableEv+0x9e>
            } else {
                if (errno != EAGAIN && errno != EWOULDBLOCK) {
   d76c6:	f7fe fd55 	bl	d6174 <__errno>
   d76ca:	6803      	ldr	r3, [r0, #0]
   d76cc:	2b0b      	cmp	r3, #11
   d76ce:	d020      	beq.n	d7712 <_ZN9TCPClient9availableEv+0x9e>
   d76d0:	f7fe fd50 	bl	d6174 <__errno>
   d76d4:	6803      	ldr	r3, [r0, #0]
   d76d6:	2b0b      	cmp	r3, #11
   d76d8:	d01b      	beq.n	d7712 <_ZN9TCPClient9availableEv+0x9e>
                    LOG(ERROR, "recv error = %d", errno);
   d76da:	2320      	movs	r3, #32
   d76dc:	2500      	movs	r5, #0
   d76de:	9302      	str	r3, [sp, #8]
   d76e0:	9503      	str	r5, [sp, #12]
   d76e2:	f7fe fd47 	bl	d6174 <__errno>
   d76e6:	6803      	ldr	r3, [r0, #0]
   d76e8:	9301      	str	r3, [sp, #4]
   d76ea:	4b0e      	ldr	r3, [pc, #56]	; (d7724 <_ZN9TCPClient9availableEv+0xb0>)
   d76ec:	9300      	str	r3, [sp, #0]
   d76ee:	aa02      	add	r2, sp, #8
   d76f0:	462b      	mov	r3, r5
   d76f2:	490d      	ldr	r1, [pc, #52]	; (d7728 <_ZN9TCPClient9availableEv+0xb4>)
   d76f4:	2032      	movs	r0, #50	; 0x32
   d76f6:	f7fe fc29 	bl	d5f4c <log_message>
                    sock_close(d_->sock);
   d76fa:	6963      	ldr	r3, [r4, #20]
   d76fc:	6818      	ldr	r0, [r3, #0]
   d76fe:	f7fe fbb5 	bl	d5e6c <sock_close>
   d7702:	6963      	ldr	r3, [r4, #20]
                    d_->sock = -1;
   d7704:	f04f 32ff 	mov.w	r2, #4294967295
   d7708:	601a      	str	r2, [r3, #0]
   d770a:	e002      	b.n	d7712 <_ZN9TCPClient9availableEv+0x9e>
{
    int avail = 0;

    // At EOB => Flush it
    if (d_->total && (d_->offset == d_->total)) {
        flush_buffer();
   d770c:	f7ff ff18 	bl	d7540 <_ZN9TCPClient12flush_bufferEv>
   d7710:	e7bb      	b.n	d768a <_ZN9TCPClient9availableEv+0x16>
   d7712:	6962      	ldr	r2, [r4, #20]
                }
            }
        } // Have Space
    } // isOpen(d_->sock)
    avail = bufferCount();
    return avail;
   d7714:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
   d7718:	f8b2 0084 	ldrh.w	r0, [r2, #132]	; 0x84
   d771c:	1a18      	subs	r0, r3, r0
}
   d771e:	b00b      	add	sp, #44	; 0x2c
   d7720:	bd30      	pop	{r4, r5, pc}
   d7722:	bf00      	nop
   d7724:	000da90f 	.word	0x000da90f
   d7728:	000da908 	.word	0x000da908

000d772c <_ZN9TCPClient4DataC1Ei>:

IPAddress TCPClient::remoteIP() {
    return d_->remoteIP;
}

TCPClient::Data::Data(sock_handle_t sock)
   d772c:	b510      	push	{r4, lr}
        : sock(sock),
          offset(0),
          total(0) {
   d772e:	2300      	movs	r3, #0

IPAddress TCPClient::remoteIP() {
    return d_->remoteIP;
}

TCPClient::Data::Data(sock_handle_t sock)
   d7730:	4604      	mov	r4, r0
        : sock(sock),
          offset(0),
          total(0) {
   d7732:	6001      	str	r1, [r0, #0]
   d7734:	f8a0 3084 	strh.w	r3, [r0, #132]	; 0x84
   d7738:	f8a0 3086 	strh.w	r3, [r0, #134]	; 0x86
   d773c:	3088      	adds	r0, #136	; 0x88
   d773e:	f7ff fb1f 	bl	d6d80 <_ZN9IPAddressC1Ev>
}
   d7742:	4620      	mov	r0, r4
   d7744:	bd10      	pop	{r4, pc}
	...

000d7748 <_ZN9TCPClientC1Ei>:
   d7748:	f44f 727a 	mov.w	r2, #1000	; 0x3e8

TCPClient::TCPClient()
        : TCPClient(-1) {
}

TCPClient::TCPClient(sock_handle_t sock)
   d774c:	b570      	push	{r4, r5, r6, lr}
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
   d774e:	2300      	movs	r3, #0
   d7750:	6082      	str	r2, [r0, #8]
        : d_(std::make_shared<Data>(sock)) {
   d7752:	4a14      	ldr	r2, [pc, #80]	; (d77a4 <_ZN9TCPClientC1Ei+0x5c>)
   d7754:	6043      	str	r3, [r0, #4]
   d7756:	6002      	str	r2, [r0, #0]
        };

      template<typename _Alloc, typename... _Args>
	__shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
		     _Args&&... __args)
	: _M_ptr(), _M_refcount()
   d7758:	6143      	str	r3, [r0, #20]

  template<_Lock_policy _Lp>
    class __shared_count
    {
    public:
      constexpr __shared_count() noexcept : _M_pi(0)
   d775a:	6183      	str	r3, [r0, #24]

TCPClient::TCPClient()
        : TCPClient(-1) {
}

TCPClient::TCPClient(sock_handle_t sock)
   d775c:	4604      	mov	r4, r0
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
   d775e:	20a0      	movs	r0, #160	; 0xa0
   d7760:	460e      	mov	r6, r1
   d7762:	f7fc fc98 	bl	d4096 <_Znwj>

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
   d7766:	4605      	mov	r5, r0
   d7768:	b110      	cbz	r0, d7770 <_ZN9TCPClientC1Ei+0x28>
   d776a:	4631      	mov	r1, r6
   d776c:	f7ff ffde 	bl	d772c <_ZN9TCPClient4DataC1Ei>
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
   d7770:	2014      	movs	r0, #20
   d7772:	f7fc fc90 	bl	d4096 <_Znwj>
	  __try
	    {
	      typename _Sp_cd_type::__allocator_type __a2(__a);
	      auto __guard = std::__allocate_guarded(__a2);
	      _Sp_cd_type* __mem = __guard.get();
	      ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));
   d7776:	4603      	mov	r3, r0
   d7778:	b128      	cbz	r0, d7786 <_ZN9TCPClientC1Ei+0x3e>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:  
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }
   d777a:	2201      	movs	r2, #1
   d777c:	6042      	str	r2, [r0, #4]
   d777e:	6082      	str	r2, [r0, #8]
      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
      : _M_impl(__p, __d, _Alloc()) { }

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }
   d7780:	4a09      	ldr	r2, [pc, #36]	; (d77a8 <_ZN9TCPClientC1Ei+0x60>)
   d7782:	6002      	str	r2, [r0, #0]
	typedef _Sp_ebo_helper<0, _Deleter>	_Del_base;
	typedef _Sp_ebo_helper<1, _Alloc>	_Alloc_base;

      public:
	_Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
	: _M_ptr(__p), _Del_base(__d), _Alloc_base(__a)
   d7784:	6105      	str	r5, [r0, #16]

      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
   d7786:	69a0      	ldr	r0, [r4, #24]
	  __traits::construct(__del._M_alloc, __ptr,
			      std::forward<_Args>(__args)...);
	  __guard = nullptr;
	  __shared_count<_Lp> __count(__ptr, __del, __del._M_alloc);
	  _M_refcount._M_swap(__count);
	  _M_ptr = __ptr;
   d7788:	6165      	str	r5, [r4, #20]
      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
	_M_pi = __tmp;
   d778a:	61a3      	str	r3, [r4, #24]
      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
   d778c:	b128      	cbz	r0, d779a <_ZN9TCPClientC1Ei+0x52>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
   d778e:	6843      	ldr	r3, [r0, #4]
   d7790:	3b01      	subs	r3, #1
   d7792:	6043      	str	r3, [r0, #4]
   d7794:	b90b      	cbnz	r3, d779a <_ZN9TCPClientC1Ei+0x52>
   d7796:	f7ff fddf 	bl	d7358 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.4.constprop.31>
        : d_(std::make_shared<Data>(sock)) {
    flush_buffer();
   d779a:	4620      	mov	r0, r4
   d779c:	f7ff fed0 	bl	d7540 <_ZN9TCPClient12flush_bufferEv>
}
   d77a0:	4620      	mov	r0, r4
   d77a2:	bd70      	pop	{r4, r5, r6, pc}
   d77a4:	000da8c4 	.word	0x000da8c4
   d77a8:	000da8a8 	.word	0x000da8a8

000d77ac <_ZN9TCPClientC1Ev>:

static bool inline isOpen(sock_handle_t sd) {
    return socket_handle_valid(sd);
}

TCPClient::TCPClient()
   d77ac:	b510      	push	{r4, lr}
        : TCPClient(-1) {
   d77ae:	f04f 31ff 	mov.w	r1, #4294967295

static bool inline isOpen(sock_handle_t sd) {
    return socket_handle_valid(sd);
}

TCPClient::TCPClient()
   d77b2:	4604      	mov	r4, r0
        : TCPClient(-1) {
   d77b4:	f7ff ffc8 	bl	d7748 <_ZN9TCPClientC1Ei>
}
   d77b8:	4620      	mov	r0, r4
   d77ba:	bd10      	pop	{r4, pc}

000d77bc <_ZN9TCPClient4DataD1Ev>:
        : sock(sock),
          offset(0),
          total(0) {
}

TCPClient::Data::~Data() {
   d77bc:	b510      	push	{r4, lr}
   d77be:	4604      	mov	r4, r0
    if (socket_handle_valid(sock)) {
   d77c0:	6800      	ldr	r0, [r0, #0]
   d77c2:	2800      	cmp	r0, #0
   d77c4:	db01      	blt.n	d77ca <_ZN9TCPClient4DataD1Ev+0xe>
        sock_close(sock);
   d77c6:	f7fe fb51 	bl	d5e6c <sock_close>
    }
}
   d77ca:	4620      	mov	r0, r4
   d77cc:	bd10      	pop	{r4, pc}

000d77ce <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_disposeEv>:
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }

      virtual void
      _M_dispose() noexcept
   d77ce:	b510      	push	{r4, lr}
      { _M_impl._M_del()(_M_impl._M_ptr); }
   d77d0:	6904      	ldr	r4, [r0, #16]
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
        void 
        destroy(_Up* __p) { __p->~_Up(); }
   d77d2:	4620      	mov	r0, r4
   d77d4:	f7ff fff2 	bl	d77bc <_ZN9TCPClient4DataD1Ev>
      { __gd._M_ptr = nullptr; }

      /// Deallocate the owned pointer
      ~__allocated_ptr()
      {
	if (_M_ptr != nullptr)
   d77d8:	b124      	cbz	r4, d77e4 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_disposeEv+0x16>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
   d77da:	4620      	mov	r0, r4
   d77dc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   d77e0:	f7fc bc5b 	b.w	d409a <_ZdlPv>
   d77e4:	bd10      	pop	{r4, pc}

000d77e6 <_ZN5spark9WiFiClass5readyEv>:
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
   d77e6:	2200      	movs	r2, #0
   d77e8:	4611      	mov	r1, r2
   d77ea:	6840      	ldr	r0, [r0, #4]
   d77ec:	f7fe bc12 	b.w	d6014 <network_ready>

000d77f0 <_ZN5spark9WiFiClass9listeningEv>:
    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
    }

    bool listening(void) {
        return network_listening(*this, 0, NULL);
   d77f0:	2200      	movs	r2, #0
   d77f2:	4611      	mov	r1, r2
   d77f4:	6840      	ldr	r0, [r0, #4]
   d77f6:	f7fe bc2d 	b.w	d6054 <network_listening>

000d77fa <_ZN5spark9WiFiClass16getListenTimeoutEv>:
        network_set_listen_timeout(*this, timeout, NULL);
    }
    inline void setListenTimeout(std::chrono::seconds s) { setListenTimeout(s.count()); }

    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
   d77fa:	2200      	movs	r2, #0
   d77fc:	4611      	mov	r1, r2
   d77fe:	6840      	ldr	r0, [r0, #4]
   d7800:	f7fe bc38 	b.w	d6074 <network_get_listen_timeout>

000d7804 <_ZN5spark9WiFiClass16setListenTimeoutEt>:
    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
    }

    void setListenTimeout(uint16_t timeout) {
        network_set_listen_timeout(*this, timeout, NULL);
   d7804:	2200      	movs	r2, #0
   d7806:	6840      	ldr	r0, [r0, #4]
   d7808:	f7fe bc2c 	b.w	d6064 <network_set_listen_timeout>

000d780c <_ZN5spark9WiFiClass6listenEb>:
    void off(void) {
        network_off(*this, 0, 0, NULL);
    }

    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
   d780c:	2200      	movs	r2, #0
   d780e:	f081 0101 	eor.w	r1, r1, #1
   d7812:	6840      	ldr	r0, [r0, #4]
   d7814:	f7fe bc16 	b.w	d6044 <network_listen>

000d7818 <_ZN5spark9WiFiClass3offEv>:
    void on(void) {
        network_on(*this, 0, 0, NULL);
    }

    void off(void) {
        network_off(*this, 0, 0, NULL);
   d7818:	2300      	movs	r3, #0
   d781a:	461a      	mov	r2, r3
   d781c:	4619      	mov	r1, r3
   d781e:	6840      	ldr	r0, [r0, #4]
   d7820:	f7fe bc08 	b.w	d6034 <network_off>

000d7824 <_ZN5spark9WiFiClass2onEv>:
    bool ready(void) {
        return network_ready(*this, 0, NULL);
    }

    void on(void) {
        network_on(*this, 0, 0, NULL);
   d7824:	2300      	movs	r3, #0
   d7826:	461a      	mov	r2, r3
   d7828:	4619      	mov	r1, r3
   d782a:	6840      	ldr	r0, [r0, #4]
   d782c:	f7fe bbfa 	b.w	d6024 <network_on>

000d7830 <_ZN5spark9WiFiClass10connectingEv>:
    void disconnect(void) {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
    }

    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
   d7830:	2200      	movs	r2, #0
   d7832:	4611      	mov	r1, r2
   d7834:	6840      	ldr	r0, [r0, #4]
   d7836:	f7fe bbdd 	b.w	d5ff4 <network_connecting>

000d783a <_ZN5spark9WiFiClass10disconnectEv>:
    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
    }

    void disconnect(void) {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
   d783a:	2200      	movs	r2, #0
   d783c:	2102      	movs	r1, #2
   d783e:	6840      	ldr	r0, [r0, #4]
   d7840:	f7fe bbe0 	b.w	d6004 <network_disconnect>

000d7844 <_ZN5spark9WiFiClass7connectEj>:
    uint32_t ping(IPAddress remoteIP, uint8_t nTries) {
        return inet_ping(&remoteIP.raw(), *this, nTries, NULL);
    }

    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
   d7844:	2300      	movs	r3, #0
   d7846:	461a      	mov	r2, r3
   d7848:	6840      	ldr	r0, [r0, #4]
   d784a:	f7fe bbcb 	b.w	d5fe4 <network_connect>
	...

000d7850 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t>:
   d7850:	4b02      	ldr	r3, [pc, #8]	; (d785c <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0xc>)
   d7852:	2204      	movs	r2, #4
   d7854:	605a      	str	r2, [r3, #4]
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() :
            NetworkClass(NETWORK_INTERFACE_WIFI_STA) {
   d7856:	4a02      	ldr	r2, [pc, #8]	; (d7860 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x10>)
   d7858:	601a      	str	r2, [r3, #0]
   d785a:	4770      	bx	lr
   d785c:	2003e5ec 	.word	0x2003e5ec
   d7860:	000da928 	.word	0x000da928

000d7864 <_ZN5spark12NetworkClass7connectEj>:
        return Network;
    }
}

void NetworkClass::connect(unsigned flags) {
    network_connect(*this, flags, 0, nullptr);
   d7864:	2300      	movs	r3, #0
   d7866:	461a      	mov	r2, r3
   d7868:	6840      	ldr	r0, [r0, #4]
   d786a:	f7fe bbbb 	b.w	d5fe4 <network_connect>

000d786e <_ZN5spark12NetworkClass10disconnectEv>:
}

void NetworkClass::disconnect() {
    network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, nullptr);
   d786e:	2200      	movs	r2, #0
   d7870:	2102      	movs	r1, #2
   d7872:	6840      	ldr	r0, [r0, #4]
   d7874:	f7fe bbc6 	b.w	d6004 <network_disconnect>

000d7878 <_ZN5spark12NetworkClass10connectingEv>:
}

bool NetworkClass::connecting() {
    return network_connecting(*this, 0, nullptr);
   d7878:	2200      	movs	r2, #0
   d787a:	4611      	mov	r1, r2
   d787c:	6840      	ldr	r0, [r0, #4]
   d787e:	f7fe bbb9 	b.w	d5ff4 <network_connecting>

000d7882 <_ZN5spark12NetworkClass5readyEv>:
}

bool NetworkClass::ready() {
    return network_ready(*this, 0, nullptr);
   d7882:	2200      	movs	r2, #0
   d7884:	4611      	mov	r1, r2
   d7886:	6840      	ldr	r0, [r0, #4]
   d7888:	f7fe bbc4 	b.w	d6014 <network_ready>

000d788c <_ZN5spark12NetworkClass2onEv>:
}

void NetworkClass::on() {
    network_on(*this, 0, 0, nullptr);
   d788c:	2300      	movs	r3, #0
   d788e:	461a      	mov	r2, r3
   d7890:	4619      	mov	r1, r3
   d7892:	6840      	ldr	r0, [r0, #4]
   d7894:	f7fe bbc6 	b.w	d6024 <network_on>

000d7898 <_ZN5spark12NetworkClass3offEv>:
}

void NetworkClass::off() {
    network_off(*this, 0, 0, nullptr);
   d7898:	2300      	movs	r3, #0
   d789a:	461a      	mov	r2, r3
   d789c:	4619      	mov	r1, r3
   d789e:	6840      	ldr	r0, [r0, #4]
   d78a0:	f7fe bbc8 	b.w	d6034 <network_off>

000d78a4 <_ZN5spark12NetworkClass6listenEb>:
}

void NetworkClass::listen(bool begin) {
    network_listen(*this, begin ? 0 : 1, nullptr);
   d78a4:	2200      	movs	r2, #0
   d78a6:	f081 0101 	eor.w	r1, r1, #1
   d78aa:	6840      	ldr	r0, [r0, #4]
   d78ac:	f7fe bbca 	b.w	d6044 <network_listen>

000d78b0 <_ZN5spark12NetworkClass16setListenTimeoutEt>:
}

void NetworkClass::setListenTimeout(uint16_t timeout) {
    network_set_listen_timeout(*this, timeout, nullptr);
   d78b0:	2200      	movs	r2, #0
   d78b2:	6840      	ldr	r0, [r0, #4]
   d78b4:	f7fe bbd6 	b.w	d6064 <network_set_listen_timeout>

000d78b8 <_ZN5spark12NetworkClass16getListenTimeoutEv>:
}

uint16_t NetworkClass::getListenTimeout() {
    return network_get_listen_timeout(*this, 0, nullptr);
   d78b8:	2200      	movs	r2, #0
   d78ba:	4611      	mov	r1, r2
   d78bc:	6840      	ldr	r0, [r0, #4]
   d78be:	f7fe bbd9 	b.w	d6074 <network_get_listen_timeout>

000d78c2 <_ZN5spark12NetworkClass9listeningEv>:
}

bool NetworkClass::listening() {
    return network_listening(*this, 0, nullptr);
   d78c2:	2200      	movs	r2, #0
   d78c4:	4611      	mov	r1, r2
   d78c6:	6840      	ldr	r0, [r0, #4]
   d78c8:	f7fe bbc4 	b.w	d6054 <network_listening>

000d78cc <_ZN5spark12NetworkClass7resolveEPKc>:
}

IPAddress NetworkClass::resolve(const char* name) {
   d78cc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    IPAddress addr;
#if HAL_USE_INET_HAL_POSIX
    struct addrinfo *ai = nullptr;
   d78d0:	2400      	movs	r4, #0

bool NetworkClass::listening() {
    return network_listening(*this, 0, nullptr);
}

IPAddress NetworkClass::resolve(const char* name) {
   d78d2:	b095      	sub	sp, #84	; 0x54
   d78d4:	4616      	mov	r6, r2
   d78d6:	460d      	mov	r5, r1
   d78d8:	4607      	mov	r7, r0
    IPAddress addr;
   d78da:	f7ff fa51 	bl	d6d80 <_ZN9IPAddressC1Ev>
#if HAL_USE_INET_HAL_POSIX
    struct addrinfo *ai = nullptr;
    struct addrinfo hints = {};
   d78de:	4621      	mov	r1, r4
   d78e0:	2220      	movs	r2, #32
   d78e2:	a80c      	add	r0, sp, #48	; 0x30
}

IPAddress NetworkClass::resolve(const char* name) {
    IPAddress addr;
#if HAL_USE_INET_HAL_POSIX
    struct addrinfo *ai = nullptr;
   d78e4:	9400      	str	r4, [sp, #0]
    struct addrinfo hints = {};
   d78e6:	f000 fbbc 	bl	d8062 <memset>
    hints.ai_flags = AI_ADDRCONFIG;
   d78ea:	2340      	movs	r3, #64	; 0x40
   d78ec:	930c      	str	r3, [sp, #48]	; 0x30
    hints.ai_family = AF_UNSPEC;
    const int r = getaddrinfo(name, nullptr, &hints, &ai);
   d78ee:	4621      	mov	r1, r4
   d78f0:	466b      	mov	r3, sp
   d78f2:	aa0c      	add	r2, sp, #48	; 0x30
   d78f4:	4630      	mov	r0, r6
   d78f6:	f7fe f961 	bl	d5bbc <netdb_getaddrinfo>
    if (!r) {
   d78fa:	4604      	mov	r4, r0
   d78fc:	2800      	cmp	r0, #0
   d78fe:	d144      	bne.n	d798a <_ZN5spark12NetworkClass7resolveEPKc+0xbe>
        bool ok = false;
        // This is not really needed if AI_ADDRCONFIG is properly supported
        bool ipv4 = network_ready(*this, NETWORK_READY_TYPE_IPV4, nullptr);
   d7900:	4602      	mov	r2, r0
   d7902:	2101      	movs	r1, #1
   d7904:	6868      	ldr	r0, [r5, #4]
   d7906:	f7fe fb85 	bl	d6014 <network_ready>
        bool ipv6 = network_ready(*this, NETWORK_READY_TYPE_IPV6, nullptr);
   d790a:	2102      	movs	r1, #2
    hints.ai_family = AF_UNSPEC;
    const int r = getaddrinfo(name, nullptr, &hints, &ai);
    if (!r) {
        bool ok = false;
        // This is not really needed if AI_ADDRCONFIG is properly supported
        bool ipv4 = network_ready(*this, NETWORK_READY_TYPE_IPV4, nullptr);
   d790c:	4680      	mov	r8, r0
        bool ipv6 = network_ready(*this, NETWORK_READY_TYPE_IPV6, nullptr);
   d790e:	4622      	mov	r2, r4
   d7910:	6868      	ldr	r0, [r5, #4]
   d7912:	f7fe fb7f 	bl	d6014 <network_ready>
        for (auto cur = ai; cur != nullptr && !ok; cur = cur->ai_next) {
   d7916:	9e00      	ldr	r6, [sp, #0]
    const int r = getaddrinfo(name, nullptr, &hints, &ai);
    if (!r) {
        bool ok = false;
        // This is not really needed if AI_ADDRCONFIG is properly supported
        bool ipv4 = network_ready(*this, NETWORK_READY_TYPE_IPV4, nullptr);
        bool ipv6 = network_ready(*this, NETWORK_READY_TYPE_IPV6, nullptr);
   d7918:	4681      	mov	r9, r0
    struct addrinfo hints = {};
    hints.ai_flags = AI_ADDRCONFIG;
    hints.ai_family = AF_UNSPEC;
    const int r = getaddrinfo(name, nullptr, &hints, &ai);
    if (!r) {
        bool ok = false;
   d791a:	4621      	mov	r1, r4
        // This is not really needed if AI_ADDRCONFIG is properly supported
        bool ipv4 = network_ready(*this, NETWORK_READY_TYPE_IPV4, nullptr);
        bool ipv6 = network_ready(*this, NETWORK_READY_TYPE_IPV6, nullptr);
        for (auto cur = ai; cur != nullptr && !ok; cur = cur->ai_next) {
   d791c:	2e00      	cmp	r6, #0
   d791e:	d034      	beq.n	d798a <_ZN5spark12NetworkClass7resolveEPKc+0xbe>
   d7920:	2900      	cmp	r1, #0
   d7922:	d132      	bne.n	d798a <_ZN5spark12NetworkClass7resolveEPKc+0xbe>
            // NOTE: using only the first entry that matches the current state of IPv4/IPv6 connectivity
            switch (cur->ai_family) {
   d7924:	6873      	ldr	r3, [r6, #4]
   d7926:	2b02      	cmp	r3, #2
   d7928:	d002      	beq.n	d7930 <_ZN5spark12NetworkClass7resolveEPKc+0x64>
   d792a:	2b0a      	cmp	r3, #10
   d792c:	d009      	beq.n	d7942 <_ZN5spark12NetworkClass7resolveEPKc+0x76>
   d792e:	e02a      	b.n	d7986 <_ZN5spark12NetworkClass7resolveEPKc+0xba>
                case AF_INET: {
                    if (!ipv4) {
   d7930:	f1b8 0f00 	cmp.w	r8, #0
   d7934:	d027      	beq.n	d7986 <_ZN5spark12NetworkClass7resolveEPKc+0xba>
                        continue;
                    }
                    // NOTE: HAL_IPAddress is little-endian
                    auto in = (struct sockaddr_in*)cur->ai_addr;
                    addr = (const uint8_t*)(&in->sin_addr.s_addr);
   d7936:	6971      	ldr	r1, [r6, #20]
   d7938:	4638      	mov	r0, r7
   d793a:	3104      	adds	r1, #4
   d793c:	f7ff fa70 	bl	d6e20 <_ZN9IPAddressaSEPKh>
   d7940:	e020      	b.n	d7984 <_ZN5spark12NetworkClass7resolveEPKc+0xb8>
                    ok = true;
                    break;
                }
                case AF_INET6: {
                    if (!ipv6) {
   d7942:	f1b9 0f00 	cmp.w	r9, #0
   d7946:	d01e      	beq.n	d7986 <_ZN5spark12NetworkClass7resolveEPKc+0xba>
                        continue;
                    }
                    auto in6 = (struct sockaddr_in6*)cur->ai_addr;
   d7948:	6974      	ldr	r4, [r6, #20]
                    HAL_IPAddress a = {};
   d794a:	2211      	movs	r2, #17
   d794c:	a801      	add	r0, sp, #4
   d794e:	f000 fb88 	bl	d8062 <memset>
                    a.v = 6;
   d7952:	2306      	movs	r3, #6
   d7954:	f88d 3014 	strb.w	r3, [sp, #20]
                    memcpy(a.ipv6, in6->sin6_addr.s6_addr, sizeof(a.ipv6));
   d7958:	ad01      	add	r5, sp, #4
   d795a:	f104 0308 	add.w	r3, r4, #8
   d795e:	3418      	adds	r4, #24
   d7960:	6818      	ldr	r0, [r3, #0]
   d7962:	6859      	ldr	r1, [r3, #4]
   d7964:	462a      	mov	r2, r5
   d7966:	c203      	stmia	r2!, {r0, r1}
   d7968:	3308      	adds	r3, #8
   d796a:	42a3      	cmp	r3, r4
   d796c:	4615      	mov	r5, r2
   d796e:	d1f7      	bne.n	d7960 <_ZN5spark12NetworkClass7resolveEPKc+0x94>
                    addr = IPAddress(a);
   d7970:	a901      	add	r1, sp, #4
   d7972:	a806      	add	r0, sp, #24

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
   d7974:	ad07      	add	r5, sp, #28
   d7976:	f7ff fa11 	bl	d6d9c <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
   d797a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   d797c:	1d3c      	adds	r4, r7, #4
   d797e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   d7980:	682b      	ldr	r3, [r5, #0]
   d7982:	7023      	strb	r3, [r4, #0]
                    ok = true;
   d7984:	2101      	movs	r1, #1
    if (!r) {
        bool ok = false;
        // This is not really needed if AI_ADDRCONFIG is properly supported
        bool ipv4 = network_ready(*this, NETWORK_READY_TYPE_IPV4, nullptr);
        bool ipv6 = network_ready(*this, NETWORK_READY_TYPE_IPV6, nullptr);
        for (auto cur = ai; cur != nullptr && !ok; cur = cur->ai_next) {
   d7986:	69f6      	ldr	r6, [r6, #28]
   d7988:	e7c8      	b.n	d791c <_ZN5spark12NetworkClass7resolveEPKc+0x50>
                    break;
                }
            }
        }
    }
    freeaddrinfo(ai);
   d798a:	9800      	ldr	r0, [sp, #0]
   d798c:	f7fe f90e 	bl	d5bac <netdb_freeaddrinfo>
    return Cellular.resolve(name);
#endif // Wiring_Cellular

#endif // HAL_USE_INET_HAL_POSIX
    return addr;
}
   d7990:	4638      	mov	r0, r7
   d7992:	b015      	add	sp, #84	; 0x54
   d7994:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

000d7998 <_GLOBAL__sub_I__ZN5spark7NetworkE>:
   d7998:	4b02      	ldr	r3, [pc, #8]	; (d79a4 <_GLOBAL__sub_I__ZN5spark7NetworkE+0xc>)
   d799a:	4a03      	ldr	r2, [pc, #12]	; (d79a8 <_GLOBAL__sub_I__ZN5spark7NetworkE+0x10>)
   d799c:	601a      	str	r2, [r3, #0]
   d799e:	2200      	movs	r2, #0
   d79a0:	605a      	str	r2, [r3, #4]
   d79a2:	4770      	bx	lr
   d79a4:	2003e5f4 	.word	0x2003e5f4
   d79a8:	000da95c 	.word	0x000da95c

000d79ac <pinAvailable>:

/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
   d79ac:	b570      	push	{r4, r5, r6, lr}

template <HAL_SPI_Interface Interface>
class SpiProxy {
public:
    static SPIClass& instance() {
        static SPIClass instance(Interface);
   d79ae:	4e18      	ldr	r6, [pc, #96]	; (d7a10 <pinAvailable+0x64>)
   d79b0:	6831      	ldr	r1, [r6, #0]
   d79b2:	f011 0501 	ands.w	r5, r1, #1
   d79b6:	4604      	mov	r4, r0
   d79b8:	d10a      	bne.n	d79d0 <pinAvailable+0x24>
   d79ba:	4630      	mov	r0, r6
   d79bc:	f7fc fb7c 	bl	d40b8 <__cxa_guard_acquire>
   d79c0:	b130      	cbz	r0, d79d0 <pinAvailable+0x24>
   d79c2:	4629      	mov	r1, r5
   d79c4:	4813      	ldr	r0, [pc, #76]	; (d7a14 <pinAvailable+0x68>)
   d79c6:	f7fe fc1b 	bl	d6200 <_ZN8SPIClassC1E17HAL_SPI_Interface>
   d79ca:	4630      	mov	r0, r6
   d79cc:	f7fc fb79 	bl	d40c2 <__cxa_guard_release>
    }
    void detachInterrupt() {
        instance().detachInterrupt();
    }
    bool isEnabled(void) {
        return instance().isEnabled();
   d79d0:	4810      	ldr	r0, [pc, #64]	; (d7a14 <pinAvailable+0x68>)
   d79d2:	f7fe fc1f 	bl	d6214 <_ZN8SPIClass9isEnabledEv>

  // SPI safety check
#ifndef SPARK_WIRING_NO_SPI
  if(SPI.isEnabled() == true && (pin == SCK || pin == MOSI || pin == MISO))
   d79d6:	b128      	cbz	r0, d79e4 <pinAvailable+0x38>
   d79d8:	f1a4 030b 	sub.w	r3, r4, #11
   d79dc:	2b02      	cmp	r3, #2
   d79de:	d801      	bhi.n	d79e4 <pinAvailable+0x38>
  {
    return 0; // 'pin' is used
   d79e0:	2000      	movs	r0, #0
   d79e2:	bd70      	pop	{r4, r5, r6, pc}
  }
#endif
  // I2C safety check
#ifndef SPARK_WIRING_NO_I2C
  if(Wire.isEnabled() == true && (pin == SCL || pin == SDA))
   d79e4:	f000 f85c 	bl	d7aa0 <_Z19__fetch_global_Wirev>
   d79e8:	f7ff fb74 	bl	d70d4 <_ZN7TwoWire9isEnabledEv>
   d79ec:	b108      	cbz	r0, d79f2 <pinAvailable+0x46>
   d79ee:	2c01      	cmp	r4, #1
   d79f0:	d9f6      	bls.n	d79e0 <pinAvailable+0x34>
    return 0; // 'pin' is used
  }
#endif
#ifndef SPARK_WIRING_NO_USART_SERIAL
  // Serial1 safety check
  if(Serial1.isEnabled() == true && (pin == RX || pin == TX))
   d79f2:	f7ff fb0b 	bl	d700c <_Z22__fetch_global_Serial1v>
   d79f6:	f7ff fb05 	bl	d7004 <_ZN11USARTSerial9isEnabledEv>
   d79fa:	b118      	cbz	r0, d7a04 <pinAvailable+0x58>
   d79fc:	f1a4 0309 	sub.w	r3, r4, #9
   d7a00:	2b01      	cmp	r3, #1
   d7a02:	d9ed      	bls.n	d79e0 <pinAvailable+0x34>
  {
    return 0; // 'pin' is used
  }
#endif

  if (pin >= TOTAL_PINS)
   d7a04:	2c23      	cmp	r4, #35	; 0x23
   d7a06:	bf8c      	ite	hi
   d7a08:	2000      	movhi	r0, #0
   d7a0a:	2001      	movls	r0, #1
    return 0;
  else
    return 1; // 'pin' is available
}
   d7a0c:	bd70      	pop	{r4, r5, r6, pc}
   d7a0e:	bf00      	nop
   d7a10:	2003e5fc 	.word	0x2003e5fc
   d7a14:	2003e600 	.word	0x2003e600

000d7a18 <pinMode>:
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
   d7a18:	2823      	cmp	r0, #35	; 0x23
/*
 * @brief Set the mode of the pin to OUTPUT, INPUT, INPUT_PULLUP,
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{
   d7a1a:	b538      	push	{r3, r4, r5, lr}
   d7a1c:	4604      	mov	r4, r0
   d7a1e:	460d      	mov	r5, r1

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
   d7a20:	d80a      	bhi.n	d7a38 <pinMode+0x20>
   d7a22:	29ff      	cmp	r1, #255	; 0xff
   d7a24:	d008      	beq.n	d7a38 <pinMode+0x20>
  {
    return;
  }

  // Safety check
  if( !pinAvailable(pin) ) {
   d7a26:	f7ff ffc1 	bl	d79ac <pinAvailable>
   d7a2a:	b128      	cbz	r0, d7a38 <pinMode+0x20>
    return;
  }

  HAL_Pin_Mode(pin, setMode);
   d7a2c:	4629      	mov	r1, r5
   d7a2e:	4620      	mov	r0, r4
}
   d7a30:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_Pin_Mode(pin, setMode);
   d7a34:	f7fe b8d2 	b.w	d5bdc <HAL_Pin_Mode>
   d7a38:	bd38      	pop	{r3, r4, r5, pc}

000d7a3a <digitalWrite>:

/*
 * @brief Sets a GPIO pin to HIGH or LOW.
 */
void digitalWrite(pin_t pin, uint8_t value)
{
   d7a3a:	b538      	push	{r3, r4, r5, lr}
   d7a3c:	4604      	mov	r4, r0
   d7a3e:	460d      	mov	r5, r1
    PinMode mode = HAL_Get_Pin_Mode(pin);
   d7a40:	f7fe f8d4 	bl	d5bec <HAL_Get_Pin_Mode>
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
   d7a44:	28ff      	cmp	r0, #255	; 0xff
   d7a46:	d010      	beq.n	d7a6a <digitalWrite+0x30>
}

inline bool is_input_mode(PinMode mode) {
    return  mode == INPUT ||
            mode == INPUT_PULLUP ||
            mode == INPUT_PULLDOWN ||
   d7a48:	2806      	cmp	r0, #6
   d7a4a:	d804      	bhi.n	d7a56 <digitalWrite+0x1c>
   d7a4c:	234d      	movs	r3, #77	; 0x4d
   d7a4e:	fa23 f000 	lsr.w	r0, r3, r0
   d7a52:	07c3      	lsls	r3, r0, #31
   d7a54:	d409      	bmi.n	d7a6a <digitalWrite+0x30>
{
    PinMode mode = HAL_Get_Pin_Mode(pin);
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
        return;
  // Safety check
  if( !pinAvailable(pin) ) {
   d7a56:	4620      	mov	r0, r4
   d7a58:	f7ff ffa8 	bl	d79ac <pinAvailable>
   d7a5c:	b128      	cbz	r0, d7a6a <digitalWrite+0x30>
    return;
  }

  HAL_GPIO_Write(pin, value);
   d7a5e:	4629      	mov	r1, r5
   d7a60:	4620      	mov	r0, r4
}
   d7a62:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_GPIO_Write(pin, value);
   d7a66:	f7fe b8c9 	b.w	d5bfc <HAL_GPIO_Write>
   d7a6a:	bd38      	pop	{r3, r4, r5, pc}

000d7a6c <_Z17acquireWireBufferv>:
   d7a6c:	b570      	push	{r4, r5, r6, lr}
   d7a6e:	4604      	mov	r4, r0
   d7a70:	2514      	movs	r5, #20
   d7a72:	462a      	mov	r2, r5
   d7a74:	4e09      	ldr	r6, [pc, #36]	; (d7a9c <_Z17acquireWireBufferv+0x30>)
   d7a76:	2100      	movs	r1, #0
   d7a78:	f000 faf3 	bl	d8062 <memset>
   d7a7c:	8025      	strh	r5, [r4, #0]
   d7a7e:	2520      	movs	r5, #32
   d7a80:	4631      	mov	r1, r6
   d7a82:	60a5      	str	r5, [r4, #8]
   d7a84:	6125      	str	r5, [r4, #16]
   d7a86:	4628      	mov	r0, r5
   d7a88:	f000 f840 	bl	d7b0c <_ZnajRKSt9nothrow_t>
   d7a8c:	4631      	mov	r1, r6
   d7a8e:	6060      	str	r0, [r4, #4]
   d7a90:	4628      	mov	r0, r5
   d7a92:	f000 f83b 	bl	d7b0c <_ZnajRKSt9nothrow_t>
   d7a96:	60e0      	str	r0, [r4, #12]
   d7a98:	4620      	mov	r0, r4
   d7a9a:	bd70      	pop	{r4, r5, r6, pc}
   d7a9c:	000da988 	.word	0x000da988

000d7aa0 <_Z19__fetch_global_Wirev>:
	return defaultWireConfig();
}
#endif

TwoWire& __fetch_global_Wire()
{
   d7aa0:	b530      	push	{r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
   d7aa2:	4d0e      	ldr	r5, [pc, #56]	; (d7adc <_Z19__fetch_global_Wirev+0x3c>)
   d7aa4:	6829      	ldr	r1, [r5, #0]
   d7aa6:	f011 0401 	ands.w	r4, r1, #1
	return defaultWireConfig();
}
#endif

TwoWire& __fetch_global_Wire()
{
   d7aaa:	b087      	sub	sp, #28
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
   d7aac:	d113      	bne.n	d7ad6 <_Z19__fetch_global_Wirev+0x36>
   d7aae:	4628      	mov	r0, r5
   d7ab0:	f7fc fb02 	bl	d40b8 <__cxa_guard_acquire>
   d7ab4:	b178      	cbz	r0, d7ad6 <_Z19__fetch_global_Wirev+0x36>
   d7ab6:	a801      	add	r0, sp, #4
   d7ab8:	f7ff ffd8 	bl	d7a6c <_Z17acquireWireBufferv>
   d7abc:	aa01      	add	r2, sp, #4
   d7abe:	4621      	mov	r1, r4
   d7ac0:	4807      	ldr	r0, [pc, #28]	; (d7ae0 <_Z19__fetch_global_Wirev+0x40>)
   d7ac2:	f7ff faf5 	bl	d70b0 <_ZN7TwoWireC1E17HAL_I2C_InterfaceRK14HAL_I2C_Config>
   d7ac6:	4628      	mov	r0, r5
   d7ac8:	f7fc fafb 	bl	d40c2 <__cxa_guard_release>
   d7acc:	4a05      	ldr	r2, [pc, #20]	; (d7ae4 <_Z19__fetch_global_Wirev+0x44>)
   d7ace:	4906      	ldr	r1, [pc, #24]	; (d7ae8 <_Z19__fetch_global_Wirev+0x48>)
   d7ad0:	4803      	ldr	r0, [pc, #12]	; (d7ae0 <_Z19__fetch_global_Wirev+0x40>)
   d7ad2:	f000 f80b 	bl	d7aec <__aeabi_atexit>
	return wire;
}
   d7ad6:	4802      	ldr	r0, [pc, #8]	; (d7ae0 <_Z19__fetch_global_Wirev+0x40>)
   d7ad8:	b007      	add	sp, #28
   d7ada:	bd30      	pop	{r4, r5, pc}
   d7adc:	2003e60c 	.word	0x2003e60c
   d7ae0:	2003e610 	.word	0x2003e610
   d7ae4:	20034a40 	.word	0x20034a40
   d7ae8:	000d7059 	.word	0x000d7059

000d7aec <__aeabi_atexit>:
   d7aec:	460b      	mov	r3, r1
   d7aee:	4601      	mov	r1, r0
   d7af0:	4618      	mov	r0, r3
   d7af2:	f000 b9a5 	b.w	d7e40 <__cxa_atexit>
	...

000d7af8 <_ZSt15get_new_handlerv>:
   d7af8:	4b02      	ldr	r3, [pc, #8]	; (d7b04 <_ZSt15get_new_handlerv+0xc>)
   d7afa:	6818      	ldr	r0, [r3, #0]
   d7afc:	f3bf 8f5f 	dmb	sy
   d7b00:	4770      	bx	lr
   d7b02:	bf00      	nop
   d7b04:	2003e624 	.word	0x2003e624

000d7b08 <_ZdlPvj>:
   d7b08:	f7fc bac7 	b.w	d409a <_ZdlPv>

000d7b0c <_ZnajRKSt9nothrow_t>:
   d7b0c:	f000 b800 	b.w	d7b10 <_ZnwjRKSt9nothrow_t>

000d7b10 <_ZnwjRKSt9nothrow_t>:
   d7b10:	b510      	push	{r4, lr}
   d7b12:	2800      	cmp	r0, #0
   d7b14:	bf14      	ite	ne
   d7b16:	4604      	movne	r4, r0
   d7b18:	2401      	moveq	r4, #1
   d7b1a:	4620      	mov	r0, r4
   d7b1c:	f7fe fae2 	bl	d60e4 <malloc>
   d7b20:	b920      	cbnz	r0, d7b2c <_ZnwjRKSt9nothrow_t+0x1c>
   d7b22:	f7ff ffe9 	bl	d7af8 <_ZSt15get_new_handlerv>
   d7b26:	b108      	cbz	r0, d7b2c <_ZnwjRKSt9nothrow_t+0x1c>
   d7b28:	4780      	blx	r0
   d7b2a:	e7f6      	b.n	d7b1a <_ZnwjRKSt9nothrow_t+0xa>
   d7b2c:	bd10      	pop	{r4, pc}
	...

000d7b30 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
   d7b30:	4b18      	ldr	r3, [pc, #96]	; (d7b94 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
   d7b32:	681a      	ldr	r2, [r3, #0]
   d7b34:	07d1      	lsls	r1, r2, #31
   d7b36:	bf5c      	itt	pl
   d7b38:	2201      	movpl	r2, #1
   d7b3a:	601a      	strpl	r2, [r3, #0]
   d7b3c:	4b16      	ldr	r3, [pc, #88]	; (d7b98 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
   d7b3e:	681a      	ldr	r2, [r3, #0]
   d7b40:	07d2      	lsls	r2, r2, #31
   d7b42:	bf5c      	itt	pl
   d7b44:	2201      	movpl	r2, #1
   d7b46:	601a      	strpl	r2, [r3, #0]
   d7b48:	4b14      	ldr	r3, [pc, #80]	; (d7b9c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
   d7b4a:	681a      	ldr	r2, [r3, #0]
   d7b4c:	07d0      	lsls	r0, r2, #31
   d7b4e:	bf5c      	itt	pl
   d7b50:	2201      	movpl	r2, #1
   d7b52:	601a      	strpl	r2, [r3, #0]
   d7b54:	4b12      	ldr	r3, [pc, #72]	; (d7ba0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
   d7b56:	681a      	ldr	r2, [r3, #0]
   d7b58:	07d1      	lsls	r1, r2, #31
   d7b5a:	bf5c      	itt	pl
   d7b5c:	2201      	movpl	r2, #1
   d7b5e:	601a      	strpl	r2, [r3, #0]
   d7b60:	4b10      	ldr	r3, [pc, #64]	; (d7ba4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
   d7b62:	681a      	ldr	r2, [r3, #0]
   d7b64:	07d2      	lsls	r2, r2, #31
   d7b66:	bf5c      	itt	pl
   d7b68:	2201      	movpl	r2, #1
   d7b6a:	601a      	strpl	r2, [r3, #0]
   d7b6c:	4b0e      	ldr	r3, [pc, #56]	; (d7ba8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
   d7b6e:	681a      	ldr	r2, [r3, #0]
   d7b70:	07d0      	lsls	r0, r2, #31
   d7b72:	bf5c      	itt	pl
   d7b74:	2201      	movpl	r2, #1
   d7b76:	601a      	strpl	r2, [r3, #0]
   d7b78:	4b0c      	ldr	r3, [pc, #48]	; (d7bac <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
   d7b7a:	681a      	ldr	r2, [r3, #0]
   d7b7c:	07d1      	lsls	r1, r2, #31
   d7b7e:	bf5c      	itt	pl
   d7b80:	2201      	movpl	r2, #1
   d7b82:	601a      	strpl	r2, [r3, #0]
   d7b84:	4b0a      	ldr	r3, [pc, #40]	; (d7bb0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
   d7b86:	681a      	ldr	r2, [r3, #0]
   d7b88:	07d2      	lsls	r2, r2, #31
   d7b8a:	bf5c      	itt	pl
   d7b8c:	2201      	movpl	r2, #1
   d7b8e:	601a      	strpl	r2, [r3, #0]
   d7b90:	4770      	bx	lr
   d7b92:	bf00      	nop
   d7b94:	2003e644 	.word	0x2003e644
   d7b98:	2003e640 	.word	0x2003e640
   d7b9c:	2003e63c 	.word	0x2003e63c
   d7ba0:	2003e638 	.word	0x2003e638
   d7ba4:	2003e634 	.word	0x2003e634
   d7ba8:	2003e630 	.word	0x2003e630
   d7bac:	2003e62c 	.word	0x2003e62c
   d7bb0:	2003e628 	.word	0x2003e628

000d7bb4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj>:
   d7bb4:	4b24      	ldr	r3, [pc, #144]	; (d7c48 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x94>)
   d7bb6:	681a      	ldr	r2, [r3, #0]
   d7bb8:	07d0      	lsls	r0, r2, #31
   d7bba:	bf5c      	itt	pl
   d7bbc:	2201      	movpl	r2, #1
   d7bbe:	601a      	strpl	r2, [r3, #0]
   d7bc0:	4b22      	ldr	r3, [pc, #136]	; (d7c4c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x98>)
   d7bc2:	681a      	ldr	r2, [r3, #0]
   d7bc4:	07d1      	lsls	r1, r2, #31
   d7bc6:	bf5c      	itt	pl
   d7bc8:	2201      	movpl	r2, #1
   d7bca:	601a      	strpl	r2, [r3, #0]
   d7bcc:	4b20      	ldr	r3, [pc, #128]	; (d7c50 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x9c>)
   d7bce:	681a      	ldr	r2, [r3, #0]
   d7bd0:	07d2      	lsls	r2, r2, #31
   d7bd2:	bf5c      	itt	pl
   d7bd4:	2201      	movpl	r2, #1
   d7bd6:	601a      	strpl	r2, [r3, #0]
   d7bd8:	4b1e      	ldr	r3, [pc, #120]	; (d7c54 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa0>)
   d7bda:	681a      	ldr	r2, [r3, #0]
   d7bdc:	07d0      	lsls	r0, r2, #31
   d7bde:	bf5c      	itt	pl
   d7be0:	2201      	movpl	r2, #1
   d7be2:	601a      	strpl	r2, [r3, #0]
   d7be4:	4b1c      	ldr	r3, [pc, #112]	; (d7c58 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa4>)
   d7be6:	681a      	ldr	r2, [r3, #0]
   d7be8:	07d1      	lsls	r1, r2, #31
   d7bea:	bf5c      	itt	pl
   d7bec:	2201      	movpl	r2, #1
   d7bee:	601a      	strpl	r2, [r3, #0]
   d7bf0:	4b1a      	ldr	r3, [pc, #104]	; (d7c5c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa8>)
   d7bf2:	681a      	ldr	r2, [r3, #0]
   d7bf4:	07d2      	lsls	r2, r2, #31
   d7bf6:	bf5c      	itt	pl
   d7bf8:	2201      	movpl	r2, #1
   d7bfa:	601a      	strpl	r2, [r3, #0]
   d7bfc:	4b18      	ldr	r3, [pc, #96]	; (d7c60 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xac>)
   d7bfe:	681a      	ldr	r2, [r3, #0]
   d7c00:	07d0      	lsls	r0, r2, #31
   d7c02:	bf5c      	itt	pl
   d7c04:	2201      	movpl	r2, #1
   d7c06:	601a      	strpl	r2, [r3, #0]
   d7c08:	4b16      	ldr	r3, [pc, #88]	; (d7c64 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb0>)
   d7c0a:	681a      	ldr	r2, [r3, #0]
   d7c0c:	07d1      	lsls	r1, r2, #31
   d7c0e:	bf5c      	itt	pl
   d7c10:	2201      	movpl	r2, #1
   d7c12:	601a      	strpl	r2, [r3, #0]
   d7c14:	4b14      	ldr	r3, [pc, #80]	; (d7c68 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb4>)
   d7c16:	681a      	ldr	r2, [r3, #0]
   d7c18:	07d2      	lsls	r2, r2, #31
   d7c1a:	bf5c      	itt	pl
   d7c1c:	2201      	movpl	r2, #1
   d7c1e:	601a      	strpl	r2, [r3, #0]
   d7c20:	4b12      	ldr	r3, [pc, #72]	; (d7c6c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb8>)
   d7c22:	681a      	ldr	r2, [r3, #0]
   d7c24:	07d0      	lsls	r0, r2, #31
   d7c26:	bf5c      	itt	pl
   d7c28:	2201      	movpl	r2, #1
   d7c2a:	601a      	strpl	r2, [r3, #0]
   d7c2c:	4b10      	ldr	r3, [pc, #64]	; (d7c70 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xbc>)
   d7c2e:	681a      	ldr	r2, [r3, #0]
   d7c30:	07d1      	lsls	r1, r2, #31
   d7c32:	bf5c      	itt	pl
   d7c34:	2201      	movpl	r2, #1
   d7c36:	601a      	strpl	r2, [r3, #0]
   d7c38:	4b0e      	ldr	r3, [pc, #56]	; (d7c74 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xc0>)
   d7c3a:	681a      	ldr	r2, [r3, #0]
   d7c3c:	07d2      	lsls	r2, r2, #31
   d7c3e:	bf5c      	itt	pl
   d7c40:	2201      	movpl	r2, #1
   d7c42:	601a      	strpl	r2, [r3, #0]
   d7c44:	4770      	bx	lr
   d7c46:	bf00      	nop
   d7c48:	2003e674 	.word	0x2003e674
   d7c4c:	2003e670 	.word	0x2003e670
   d7c50:	2003e66c 	.word	0x2003e66c
   d7c54:	2003e668 	.word	0x2003e668
   d7c58:	2003e664 	.word	0x2003e664
   d7c5c:	2003e660 	.word	0x2003e660
   d7c60:	2003e65c 	.word	0x2003e65c
   d7c64:	2003e658 	.word	0x2003e658
   d7c68:	2003e654 	.word	0x2003e654
   d7c6c:	2003e650 	.word	0x2003e650
   d7c70:	2003e64c 	.word	0x2003e64c
   d7c74:	2003e648 	.word	0x2003e648

000d7c78 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj>:
   d7c78:	4b24      	ldr	r3, [pc, #144]	; (d7d0c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x94>)
   d7c7a:	681a      	ldr	r2, [r3, #0]
   d7c7c:	07d0      	lsls	r0, r2, #31
   d7c7e:	bf5c      	itt	pl
   d7c80:	2201      	movpl	r2, #1
   d7c82:	601a      	strpl	r2, [r3, #0]
   d7c84:	4b22      	ldr	r3, [pc, #136]	; (d7d10 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x98>)
   d7c86:	681a      	ldr	r2, [r3, #0]
   d7c88:	07d1      	lsls	r1, r2, #31
   d7c8a:	bf5c      	itt	pl
   d7c8c:	2201      	movpl	r2, #1
   d7c8e:	601a      	strpl	r2, [r3, #0]
   d7c90:	4b20      	ldr	r3, [pc, #128]	; (d7d14 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x9c>)
   d7c92:	681a      	ldr	r2, [r3, #0]
   d7c94:	07d2      	lsls	r2, r2, #31
   d7c96:	bf5c      	itt	pl
   d7c98:	2201      	movpl	r2, #1
   d7c9a:	601a      	strpl	r2, [r3, #0]
   d7c9c:	4b1e      	ldr	r3, [pc, #120]	; (d7d18 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa0>)
   d7c9e:	681a      	ldr	r2, [r3, #0]
   d7ca0:	07d0      	lsls	r0, r2, #31
   d7ca2:	bf5c      	itt	pl
   d7ca4:	2201      	movpl	r2, #1
   d7ca6:	601a      	strpl	r2, [r3, #0]
   d7ca8:	4b1c      	ldr	r3, [pc, #112]	; (d7d1c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa4>)
   d7caa:	681a      	ldr	r2, [r3, #0]
   d7cac:	07d1      	lsls	r1, r2, #31
   d7cae:	bf5c      	itt	pl
   d7cb0:	2201      	movpl	r2, #1
   d7cb2:	601a      	strpl	r2, [r3, #0]
   d7cb4:	4b1a      	ldr	r3, [pc, #104]	; (d7d20 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa8>)
   d7cb6:	681a      	ldr	r2, [r3, #0]
   d7cb8:	07d2      	lsls	r2, r2, #31
   d7cba:	bf5c      	itt	pl
   d7cbc:	2201      	movpl	r2, #1
   d7cbe:	601a      	strpl	r2, [r3, #0]
   d7cc0:	4b18      	ldr	r3, [pc, #96]	; (d7d24 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xac>)
   d7cc2:	681a      	ldr	r2, [r3, #0]
   d7cc4:	07d0      	lsls	r0, r2, #31
   d7cc6:	bf5c      	itt	pl
   d7cc8:	2201      	movpl	r2, #1
   d7cca:	601a      	strpl	r2, [r3, #0]
   d7ccc:	4b16      	ldr	r3, [pc, #88]	; (d7d28 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb0>)
   d7cce:	681a      	ldr	r2, [r3, #0]
   d7cd0:	07d1      	lsls	r1, r2, #31
   d7cd2:	bf5c      	itt	pl
   d7cd4:	2201      	movpl	r2, #1
   d7cd6:	601a      	strpl	r2, [r3, #0]
   d7cd8:	4b14      	ldr	r3, [pc, #80]	; (d7d2c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb4>)
   d7cda:	681a      	ldr	r2, [r3, #0]
   d7cdc:	07d2      	lsls	r2, r2, #31
   d7cde:	bf5c      	itt	pl
   d7ce0:	2201      	movpl	r2, #1
   d7ce2:	601a      	strpl	r2, [r3, #0]
   d7ce4:	4b12      	ldr	r3, [pc, #72]	; (d7d30 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb8>)
   d7ce6:	681a      	ldr	r2, [r3, #0]
   d7ce8:	07d0      	lsls	r0, r2, #31
   d7cea:	bf5c      	itt	pl
   d7cec:	2201      	movpl	r2, #1
   d7cee:	601a      	strpl	r2, [r3, #0]
   d7cf0:	4b10      	ldr	r3, [pc, #64]	; (d7d34 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xbc>)
   d7cf2:	681a      	ldr	r2, [r3, #0]
   d7cf4:	07d1      	lsls	r1, r2, #31
   d7cf6:	bf5c      	itt	pl
   d7cf8:	2201      	movpl	r2, #1
   d7cfa:	601a      	strpl	r2, [r3, #0]
   d7cfc:	4b0e      	ldr	r3, [pc, #56]	; (d7d38 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xc0>)
   d7cfe:	681a      	ldr	r2, [r3, #0]
   d7d00:	07d2      	lsls	r2, r2, #31
   d7d02:	bf5c      	itt	pl
   d7d04:	2201      	movpl	r2, #1
   d7d06:	601a      	strpl	r2, [r3, #0]
   d7d08:	4770      	bx	lr
   d7d0a:	bf00      	nop
   d7d0c:	2003e6a4 	.word	0x2003e6a4
   d7d10:	2003e6a0 	.word	0x2003e6a0
   d7d14:	2003e69c 	.word	0x2003e69c
   d7d18:	2003e698 	.word	0x2003e698
   d7d1c:	2003e694 	.word	0x2003e694
   d7d20:	2003e690 	.word	0x2003e690
   d7d24:	2003e68c 	.word	0x2003e68c
   d7d28:	2003e688 	.word	0x2003e688
   d7d2c:	2003e684 	.word	0x2003e684
   d7d30:	2003e680 	.word	0x2003e680
   d7d34:	2003e67c 	.word	0x2003e67c
   d7d38:	2003e678 	.word	0x2003e678

000d7d3c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
   d7d3c:	4b18      	ldr	r3, [pc, #96]	; (d7da0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
   d7d3e:	681a      	ldr	r2, [r3, #0]
   d7d40:	07d1      	lsls	r1, r2, #31
   d7d42:	bf5c      	itt	pl
   d7d44:	2201      	movpl	r2, #1
   d7d46:	601a      	strpl	r2, [r3, #0]
   d7d48:	4b16      	ldr	r3, [pc, #88]	; (d7da4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
   d7d4a:	681a      	ldr	r2, [r3, #0]
   d7d4c:	07d2      	lsls	r2, r2, #31
   d7d4e:	bf5c      	itt	pl
   d7d50:	2201      	movpl	r2, #1
   d7d52:	601a      	strpl	r2, [r3, #0]
   d7d54:	4b14      	ldr	r3, [pc, #80]	; (d7da8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
   d7d56:	681a      	ldr	r2, [r3, #0]
   d7d58:	07d0      	lsls	r0, r2, #31
   d7d5a:	bf5c      	itt	pl
   d7d5c:	2201      	movpl	r2, #1
   d7d5e:	601a      	strpl	r2, [r3, #0]
   d7d60:	4b12      	ldr	r3, [pc, #72]	; (d7dac <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
   d7d62:	681a      	ldr	r2, [r3, #0]
   d7d64:	07d1      	lsls	r1, r2, #31
   d7d66:	bf5c      	itt	pl
   d7d68:	2201      	movpl	r2, #1
   d7d6a:	601a      	strpl	r2, [r3, #0]
   d7d6c:	4b10      	ldr	r3, [pc, #64]	; (d7db0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
   d7d6e:	681a      	ldr	r2, [r3, #0]
   d7d70:	07d2      	lsls	r2, r2, #31
   d7d72:	bf5c      	itt	pl
   d7d74:	2201      	movpl	r2, #1
   d7d76:	601a      	strpl	r2, [r3, #0]
   d7d78:	4b0e      	ldr	r3, [pc, #56]	; (d7db4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
   d7d7a:	681a      	ldr	r2, [r3, #0]
   d7d7c:	07d0      	lsls	r0, r2, #31
   d7d7e:	bf5c      	itt	pl
   d7d80:	2201      	movpl	r2, #1
   d7d82:	601a      	strpl	r2, [r3, #0]
   d7d84:	4b0c      	ldr	r3, [pc, #48]	; (d7db8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
   d7d86:	681a      	ldr	r2, [r3, #0]
   d7d88:	07d1      	lsls	r1, r2, #31
   d7d8a:	bf5c      	itt	pl
   d7d8c:	2201      	movpl	r2, #1
   d7d8e:	601a      	strpl	r2, [r3, #0]
   d7d90:	4b0a      	ldr	r3, [pc, #40]	; (d7dbc <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
   d7d92:	681a      	ldr	r2, [r3, #0]
   d7d94:	07d2      	lsls	r2, r2, #31
   d7d96:	bf5c      	itt	pl
   d7d98:	2201      	movpl	r2, #1
   d7d9a:	601a      	strpl	r2, [r3, #0]
   d7d9c:	4770      	bx	lr
   d7d9e:	bf00      	nop
   d7da0:	2003e6c4 	.word	0x2003e6c4
   d7da4:	2003e6c0 	.word	0x2003e6c0
   d7da8:	2003e6bc 	.word	0x2003e6bc
   d7dac:	2003e6b8 	.word	0x2003e6b8
   d7db0:	2003e6b4 	.word	0x2003e6b4
   d7db4:	2003e6b0 	.word	0x2003e6b0
   d7db8:	2003e6ac 	.word	0x2003e6ac
   d7dbc:	2003e6a8 	.word	0x2003e6a8

000d7dc0 <asctime>:
   d7dc0:	4b09      	ldr	r3, [pc, #36]	; (d7de8 <asctime+0x28>)
   d7dc2:	b570      	push	{r4, r5, r6, lr}
   d7dc4:	681c      	ldr	r4, [r3, #0]
   d7dc6:	6c25      	ldr	r5, [r4, #64]	; 0x40
   d7dc8:	4606      	mov	r6, r0
   d7dca:	b93d      	cbnz	r5, d7ddc <asctime+0x1c>
   d7dcc:	201a      	movs	r0, #26
   d7dce:	f7fe f989 	bl	d60e4 <malloc>
   d7dd2:	221a      	movs	r2, #26
   d7dd4:	6420      	str	r0, [r4, #64]	; 0x40
   d7dd6:	4629      	mov	r1, r5
   d7dd8:	f000 f943 	bl	d8062 <memset>
   d7ddc:	6c21      	ldr	r1, [r4, #64]	; 0x40
   d7dde:	4630      	mov	r0, r6
   d7de0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   d7de4:	f000 b802 	b.w	d7dec <asctime_r>
   d7de8:	200349f0 	.word	0x200349f0

000d7dec <asctime_r>:
   d7dec:	b510      	push	{r4, lr}
   d7dee:	460c      	mov	r4, r1
   d7df0:	6941      	ldr	r1, [r0, #20]
   d7df2:	6903      	ldr	r3, [r0, #16]
   d7df4:	6982      	ldr	r2, [r0, #24]
   d7df6:	b086      	sub	sp, #24
   d7df8:	f201 716c 	addw	r1, r1, #1900	; 0x76c
   d7dfc:	9104      	str	r1, [sp, #16]
   d7dfe:	6801      	ldr	r1, [r0, #0]
   d7e00:	9103      	str	r1, [sp, #12]
   d7e02:	6841      	ldr	r1, [r0, #4]
   d7e04:	9102      	str	r1, [sp, #8]
   d7e06:	6881      	ldr	r1, [r0, #8]
   d7e08:	9101      	str	r1, [sp, #4]
   d7e0a:	68c1      	ldr	r1, [r0, #12]
   d7e0c:	9100      	str	r1, [sp, #0]
   d7e0e:	4907      	ldr	r1, [pc, #28]	; (d7e2c <asctime_r+0x40>)
   d7e10:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   d7e14:	440b      	add	r3, r1
   d7e16:	4906      	ldr	r1, [pc, #24]	; (d7e30 <asctime_r+0x44>)
   d7e18:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   d7e1c:	440a      	add	r2, r1
   d7e1e:	4620      	mov	r0, r4
   d7e20:	4904      	ldr	r1, [pc, #16]	; (d7e34 <asctime_r+0x48>)
   d7e22:	f7fe f977 	bl	d6114 <siprintf>
   d7e26:	4620      	mov	r0, r4
   d7e28:	b006      	add	sp, #24
   d7e2a:	bd10      	pop	{r4, pc}
   d7e2c:	000da99e 	.word	0x000da99e
   d7e30:	000da989 	.word	0x000da989
   d7e34:	000da9c2 	.word	0x000da9c2

000d7e38 <atoi>:
   d7e38:	220a      	movs	r2, #10
   d7e3a:	2100      	movs	r1, #0
   d7e3c:	f000 bf2c 	b.w	d8c98 <strtol>

000d7e40 <__cxa_atexit>:
   d7e40:	b510      	push	{r4, lr}
   d7e42:	4c05      	ldr	r4, [pc, #20]	; (d7e58 <__cxa_atexit+0x18>)
   d7e44:	4613      	mov	r3, r2
   d7e46:	b12c      	cbz	r4, d7e54 <__cxa_atexit+0x14>
   d7e48:	460a      	mov	r2, r1
   d7e4a:	4601      	mov	r1, r0
   d7e4c:	2002      	movs	r0, #2
   d7e4e:	f3af 8000 	nop.w
   d7e52:	bd10      	pop	{r4, pc}
   d7e54:	4620      	mov	r0, r4
   d7e56:	bd10      	pop	{r4, pc}
   d7e58:	00000000 	.word	0x00000000

000d7e5c <localtime>:
   d7e5c:	b538      	push	{r3, r4, r5, lr}
   d7e5e:	4b07      	ldr	r3, [pc, #28]	; (d7e7c <localtime+0x20>)
   d7e60:	681c      	ldr	r4, [r3, #0]
   d7e62:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   d7e64:	4605      	mov	r5, r0
   d7e66:	b91b      	cbnz	r3, d7e70 <localtime+0x14>
   d7e68:	2024      	movs	r0, #36	; 0x24
   d7e6a:	f7fe f93b 	bl	d60e4 <malloc>
   d7e6e:	63e0      	str	r0, [r4, #60]	; 0x3c
   d7e70:	6be1      	ldr	r1, [r4, #60]	; 0x3c
   d7e72:	4628      	mov	r0, r5
   d7e74:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   d7e78:	f000 b802 	b.w	d7e80 <localtime_r>
   d7e7c:	200349f0 	.word	0x200349f0

000d7e80 <localtime_r>:
   d7e80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   d7e84:	460c      	mov	r4, r1
   d7e86:	4680      	mov	r8, r0
   d7e88:	f001 fa2c 	bl	d92e4 <__gettzinfo>
   d7e8c:	4621      	mov	r1, r4
   d7e8e:	4607      	mov	r7, r0
   d7e90:	4640      	mov	r0, r8
   d7e92:	f001 fa2b 	bl	d92ec <gmtime_r>
   d7e96:	6946      	ldr	r6, [r0, #20]
   d7e98:	f206 766c 	addw	r6, r6, #1900	; 0x76c
   d7e9c:	07b3      	lsls	r3, r6, #30
   d7e9e:	4604      	mov	r4, r0
   d7ea0:	d105      	bne.n	d7eae <localtime_r+0x2e>
   d7ea2:	2264      	movs	r2, #100	; 0x64
   d7ea4:	fb96 f3f2 	sdiv	r3, r6, r2
   d7ea8:	fb02 6313 	mls	r3, r2, r3, r6
   d7eac:	b94b      	cbnz	r3, d7ec2 <localtime_r+0x42>
   d7eae:	f44f 75c8 	mov.w	r5, #400	; 0x190
   d7eb2:	fb96 f3f5 	sdiv	r3, r6, r5
   d7eb6:	fb05 6513 	mls	r5, r5, r3, r6
   d7eba:	fab5 f385 	clz	r3, r5
   d7ebe:	095b      	lsrs	r3, r3, #5
   d7ec0:	e000      	b.n	d7ec4 <localtime_r+0x44>
   d7ec2:	2301      	movs	r3, #1
   d7ec4:	4a5f      	ldr	r2, [pc, #380]	; (d8044 <localtime_r+0x1c4>)
   d7ec6:	2530      	movs	r5, #48	; 0x30
   d7ec8:	fb05 2503 	mla	r5, r5, r3, r2
   d7ecc:	f001 f83a 	bl	d8f44 <__tz_lock>
   d7ed0:	f001 f83a 	bl	d8f48 <_tzset_unlocked>
   d7ed4:	4b5c      	ldr	r3, [pc, #368]	; (d8048 <localtime_r+0x1c8>)
   d7ed6:	681b      	ldr	r3, [r3, #0]
   d7ed8:	b1f3      	cbz	r3, d7f18 <localtime_r+0x98>
   d7eda:	687b      	ldr	r3, [r7, #4]
   d7edc:	429e      	cmp	r6, r3
   d7ede:	d105      	bne.n	d7eec <localtime_r+0x6c>
   d7ee0:	6839      	ldr	r1, [r7, #0]
   d7ee2:	f8d8 3000 	ldr.w	r3, [r8]
   d7ee6:	69fa      	ldr	r2, [r7, #28]
   d7ee8:	b941      	cbnz	r1, d7efc <localtime_r+0x7c>
   d7eea:	e00a      	b.n	d7f02 <localtime_r+0x82>
   d7eec:	4630      	mov	r0, r6
   d7eee:	f000 ff81 	bl	d8df4 <__tzcalc_limits>
   d7ef2:	2800      	cmp	r0, #0
   d7ef4:	d1f4      	bne.n	d7ee0 <localtime_r+0x60>
   d7ef6:	f04f 33ff 	mov.w	r3, #4294967295
   d7efa:	e00d      	b.n	d7f18 <localtime_r+0x98>
   d7efc:	4293      	cmp	r3, r2
   d7efe:	db08      	blt.n	d7f12 <localtime_r+0x92>
   d7f00:	e001      	b.n	d7f06 <localtime_r+0x86>
   d7f02:	4293      	cmp	r3, r2
   d7f04:	da07      	bge.n	d7f16 <localtime_r+0x96>
   d7f06:	6bba      	ldr	r2, [r7, #56]	; 0x38
   d7f08:	4293      	cmp	r3, r2
   d7f0a:	bfac      	ite	ge
   d7f0c:	2300      	movge	r3, #0
   d7f0e:	2301      	movlt	r3, #1
   d7f10:	e002      	b.n	d7f18 <localtime_r+0x98>
   d7f12:	2300      	movs	r3, #0
   d7f14:	e000      	b.n	d7f18 <localtime_r+0x98>
   d7f16:	2301      	movs	r3, #1
   d7f18:	6223      	str	r3, [r4, #32]
   d7f1a:	6a23      	ldr	r3, [r4, #32]
   d7f1c:	2b01      	cmp	r3, #1
   d7f1e:	bf0c      	ite	eq
   d7f20:	6bf9      	ldreq	r1, [r7, #60]	; 0x3c
   d7f22:	6a39      	ldrne	r1, [r7, #32]
   d7f24:	f44f 6361 	mov.w	r3, #3600	; 0xe10
   d7f28:	203c      	movs	r0, #60	; 0x3c
   d7f2a:	fb91 f6f3 	sdiv	r6, r1, r3
   d7f2e:	fb03 1316 	mls	r3, r3, r6, r1
   d7f32:	6861      	ldr	r1, [r4, #4]
   d7f34:	fb93 f2f0 	sdiv	r2, r3, r0
   d7f38:	fb00 3012 	mls	r0, r0, r2, r3
   d7f3c:	6823      	ldr	r3, [r4, #0]
   d7f3e:	1a89      	subs	r1, r1, r2
   d7f40:	68a2      	ldr	r2, [r4, #8]
   d7f42:	6061      	str	r1, [r4, #4]
   d7f44:	1a1b      	subs	r3, r3, r0
   d7f46:	1b92      	subs	r2, r2, r6
   d7f48:	2b3b      	cmp	r3, #59	; 0x3b
   d7f4a:	6023      	str	r3, [r4, #0]
   d7f4c:	60a2      	str	r2, [r4, #8]
   d7f4e:	dd03      	ble.n	d7f58 <localtime_r+0xd8>
   d7f50:	3101      	adds	r1, #1
   d7f52:	6061      	str	r1, [r4, #4]
   d7f54:	3b3c      	subs	r3, #60	; 0x3c
   d7f56:	e004      	b.n	d7f62 <localtime_r+0xe2>
   d7f58:	2b00      	cmp	r3, #0
   d7f5a:	da03      	bge.n	d7f64 <localtime_r+0xe4>
   d7f5c:	3901      	subs	r1, #1
   d7f5e:	6061      	str	r1, [r4, #4]
   d7f60:	333c      	adds	r3, #60	; 0x3c
   d7f62:	6023      	str	r3, [r4, #0]
   d7f64:	6863      	ldr	r3, [r4, #4]
   d7f66:	2b3b      	cmp	r3, #59	; 0x3b
   d7f68:	dd03      	ble.n	d7f72 <localtime_r+0xf2>
   d7f6a:	3201      	adds	r2, #1
   d7f6c:	60a2      	str	r2, [r4, #8]
   d7f6e:	3b3c      	subs	r3, #60	; 0x3c
   d7f70:	e004      	b.n	d7f7c <localtime_r+0xfc>
   d7f72:	2b00      	cmp	r3, #0
   d7f74:	da03      	bge.n	d7f7e <localtime_r+0xfe>
   d7f76:	3a01      	subs	r2, #1
   d7f78:	60a2      	str	r2, [r4, #8]
   d7f7a:	333c      	adds	r3, #60	; 0x3c
   d7f7c:	6063      	str	r3, [r4, #4]
   d7f7e:	68a3      	ldr	r3, [r4, #8]
   d7f80:	2b17      	cmp	r3, #23
   d7f82:	dd22      	ble.n	d7fca <localtime_r+0x14a>
   d7f84:	69e2      	ldr	r2, [r4, #28]
   d7f86:	3201      	adds	r2, #1
   d7f88:	61e2      	str	r2, [r4, #28]
   d7f8a:	69a2      	ldr	r2, [r4, #24]
   d7f8c:	3201      	adds	r2, #1
   d7f8e:	2a06      	cmp	r2, #6
   d7f90:	bfc8      	it	gt
   d7f92:	2200      	movgt	r2, #0
   d7f94:	61a2      	str	r2, [r4, #24]
   d7f96:	68e2      	ldr	r2, [r4, #12]
   d7f98:	3b18      	subs	r3, #24
   d7f9a:	3201      	adds	r2, #1
   d7f9c:	60a3      	str	r3, [r4, #8]
   d7f9e:	6923      	ldr	r3, [r4, #16]
   d7fa0:	60e2      	str	r2, [r4, #12]
   d7fa2:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
   d7fa6:	428a      	cmp	r2, r1
   d7fa8:	dd46      	ble.n	d8038 <localtime_r+0x1b8>
   d7faa:	3301      	adds	r3, #1
   d7fac:	2b0c      	cmp	r3, #12
   d7fae:	bf0c      	ite	eq
   d7fb0:	6963      	ldreq	r3, [r4, #20]
   d7fb2:	6123      	strne	r3, [r4, #16]
   d7fb4:	eba2 0201 	sub.w	r2, r2, r1
   d7fb8:	60e2      	str	r2, [r4, #12]
   d7fba:	bf01      	itttt	eq
   d7fbc:	3301      	addeq	r3, #1
   d7fbe:	2200      	moveq	r2, #0
   d7fc0:	6122      	streq	r2, [r4, #16]
   d7fc2:	6163      	streq	r3, [r4, #20]
   d7fc4:	bf08      	it	eq
   d7fc6:	61e2      	streq	r2, [r4, #28]
   d7fc8:	e036      	b.n	d8038 <localtime_r+0x1b8>
   d7fca:	2b00      	cmp	r3, #0
   d7fcc:	da34      	bge.n	d8038 <localtime_r+0x1b8>
   d7fce:	69e2      	ldr	r2, [r4, #28]
   d7fd0:	3a01      	subs	r2, #1
   d7fd2:	61e2      	str	r2, [r4, #28]
   d7fd4:	69a2      	ldr	r2, [r4, #24]
   d7fd6:	3a01      	subs	r2, #1
   d7fd8:	bf48      	it	mi
   d7fda:	2206      	movmi	r2, #6
   d7fdc:	61a2      	str	r2, [r4, #24]
   d7fde:	68e2      	ldr	r2, [r4, #12]
   d7fe0:	3318      	adds	r3, #24
   d7fe2:	3a01      	subs	r2, #1
   d7fe4:	60e2      	str	r2, [r4, #12]
   d7fe6:	60a3      	str	r3, [r4, #8]
   d7fe8:	bb32      	cbnz	r2, d8038 <localtime_r+0x1b8>
   d7fea:	6923      	ldr	r3, [r4, #16]
   d7fec:	3b01      	subs	r3, #1
   d7fee:	d401      	bmi.n	d7ff4 <localtime_r+0x174>
   d7ff0:	6123      	str	r3, [r4, #16]
   d7ff2:	e01d      	b.n	d8030 <localtime_r+0x1b0>
   d7ff4:	230b      	movs	r3, #11
   d7ff6:	6123      	str	r3, [r4, #16]
   d7ff8:	6963      	ldr	r3, [r4, #20]
   d7ffa:	1e5a      	subs	r2, r3, #1
   d7ffc:	f012 0f03 	tst.w	r2, #3
   d8000:	6162      	str	r2, [r4, #20]
   d8002:	f203 736b 	addw	r3, r3, #1899	; 0x76b
   d8006:	d105      	bne.n	d8014 <localtime_r+0x194>
   d8008:	2164      	movs	r1, #100	; 0x64
   d800a:	fb93 f2f1 	sdiv	r2, r3, r1
   d800e:	fb01 3212 	mls	r2, r1, r2, r3
   d8012:	b94a      	cbnz	r2, d8028 <localtime_r+0x1a8>
   d8014:	f44f 71c8 	mov.w	r1, #400	; 0x190
   d8018:	fb93 f2f1 	sdiv	r2, r3, r1
   d801c:	fb01 3312 	mls	r3, r1, r2, r3
   d8020:	fab3 f383 	clz	r3, r3
   d8024:	095b      	lsrs	r3, r3, #5
   d8026:	e000      	b.n	d802a <localtime_r+0x1aa>
   d8028:	2301      	movs	r3, #1
   d802a:	f503 73b6 	add.w	r3, r3, #364	; 0x16c
   d802e:	61e3      	str	r3, [r4, #28]
   d8030:	6923      	ldr	r3, [r4, #16]
   d8032:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
   d8036:	60e3      	str	r3, [r4, #12]
   d8038:	f000 ff85 	bl	d8f46 <__tz_unlock>
   d803c:	4620      	mov	r0, r4
   d803e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   d8042:	bf00      	nop
   d8044:	000dab44 	.word	0x000dab44
   d8048:	2003e7e4 	.word	0x2003e7e4

000d804c <memcpy>:
   d804c:	b510      	push	{r4, lr}
   d804e:	1e43      	subs	r3, r0, #1
   d8050:	440a      	add	r2, r1
   d8052:	4291      	cmp	r1, r2
   d8054:	d004      	beq.n	d8060 <memcpy+0x14>
   d8056:	f811 4b01 	ldrb.w	r4, [r1], #1
   d805a:	f803 4f01 	strb.w	r4, [r3, #1]!
   d805e:	e7f8      	b.n	d8052 <memcpy+0x6>
   d8060:	bd10      	pop	{r4, pc}

000d8062 <memset>:
   d8062:	4402      	add	r2, r0
   d8064:	4603      	mov	r3, r0
   d8066:	4293      	cmp	r3, r2
   d8068:	d002      	beq.n	d8070 <memset+0xe>
   d806a:	f803 1b01 	strb.w	r1, [r3], #1
   d806e:	e7fa      	b.n	d8066 <memset+0x4>
   d8070:	4770      	bx	lr
	...

000d8074 <srand>:
   d8074:	b538      	push	{r3, r4, r5, lr}
   d8076:	4b12      	ldr	r3, [pc, #72]	; (d80c0 <srand+0x4c>)
   d8078:	681c      	ldr	r4, [r3, #0]
   d807a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   d807c:	4605      	mov	r5, r0
   d807e:	b9d3      	cbnz	r3, d80b6 <srand+0x42>
   d8080:	2018      	movs	r0, #24
   d8082:	f7fe f82f 	bl	d60e4 <malloc>
   d8086:	f243 330e 	movw	r3, #13070	; 0x330e
   d808a:	63a0      	str	r0, [r4, #56]	; 0x38
   d808c:	8003      	strh	r3, [r0, #0]
   d808e:	f64a 33cd 	movw	r3, #43981	; 0xabcd
   d8092:	8043      	strh	r3, [r0, #2]
   d8094:	f241 2334 	movw	r3, #4660	; 0x1234
   d8098:	8083      	strh	r3, [r0, #4]
   d809a:	f24e 636d 	movw	r3, #58989	; 0xe66d
   d809e:	80c3      	strh	r3, [r0, #6]
   d80a0:	f64d 63ec 	movw	r3, #57068	; 0xdeec
   d80a4:	8103      	strh	r3, [r0, #8]
   d80a6:	2305      	movs	r3, #5
   d80a8:	8143      	strh	r3, [r0, #10]
   d80aa:	230b      	movs	r3, #11
   d80ac:	8183      	strh	r3, [r0, #12]
   d80ae:	2201      	movs	r2, #1
   d80b0:	2300      	movs	r3, #0
   d80b2:	e9c0 2304 	strd	r2, r3, [r0, #16]
   d80b6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   d80b8:	2200      	movs	r2, #0
   d80ba:	611d      	str	r5, [r3, #16]
   d80bc:	615a      	str	r2, [r3, #20]
   d80be:	bd38      	pop	{r3, r4, r5, pc}
   d80c0:	200349f0 	.word	0x200349f0

000d80c4 <strchr>:
   d80c4:	b2c9      	uxtb	r1, r1
   d80c6:	4603      	mov	r3, r0
   d80c8:	f810 2b01 	ldrb.w	r2, [r0], #1
   d80cc:	b11a      	cbz	r2, d80d6 <strchr+0x12>
   d80ce:	4291      	cmp	r1, r2
   d80d0:	d1f9      	bne.n	d80c6 <strchr+0x2>
   d80d2:	4618      	mov	r0, r3
   d80d4:	4770      	bx	lr
   d80d6:	2900      	cmp	r1, #0
   d80d8:	bf0c      	ite	eq
   d80da:	4618      	moveq	r0, r3
   d80dc:	2000      	movne	r0, #0
   d80de:	4770      	bx	lr

000d80e0 <strcmp>:
   d80e0:	f810 2b01 	ldrb.w	r2, [r0], #1
   d80e4:	f811 3b01 	ldrb.w	r3, [r1], #1
   d80e8:	2a01      	cmp	r2, #1
   d80ea:	bf28      	it	cs
   d80ec:	429a      	cmpcs	r2, r3
   d80ee:	d0f7      	beq.n	d80e0 <strcmp>
   d80f0:	1ad0      	subs	r0, r2, r3
   d80f2:	4770      	bx	lr

000d80f4 <strcpy>:
   d80f4:	4603      	mov	r3, r0
   d80f6:	f811 2b01 	ldrb.w	r2, [r1], #1
   d80fa:	f803 2b01 	strb.w	r2, [r3], #1
   d80fe:	2a00      	cmp	r2, #0
   d8100:	d1f9      	bne.n	d80f6 <strcpy+0x2>
   d8102:	4770      	bx	lr

000d8104 <iso_year_adjust>:
   d8104:	6941      	ldr	r1, [r0, #20]
   d8106:	078b      	lsls	r3, r1, #30
   d8108:	b510      	push	{r4, lr}
   d810a:	d10c      	bne.n	d8126 <iso_year_adjust+0x22>
   d810c:	2900      	cmp	r1, #0
   d810e:	f240 736c 	movw	r3, #1900	; 0x76c
   d8112:	bfa8      	it	ge
   d8114:	f06f 0363 	mvnge.w	r3, #99	; 0x63
   d8118:	440b      	add	r3, r1
   d811a:	2464      	movs	r4, #100	; 0x64
   d811c:	fb93 f2f4 	sdiv	r2, r3, r4
   d8120:	fb04 3312 	mls	r3, r4, r2, r3
   d8124:	b983      	cbnz	r3, d8148 <iso_year_adjust+0x44>
   d8126:	2900      	cmp	r1, #0
   d8128:	f240 736c 	movw	r3, #1900	; 0x76c
   d812c:	bfa8      	it	ge
   d812e:	f06f 0363 	mvnge.w	r3, #99	; 0x63
   d8132:	f44f 72c8 	mov.w	r2, #400	; 0x190
   d8136:	440b      	add	r3, r1
   d8138:	fb93 f1f2 	sdiv	r1, r3, r2
   d813c:	fb02 3311 	mls	r3, r2, r1, r3
   d8140:	fab3 f283 	clz	r2, r3
   d8144:	0952      	lsrs	r2, r2, #5
   d8146:	e000      	b.n	d814a <iso_year_adjust+0x46>
   d8148:	2201      	movs	r2, #1
   d814a:	6983      	ldr	r3, [r0, #24]
   d814c:	69c1      	ldr	r1, [r0, #28]
   d814e:	005b      	lsls	r3, r3, #1
   d8150:	eb03 1301 	add.w	r3, r3, r1, lsl #4
   d8154:	4413      	add	r3, r2
   d8156:	2b21      	cmp	r3, #33	; 0x21
   d8158:	dc0e      	bgt.n	d8178 <iso_year_adjust+0x74>
   d815a:	2b20      	cmp	r3, #32
   d815c:	da2f      	bge.n	d81be <iso_year_adjust+0xba>
   d815e:	2b0d      	cmp	r3, #13
   d8160:	dc02      	bgt.n	d8168 <iso_year_adjust+0x64>
   d8162:	2b0a      	cmp	r3, #10
   d8164:	db05      	blt.n	d8172 <iso_year_adjust+0x6e>
   d8166:	e02a      	b.n	d81be <iso_year_adjust+0xba>
   d8168:	2b10      	cmp	r3, #16
   d816a:	db26      	blt.n	d81ba <iso_year_adjust+0xb6>
   d816c:	2b11      	cmp	r3, #17
   d816e:	dd26      	ble.n	d81be <iso_year_adjust+0xba>
   d8170:	3b1c      	subs	r3, #28
   d8172:	2b01      	cmp	r3, #1
   d8174:	d923      	bls.n	d81be <iso_year_adjust+0xba>
   d8176:	e020      	b.n	d81ba <iso_year_adjust+0xb6>
   d8178:	f241 62c6 	movw	r2, #5830	; 0x16c6
   d817c:	4293      	cmp	r3, r2
   d817e:	dc0e      	bgt.n	d819e <iso_year_adjust+0x9a>
   d8180:	f241 62c2 	movw	r2, #5826	; 0x16c2
   d8184:	4293      	cmp	r3, r2
   d8186:	da16      	bge.n	d81b6 <iso_year_adjust+0xb2>
   d8188:	f241 62a2 	movw	r2, #5794	; 0x16a2
   d818c:	4293      	cmp	r3, r2
   d818e:	d012      	beq.n	d81b6 <iso_year_adjust+0xb2>
   d8190:	db13      	blt.n	d81ba <iso_year_adjust+0xb6>
   d8192:	f5a3 53b5 	sub.w	r3, r3, #5792	; 0x16a0
   d8196:	3b12      	subs	r3, #18
   d8198:	2b02      	cmp	r3, #2
   d819a:	d90c      	bls.n	d81b6 <iso_year_adjust+0xb2>
   d819c:	e00d      	b.n	d81ba <iso_year_adjust+0xb6>
   d819e:	f241 62d5 	movw	r2, #5845	; 0x16d5
   d81a2:	4293      	cmp	r3, r2
   d81a4:	d007      	beq.n	d81b6 <iso_year_adjust+0xb2>
   d81a6:	f241 62d7 	movw	r2, #5847	; 0x16d7
   d81aa:	4293      	cmp	r3, r2
   d81ac:	d003      	beq.n	d81b6 <iso_year_adjust+0xb2>
   d81ae:	f241 62d3 	movw	r2, #5843	; 0x16d3
   d81b2:	4293      	cmp	r3, r2
   d81b4:	d101      	bne.n	d81ba <iso_year_adjust+0xb6>
   d81b6:	2001      	movs	r0, #1
   d81b8:	bd10      	pop	{r4, pc}
   d81ba:	2000      	movs	r0, #0
   d81bc:	bd10      	pop	{r4, pc}
   d81be:	f04f 30ff 	mov.w	r0, #4294967295
   d81c2:	bd10      	pop	{r4, pc}

000d81c4 <strftime>:
   d81c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   d81c8:	b093      	sub	sp, #76	; 0x4c
   d81ca:	460e      	mov	r6, r1
   d81cc:	461d      	mov	r5, r3
   d81ce:	4607      	mov	r7, r0
   d81d0:	4691      	mov	r9, r2
   d81d2:	f000 fdf3 	bl	d8dbc <__get_current_time_locale>
   d81d6:	2300      	movs	r3, #0
   d81d8:	9306      	str	r3, [sp, #24]
   d81da:	461c      	mov	r4, r3
   d81dc:	1e73      	subs	r3, r6, #1
   d81de:	9003      	str	r0, [sp, #12]
   d81e0:	9302      	str	r3, [sp, #8]
   d81e2:	f899 3000 	ldrb.w	r3, [r9]
   d81e6:	2b00      	cmp	r3, #0
   d81e8:	f000 8492 	beq.w	d8b10 <strftime+0x94c>
   d81ec:	2b25      	cmp	r3, #37	; 0x25
   d81ee:	d008      	beq.n	d8202 <strftime+0x3e>
   d81f0:	9a02      	ldr	r2, [sp, #8]
   d81f2:	4294      	cmp	r4, r2
   d81f4:	f080 8490 	bcs.w	d8b18 <strftime+0x954>
   d81f8:	553b      	strb	r3, [r7, r4]
   d81fa:	f109 0901 	add.w	r9, r9, #1
   d81fe:	3401      	adds	r4, #1
   d8200:	e7ef      	b.n	d81e2 <strftime+0x1e>
   d8202:	f899 a001 	ldrb.w	sl, [r9, #1]
   d8206:	f1ba 0f30 	cmp.w	sl, #48	; 0x30
   d820a:	d007      	beq.n	d821c <strftime+0x58>
   d820c:	f1ba 0f2b 	cmp.w	sl, #43	; 0x2b
   d8210:	d004      	beq.n	d821c <strftime+0x58>
   d8212:	f109 0901 	add.w	r9, r9, #1
   d8216:	f04f 0a00 	mov.w	sl, #0
   d821a:	e001      	b.n	d8220 <strftime+0x5c>
   d821c:	f109 0902 	add.w	r9, r9, #2
   d8220:	f899 3000 	ldrb.w	r3, [r9]
   d8224:	3b31      	subs	r3, #49	; 0x31
   d8226:	2b08      	cmp	r3, #8
   d8228:	d808      	bhi.n	d823c <strftime+0x78>
   d822a:	4648      	mov	r0, r9
   d822c:	220a      	movs	r2, #10
   d822e:	a90a      	add	r1, sp, #40	; 0x28
   d8230:	f000 fdba 	bl	d8da8 <strtoul>
   d8234:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
   d8238:	4680      	mov	r8, r0
   d823a:	e001      	b.n	d8240 <strftime+0x7c>
   d823c:	f04f 0800 	mov.w	r8, #0
   d8240:	f899 3000 	ldrb.w	r3, [r9]
   d8244:	2b45      	cmp	r3, #69	; 0x45
   d8246:	d001      	beq.n	d824c <strftime+0x88>
   d8248:	2b4f      	cmp	r3, #79	; 0x4f
   d824a:	d101      	bne.n	d8250 <strftime+0x8c>
   d824c:	f109 0901 	add.w	r9, r9, #1
   d8250:	f899 0000 	ldrb.w	r0, [r9]
   d8254:	f1a0 0325 	sub.w	r3, r0, #37	; 0x25
   d8258:	2b55      	cmp	r3, #85	; 0x55
   d825a:	f200 845d 	bhi.w	d8b18 <strftime+0x954>
   d825e:	e8df f013 	tbh	[pc, r3, lsl #1]
   d8262:	044a      	.short	0x044a
   d8264:	045b045b 	.word	0x045b045b
   d8268:	045b045b 	.word	0x045b045b
   d826c:	045b045b 	.word	0x045b045b
   d8270:	045b045b 	.word	0x045b045b
   d8274:	045b045b 	.word	0x045b045b
   d8278:	045b045b 	.word	0x045b045b
   d827c:	045b045b 	.word	0x045b045b
   d8280:	045b045b 	.word	0x045b045b
   d8284:	045b045b 	.word	0x045b045b
   d8288:	045b045b 	.word	0x045b045b
   d828c:	045b045b 	.word	0x045b045b
   d8290:	045b045b 	.word	0x045b045b
   d8294:	045b045b 	.word	0x045b045b
   d8298:	006f045b 	.word	0x006f045b
   d829c:	00d400a1 	.word	0x00d400a1
   d82a0:	045b011a 	.word	0x045b011a
   d82a4:	01a0013f 	.word	0x01a0013f
   d82a8:	022d0226 	.word	0x022d0226
   d82ac:	045b045b 	.word	0x045b045b
   d82b0:	0260045b 	.word	0x0260045b
   d82b4:	045b045b 	.word	0x045b045b
   d82b8:	045b0268 	.word	0x045b0268
   d82bc:	031d0297 	.word	0x031d0297
   d82c0:	033b0325 	.word	0x033b0325
   d82c4:	03860343 	.word	0x03860343
   d82c8:	03a000c6 	.word	0x03a000c6
   d82cc:	045b041f 	.word	0x045b041f
   d82d0:	045b045b 	.word	0x045b045b
   d82d4:	045b045b 	.word	0x045b045b
   d82d8:	0056045b 	.word	0x0056045b
   d82dc:	00ba0089 	.word	0x00ba0089
   d82e0:	010c010c 	.word	0x010c010c
   d82e4:	0171045b 	.word	0x0171045b
   d82e8:	045b0089 	.word	0x045b0089
   d82ec:	0226023d 	.word	0x0226023d
   d82f0:	025d022d 	.word	0x025d022d
   d82f4:	045b0262 	.word	0x045b0262
   d82f8:	045b0268 	.word	0x045b0268
   d82fc:	029c00be 	.word	0x029c00be
   d8300:	032e031f 	.word	0x032e031f
   d8304:	037f045b 	.word	0x037f045b
   d8308:	039200c2 	.word	0x039200c2
   d830c:	03e7      	.short	0x03e7
   d830e:	69ab      	ldr	r3, [r5, #24]
   d8310:	9a03      	ldr	r2, [sp, #12]
   d8312:	3318      	adds	r3, #24
   d8314:	f852 8023 	ldr.w	r8, [r2, r3, lsl #2]
   d8318:	4640      	mov	r0, r8
   d831a:	f000 fc07 	bl	d8b2c <strlen>
   d831e:	f108 38ff 	add.w	r8, r8, #4294967295
   d8322:	193b      	adds	r3, r7, r4
   d8324:	4420      	add	r0, r4
   d8326:	4284      	cmp	r4, r0
   d8328:	f000 83eb 	beq.w	d8b02 <strftime+0x93e>
   d832c:	9a02      	ldr	r2, [sp, #8]
   d832e:	4294      	cmp	r4, r2
   d8330:	f080 83f2 	bcs.w	d8b18 <strftime+0x954>
   d8334:	f818 2f01 	ldrb.w	r2, [r8, #1]!
   d8338:	f803 2b01 	strb.w	r2, [r3], #1
   d833c:	3401      	adds	r4, #1
   d833e:	e7f2      	b.n	d8326 <strftime+0x162>
   d8340:	69ab      	ldr	r3, [r5, #24]
   d8342:	9a03      	ldr	r2, [sp, #12]
   d8344:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   d8348:	f8d3 807c 	ldr.w	r8, [r3, #124]	; 0x7c
   d834c:	4640      	mov	r0, r8
   d834e:	f000 fbed 	bl	d8b2c <strlen>
   d8352:	f108 38ff 	add.w	r8, r8, #4294967295
   d8356:	193b      	adds	r3, r7, r4
   d8358:	4420      	add	r0, r4
   d835a:	4284      	cmp	r4, r0
   d835c:	f000 83d1 	beq.w	d8b02 <strftime+0x93e>
   d8360:	9a02      	ldr	r2, [sp, #8]
   d8362:	4294      	cmp	r4, r2
   d8364:	f080 83d8 	bcs.w	d8b18 <strftime+0x954>
   d8368:	f818 2f01 	ldrb.w	r2, [r8, #1]!
   d836c:	f803 2b01 	strb.w	r2, [r3], #1
   d8370:	3401      	adds	r4, #1
   d8372:	e7f2      	b.n	d835a <strftime+0x196>
   d8374:	692b      	ldr	r3, [r5, #16]
   d8376:	9a03      	ldr	r2, [sp, #12]
   d8378:	f852 8023 	ldr.w	r8, [r2, r3, lsl #2]
   d837c:	4640      	mov	r0, r8
   d837e:	f000 fbd5 	bl	d8b2c <strlen>
   d8382:	f108 38ff 	add.w	r8, r8, #4294967295
   d8386:	193b      	adds	r3, r7, r4
   d8388:	4420      	add	r0, r4
   d838a:	4284      	cmp	r4, r0
   d838c:	f000 83b9 	beq.w	d8b02 <strftime+0x93e>
   d8390:	9a02      	ldr	r2, [sp, #8]
   d8392:	4294      	cmp	r4, r2
   d8394:	f080 83c0 	bcs.w	d8b18 <strftime+0x954>
   d8398:	f818 2f01 	ldrb.w	r2, [r8, #1]!
   d839c:	f803 2b01 	strb.w	r2, [r3], #1
   d83a0:	3401      	adds	r4, #1
   d83a2:	e7f2      	b.n	d838a <strftime+0x1c6>
   d83a4:	692b      	ldr	r3, [r5, #16]
   d83a6:	9a03      	ldr	r2, [sp, #12]
   d83a8:	330c      	adds	r3, #12
   d83aa:	f852 8023 	ldr.w	r8, [r2, r3, lsl #2]
   d83ae:	4640      	mov	r0, r8
   d83b0:	f000 fbbc 	bl	d8b2c <strlen>
   d83b4:	f108 38ff 	add.w	r8, r8, #4294967295
   d83b8:	193b      	adds	r3, r7, r4
   d83ba:	4420      	add	r0, r4
   d83bc:	4284      	cmp	r4, r0
   d83be:	f000 83a0 	beq.w	d8b02 <strftime+0x93e>
   d83c2:	9a02      	ldr	r2, [sp, #8]
   d83c4:	4294      	cmp	r4, r2
   d83c6:	f080 83a7 	bcs.w	d8b18 <strftime+0x954>
   d83ca:	f818 2f01 	ldrb.w	r2, [r8, #1]!
   d83ce:	f803 2b01 	strb.w	r2, [r3], #1
   d83d2:	3401      	adds	r4, #1
   d83d4:	e7f2      	b.n	d83bc <strftime+0x1f8>
   d83d6:	9b03      	ldr	r3, [sp, #12]
   d83d8:	f8d3 80a0 	ldr.w	r8, [r3, #160]	; 0xa0
   d83dc:	e00a      	b.n	d83f4 <strftime+0x230>
   d83de:	9b03      	ldr	r3, [sp, #12]
   d83e0:	f8d3 80e4 	ldr.w	r8, [r3, #228]	; 0xe4
   d83e4:	e006      	b.n	d83f4 <strftime+0x230>
   d83e6:	9b03      	ldr	r3, [sp, #12]
   d83e8:	f8d3 809c 	ldr.w	r8, [r3, #156]	; 0x9c
   d83ec:	e002      	b.n	d83f4 <strftime+0x230>
   d83ee:	9b03      	ldr	r3, [sp, #12]
   d83f0:	f8d3 8098 	ldr.w	r8, [r3, #152]	; 0x98
   d83f4:	4640      	mov	r0, r8
   d83f6:	f000 fb99 	bl	d8b2c <strlen>
   d83fa:	f898 3000 	ldrb.w	r3, [r8]
   d83fe:	2b00      	cmp	r3, #0
   d8400:	f000 837f 	beq.w	d8b02 <strftime+0x93e>
   d8404:	462b      	mov	r3, r5
   d8406:	4642      	mov	r2, r8
   d8408:	e093      	b.n	d8532 <strftime+0x36e>
   d840a:	49b6      	ldr	r1, [pc, #728]	; (d86e4 <strftime+0x520>)
   d840c:	f8d5 b014 	ldr.w	fp, [r5, #20]
   d8410:	458b      	cmp	fp, r1
   d8412:	bfac      	ite	ge
   d8414:	2100      	movge	r1, #0
   d8416:	2101      	movlt	r1, #1
   d8418:	f1bb 0f00 	cmp.w	fp, #0
   d841c:	db04      	blt.n	d8428 <strftime+0x264>
   d841e:	2064      	movs	r0, #100	; 0x64
   d8420:	fb9b f0f0 	sdiv	r0, fp, r0
   d8424:	3013      	adds	r0, #19
   d8426:	e008      	b.n	d843a <strftime+0x276>
   d8428:	f20b 706c 	addw	r0, fp, #1900	; 0x76c
   d842c:	9107      	str	r1, [sp, #28]
   d842e:	f000 ff11 	bl	d9254 <abs>
   d8432:	9907      	ldr	r1, [sp, #28]
   d8434:	2364      	movs	r3, #100	; 0x64
   d8436:	fb90 f0f3 	sdiv	r0, r0, r3
   d843a:	f1ba 0f00 	cmp.w	sl, #0
   d843e:	d008      	beq.n	d8452 <strftime+0x28e>
   d8440:	2863      	cmp	r0, #99	; 0x63
   d8442:	dd09      	ble.n	d8458 <strftime+0x294>
   d8444:	4ba8      	ldr	r3, [pc, #672]	; (d86e8 <strftime+0x524>)
   d8446:	4aa9      	ldr	r2, [pc, #676]	; (d86ec <strftime+0x528>)
   d8448:	f1ba 0f2b 	cmp.w	sl, #43	; 0x2b
   d844c:	bf18      	it	ne
   d844e:	4613      	movne	r3, r2
   d8450:	e003      	b.n	d845a <strftime+0x296>
   d8452:	4ba6      	ldr	r3, [pc, #664]	; (d86ec <strftime+0x528>)
   d8454:	4aa6      	ldr	r2, [pc, #664]	; (d86f0 <strftime+0x52c>)
   d8456:	e001      	b.n	d845c <strftime+0x298>
   d8458:	4ba4      	ldr	r3, [pc, #656]	; (d86ec <strftime+0x528>)
   d845a:	4aa6      	ldr	r2, [pc, #664]	; (d86f4 <strftime+0x530>)
   d845c:	9001      	str	r0, [sp, #4]
   d845e:	f1b8 0f01 	cmp.w	r8, #1
   d8462:	bf98      	it	ls
   d8464:	f04f 0802 	movls.w	r8, #2
   d8468:	ebc1 0108 	rsb	r1, r1, r8
   d846c:	9100      	str	r1, [sp, #0]
   d846e:	489d      	ldr	r0, [pc, #628]	; (d86e4 <strftime+0x520>)
   d8470:	49a1      	ldr	r1, [pc, #644]	; (d86f8 <strftime+0x534>)
   d8472:	4583      	cmp	fp, r0
   d8474:	bfb8      	it	lt
   d8476:	460b      	movlt	r3, r1
   d8478:	e21e      	b.n	d88b8 <strftime+0x6f4>
   d847a:	4aa0      	ldr	r2, [pc, #640]	; (d86fc <strftime+0x538>)
   d847c:	49a0      	ldr	r1, [pc, #640]	; (d8700 <strftime+0x53c>)
   d847e:	68eb      	ldr	r3, [r5, #12]
   d8480:	2864      	cmp	r0, #100	; 0x64
   d8482:	bf08      	it	eq
   d8484:	460a      	moveq	r2, r1
   d8486:	1b31      	subs	r1, r6, r4
   d8488:	1938      	adds	r0, r7, r4
   d848a:	f7fd fe63 	bl	d6154 <sniprintf>
   d848e:	2800      	cmp	r0, #0
   d8490:	f280 8302 	bge.w	d8a98 <strftime+0x8d4>
   d8494:	e340      	b.n	d8b18 <strftime+0x954>
   d8496:	6968      	ldr	r0, [r5, #20]
   d8498:	692b      	ldr	r3, [r5, #16]
   d849a:	2800      	cmp	r0, #0
   d849c:	f103 0b01 	add.w	fp, r3, #1
   d84a0:	eb07 0804 	add.w	r8, r7, r4
   d84a4:	ebc4 0a06 	rsb	sl, r4, r6
   d84a8:	68eb      	ldr	r3, [r5, #12]
   d84aa:	db05      	blt.n	d84b8 <strftime+0x2f4>
   d84ac:	2264      	movs	r2, #100	; 0x64
   d84ae:	fb90 f1f2 	sdiv	r1, r0, r2
   d84b2:	fb02 0011 	mls	r0, r2, r1, r0
   d84b6:	e00a      	b.n	d84ce <strftime+0x30a>
   d84b8:	f200 706c 	addw	r0, r0, #1900	; 0x76c
   d84bc:	9307      	str	r3, [sp, #28]
   d84be:	f000 fec9 	bl	d9254 <abs>
   d84c2:	2264      	movs	r2, #100	; 0x64
   d84c4:	9b07      	ldr	r3, [sp, #28]
   d84c6:	fb90 f1f2 	sdiv	r1, r0, r2
   d84ca:	fb01 0012 	mls	r0, r1, r2, r0
   d84ce:	4a8d      	ldr	r2, [pc, #564]	; (d8704 <strftime+0x540>)
   d84d0:	9001      	str	r0, [sp, #4]
   d84d2:	9300      	str	r3, [sp, #0]
   d84d4:	4651      	mov	r1, sl
   d84d6:	465b      	mov	r3, fp
   d84d8:	4640      	mov	r0, r8
   d84da:	f7fd fe3b 	bl	d6154 <sniprintf>
   d84de:	e7d6      	b.n	d848e <strftime+0x2ca>
   d84e0:	2325      	movs	r3, #37	; 0x25
   d84e2:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
   d84e6:	f1ba 0f00 	cmp.w	sl, #0
   d84ea:	d007      	beq.n	d84fc <strftime+0x338>
   d84ec:	f1b8 0f05 	cmp.w	r8, #5
   d84f0:	f88d a029 	strb.w	sl, [sp, #41]	; 0x29
   d84f4:	bf98      	it	ls
   d84f6:	f04f 0806 	movls.w	r8, #6
   d84fa:	e004      	b.n	d8506 <strftime+0x342>
   d84fc:	232b      	movs	r3, #43	; 0x2b
   d84fe:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
   d8502:	f04f 080a 	mov.w	r8, #10
   d8506:	f1b8 0306 	subs.w	r3, r8, #6
   d850a:	d102      	bne.n	d8512 <strftime+0x34e>
   d850c:	f10d 002a 	add.w	r0, sp, #42	; 0x2a
   d8510:	e00a      	b.n	d8528 <strftime+0x364>
   d8512:	4a7d      	ldr	r2, [pc, #500]	; (d8708 <strftime+0x544>)
   d8514:	211e      	movs	r1, #30
   d8516:	f10d 002a 	add.w	r0, sp, #42	; 0x2a
   d851a:	f7fd fe1b 	bl	d6154 <sniprintf>
   d851e:	2800      	cmp	r0, #0
   d8520:	ddf4      	ble.n	d850c <strftime+0x348>
   d8522:	f10d 032a 	add.w	r3, sp, #42	; 0x2a
   d8526:	4418      	add	r0, r3
   d8528:	4978      	ldr	r1, [pc, #480]	; (d870c <strftime+0x548>)
   d852a:	f7ff fde3 	bl	d80f4 <strcpy>
   d852e:	462b      	mov	r3, r5
   d8530:	aa0a      	add	r2, sp, #40	; 0x28
   d8532:	1b31      	subs	r1, r6, r4
   d8534:	1938      	adds	r0, r7, r4
   d8536:	f7ff fe45 	bl	d81c4 <strftime>
   d853a:	2800      	cmp	r0, #0
   d853c:	f340 82ec 	ble.w	d8b18 <strftime+0x954>
   d8540:	4404      	add	r4, r0
   d8542:	e2de      	b.n	d8b02 <strftime+0x93e>
   d8544:	4628      	mov	r0, r5
   d8546:	f7ff fddd 	bl	d8104 <iso_year_adjust>
   d854a:	4680      	mov	r8, r0
   d854c:	6968      	ldr	r0, [r5, #20]
   d854e:	2800      	cmp	r0, #0
   d8550:	db05      	blt.n	d855e <strftime+0x39a>
   d8552:	2264      	movs	r2, #100	; 0x64
   d8554:	fb90 f1f2 	sdiv	r1, r0, r2
   d8558:	fb02 0011 	mls	r0, r2, r1, r0
   d855c:	e008      	b.n	d8570 <strftime+0x3ac>
   d855e:	f200 706c 	addw	r0, r0, #1900	; 0x76c
   d8562:	f000 fe77 	bl	d9254 <abs>
   d8566:	2264      	movs	r2, #100	; 0x64
   d8568:	fb90 f3f2 	sdiv	r3, r0, r2
   d856c:	fb03 0012 	mls	r0, r3, r2, r0
   d8570:	f1b8 0f00 	cmp.w	r8, #0
   d8574:	da06      	bge.n	d8584 <strftime+0x3c0>
   d8576:	696a      	ldr	r2, [r5, #20]
   d8578:	4b65      	ldr	r3, [pc, #404]	; (d8710 <strftime+0x54c>)
   d857a:	429a      	cmp	r2, r3
   d857c:	bfb8      	it	lt
   d857e:	f04f 0801 	movlt.w	r8, #1
   d8582:	e006      	b.n	d8592 <strftime+0x3ce>
   d8584:	d005      	beq.n	d8592 <strftime+0x3ce>
   d8586:	696a      	ldr	r2, [r5, #20]
   d8588:	4b56      	ldr	r3, [pc, #344]	; (d86e4 <strftime+0x520>)
   d858a:	429a      	cmp	r2, r3
   d858c:	bfb8      	it	lt
   d858e:	f04f 38ff 	movlt.w	r8, #4294967295
   d8592:	2364      	movs	r3, #100	; 0x64
   d8594:	4440      	add	r0, r8
   d8596:	fb90 f2f3 	sdiv	r2, r0, r3
   d859a:	fb03 0012 	mls	r0, r3, r2, r0
   d859e:	4418      	add	r0, r3
   d85a0:	e1f9      	b.n	d8996 <strftime+0x7d2>
   d85a2:	4b50      	ldr	r3, [pc, #320]	; (d86e4 <strftime+0x520>)
   d85a4:	6969      	ldr	r1, [r5, #20]
   d85a6:	9108      	str	r1, [sp, #32]
   d85a8:	4299      	cmp	r1, r3
   d85aa:	bfac      	ite	ge
   d85ac:	2300      	movge	r3, #0
   d85ae:	2301      	movlt	r3, #1
   d85b0:	4628      	mov	r0, r5
   d85b2:	9307      	str	r3, [sp, #28]
   d85b4:	f7ff fda6 	bl	d8104 <iso_year_adjust>
   d85b8:	9908      	ldr	r1, [sp, #32]
   d85ba:	2900      	cmp	r1, #0
   d85bc:	4683      	mov	fp, r0
   d85be:	db04      	blt.n	d85ca <strftime+0x406>
   d85c0:	2364      	movs	r3, #100	; 0x64
   d85c2:	fb91 f3f3 	sdiv	r3, r1, r3
   d85c6:	3313      	adds	r3, #19
   d85c8:	e008      	b.n	d85dc <strftime+0x418>
   d85ca:	f201 706c 	addw	r0, r1, #1900	; 0x76c
   d85ce:	9108      	str	r1, [sp, #32]
   d85d0:	f000 fe40 	bl	d9254 <abs>
   d85d4:	9908      	ldr	r1, [sp, #32]
   d85d6:	2364      	movs	r3, #100	; 0x64
   d85d8:	fb90 f3f3 	sdiv	r3, r0, r3
   d85dc:	6968      	ldr	r0, [r5, #20]
   d85de:	2800      	cmp	r0, #0
   d85e0:	db06      	blt.n	d85f0 <strftime+0x42c>
   d85e2:	f04f 0e64 	mov.w	lr, #100	; 0x64
   d85e6:	fb90 fcfe 	sdiv	ip, r0, lr
   d85ea:	fb0e 001c 	mls	r0, lr, ip, r0
   d85ee:	e00d      	b.n	d860c <strftime+0x448>
   d85f0:	f200 706c 	addw	r0, r0, #1900	; 0x76c
   d85f4:	9109      	str	r1, [sp, #36]	; 0x24
   d85f6:	9308      	str	r3, [sp, #32]
   d85f8:	f000 fe2c 	bl	d9254 <abs>
   d85fc:	f04f 0e64 	mov.w	lr, #100	; 0x64
   d8600:	9909      	ldr	r1, [sp, #36]	; 0x24
   d8602:	9b08      	ldr	r3, [sp, #32]
   d8604:	fb90 fcfe 	sdiv	ip, r0, lr
   d8608:	fb0c 001e 	mls	r0, ip, lr, r0
   d860c:	f1bb 0f00 	cmp.w	fp, #0
   d8610:	da08      	bge.n	d8624 <strftime+0x460>
   d8612:	6969      	ldr	r1, [r5, #20]
   d8614:	4a3e      	ldr	r2, [pc, #248]	; (d8710 <strftime+0x54c>)
   d8616:	4291      	cmp	r1, r2
   d8618:	da0a      	bge.n	d8630 <strftime+0x46c>
   d861a:	f04f 0b01 	mov.w	fp, #1
   d861e:	f8cd b01c 	str.w	fp, [sp, #28]
   d8622:	e005      	b.n	d8630 <strftime+0x46c>
   d8624:	d004      	beq.n	d8630 <strftime+0x46c>
   d8626:	4a2f      	ldr	r2, [pc, #188]	; (d86e4 <strftime+0x520>)
   d8628:	4291      	cmp	r1, r2
   d862a:	bfb8      	it	lt
   d862c:	f04f 3bff 	movlt.w	fp, #4294967295
   d8630:	eb0b 0200 	add.w	r2, fp, r0
   d8634:	1c50      	adds	r0, r2, #1
   d8636:	d102      	bne.n	d863e <strftime+0x47a>
   d8638:	3b01      	subs	r3, #1
   d863a:	2263      	movs	r2, #99	; 0x63
   d863c:	e003      	b.n	d8646 <strftime+0x482>
   d863e:	2a64      	cmp	r2, #100	; 0x64
   d8640:	bf04      	itt	eq
   d8642:	3301      	addeq	r3, #1
   d8644:	2200      	moveq	r2, #0
   d8646:	2064      	movs	r0, #100	; 0x64
   d8648:	fb00 2303 	mla	r3, r0, r3, r2
   d864c:	9a07      	ldr	r2, [sp, #28]
   d864e:	b142      	cbz	r2, d8662 <strftime+0x49e>
   d8650:	222d      	movs	r2, #45	; 0x2d
   d8652:	f88d 2028 	strb.w	r2, [sp, #40]	; 0x28
   d8656:	f1b8 0f00 	cmp.w	r8, #0
   d865a:	d013      	beq.n	d8684 <strftime+0x4c0>
   d865c:	f108 38ff 	add.w	r8, r8, #4294967295
   d8660:	e010      	b.n	d8684 <strftime+0x4c0>
   d8662:	f1ba 0f2b 	cmp.w	sl, #43	; 0x2b
   d8666:	d110      	bne.n	d868a <strftime+0x4c6>
   d8668:	f242 720f 	movw	r2, #9999	; 0x270f
   d866c:	4293      	cmp	r3, r2
   d866e:	d90c      	bls.n	d868a <strftime+0x4c6>
   d8670:	f88d a028 	strb.w	sl, [sp, #40]	; 0x28
   d8674:	f1b8 0f00 	cmp.w	r8, #0
   d8678:	d1f0      	bne.n	d865c <strftime+0x498>
   d867a:	aa12      	add	r2, sp, #72	; 0x48
   d867c:	2125      	movs	r1, #37	; 0x25
   d867e:	f802 1d1f 	strb.w	r1, [r2, #-31]!
   d8682:	e00a      	b.n	d869a <strftime+0x4d6>
   d8684:	f10d 0229 	add.w	r2, sp, #41	; 0x29
   d8688:	e000      	b.n	d868c <strftime+0x4c8>
   d868a:	aa0a      	add	r2, sp, #40	; 0x28
   d868c:	2125      	movs	r1, #37	; 0x25
   d868e:	7011      	strb	r1, [r2, #0]
   d8690:	f1ba 0f00 	cmp.w	sl, #0
   d8694:	d101      	bne.n	d869a <strftime+0x4d6>
   d8696:	1c50      	adds	r0, r2, #1
   d8698:	e002      	b.n	d86a0 <strftime+0x4dc>
   d869a:	2130      	movs	r1, #48	; 0x30
   d869c:	1c90      	adds	r0, r2, #2
   d869e:	7051      	strb	r1, [r2, #1]
   d86a0:	491c      	ldr	r1, [pc, #112]	; (d8714 <strftime+0x550>)
   d86a2:	9307      	str	r3, [sp, #28]
   d86a4:	f7ff fd26 	bl	d80f4 <strcpy>
   d86a8:	9b07      	ldr	r3, [sp, #28]
   d86aa:	9300      	str	r3, [sp, #0]
   d86ac:	e1ad      	b.n	d8a0a <strftime+0x846>
   d86ae:	4a14      	ldr	r2, [pc, #80]	; (d8700 <strftime+0x53c>)
   d86b0:	4912      	ldr	r1, [pc, #72]	; (d86fc <strftime+0x538>)
   d86b2:	68ab      	ldr	r3, [r5, #8]
   d86b4:	286b      	cmp	r0, #107	; 0x6b
   d86b6:	bf08      	it	eq
   d86b8:	460a      	moveq	r2, r1
   d86ba:	e6e4      	b.n	d8486 <strftime+0x2c2>
   d86bc:	68a9      	ldr	r1, [r5, #8]
   d86be:	230c      	movs	r3, #12
   d86c0:	b131      	cbz	r1, d86d0 <strftime+0x50c>
   d86c2:	4299      	cmp	r1, r3
   d86c4:	bf0e      	itee	eq
   d86c6:	460b      	moveq	r3, r1
   d86c8:	fb91 f2f3 	sdivne	r2, r1, r3
   d86cc:	fb03 1312 	mlsne	r3, r3, r2, r1
   d86d0:	4a0a      	ldr	r2, [pc, #40]	; (d86fc <strftime+0x538>)
   d86d2:	490b      	ldr	r1, [pc, #44]	; (d8700 <strftime+0x53c>)
   d86d4:	2849      	cmp	r0, #73	; 0x49
   d86d6:	bf08      	it	eq
   d86d8:	460a      	moveq	r2, r1
   d86da:	e6d4      	b.n	d8486 <strftime+0x2c2>
   d86dc:	69eb      	ldr	r3, [r5, #28]
   d86de:	4a0e      	ldr	r2, [pc, #56]	; (d8718 <strftime+0x554>)
   d86e0:	3301      	adds	r3, #1
   d86e2:	e6d0      	b.n	d8486 <strftime+0x2c2>
   d86e4:	fffff894 	.word	0xfffff894
   d86e8:	000dabb3 	.word	0x000dabb3
   d86ec:	000da275 	.word	0x000da275
   d86f0:	000daba4 	.word	0x000daba4
   d86f4:	000dabab 	.word	0x000dabab
   d86f8:	000dabb5 	.word	0x000dabb5
   d86fc:	000dabb7 	.word	0x000dabb7
   d8700:	000dabc5 	.word	0x000dabc5
   d8704:	000dabbb 	.word	0x000dabbb
   d8708:	000dabca 	.word	0x000dabca
   d870c:	000dabce 	.word	0x000dabce
   d8710:	fffff895 	.word	0xfffff895
   d8714:	000dabd6 	.word	0x000dabd6
   d8718:	000dabda 	.word	0x000dabda
   d871c:	692b      	ldr	r3, [r5, #16]
   d871e:	3301      	adds	r3, #1
   d8720:	e13d      	b.n	d899e <strftime+0x7da>
   d8722:	686b      	ldr	r3, [r5, #4]
   d8724:	e13b      	b.n	d899e <strftime+0x7da>
   d8726:	9b02      	ldr	r3, [sp, #8]
   d8728:	429c      	cmp	r4, r3
   d872a:	f080 81f5 	bcs.w	d8b18 <strftime+0x954>
   d872e:	230a      	movs	r3, #10
   d8730:	e1e5      	b.n	d8afe <strftime+0x93a>
   d8732:	68ab      	ldr	r3, [r5, #8]
   d8734:	9a03      	ldr	r2, [sp, #12]
   d8736:	2b0b      	cmp	r3, #11
   d8738:	bfcc      	ite	gt
   d873a:	23a4      	movgt	r3, #164	; 0xa4
   d873c:	23a0      	movle	r3, #160	; 0xa0
   d873e:	4413      	add	r3, r2
   d8740:	f8d3 8004 	ldr.w	r8, [r3, #4]
   d8744:	4640      	mov	r0, r8
   d8746:	f000 f9f1 	bl	d8b2c <strlen>
   d874a:	4bb2      	ldr	r3, [pc, #712]	; (d8a14 <strftime+0x850>)
   d874c:	f8d3 e000 	ldr.w	lr, [r3]
   d8750:	1939      	adds	r1, r7, r4
   d8752:	4642      	mov	r2, r8
   d8754:	4420      	add	r0, r4
   d8756:	4284      	cmp	r4, r0
   d8758:	f000 81d3 	beq.w	d8b02 <strftime+0x93e>
   d875c:	9b02      	ldr	r3, [sp, #8]
   d875e:	429c      	cmp	r4, r3
   d8760:	f080 81da 	bcs.w	d8b18 <strftime+0x954>
   d8764:	f899 3000 	ldrb.w	r3, [r9]
   d8768:	2b50      	cmp	r3, #80	; 0x50
   d876a:	f104 0401 	add.w	r4, r4, #1
   d876e:	7813      	ldrb	r3, [r2, #0]
   d8770:	d10a      	bne.n	d8788 <strftime+0x5c4>
   d8772:	eb0e 0c03 	add.w	ip, lr, r3
   d8776:	f89c c001 	ldrb.w	ip, [ip, #1]
   d877a:	f00c 0c03 	and.w	ip, ip, #3
   d877e:	f1bc 0f01 	cmp.w	ip, #1
   d8782:	bf08      	it	eq
   d8784:	3320      	addeq	r3, #32
   d8786:	b2db      	uxtb	r3, r3
   d8788:	f801 3b01 	strb.w	r3, [r1], #1
   d878c:	3201      	adds	r2, #1
   d878e:	e7e2      	b.n	d8756 <strftime+0x592>
   d8790:	686b      	ldr	r3, [r5, #4]
   d8792:	9300      	str	r3, [sp, #0]
   d8794:	4aa0      	ldr	r2, [pc, #640]	; (d8a18 <strftime+0x854>)
   d8796:	68ab      	ldr	r3, [r5, #8]
   d8798:	e139      	b.n	d8a0e <strftime+0x84a>
   d879a:	6a2b      	ldr	r3, [r5, #32]
   d879c:	2b00      	cmp	r3, #0
   d879e:	db17      	blt.n	d87d0 <strftime+0x60c>
   d87a0:	f000 fbd0 	bl	d8f44 <__tz_lock>
   d87a4:	9b06      	ldr	r3, [sp, #24]
   d87a6:	b91b      	cbnz	r3, d87b0 <strftime+0x5ec>
   d87a8:	f000 fbce 	bl	d8f48 <_tzset_unlocked>
   d87ac:	2301      	movs	r3, #1
   d87ae:	9306      	str	r3, [sp, #24]
   d87b0:	f000 fd98 	bl	d92e4 <__gettzinfo>
   d87b4:	6a2b      	ldr	r3, [r5, #32]
   d87b6:	2b00      	cmp	r3, #0
   d87b8:	bfd4      	ite	le
   d87ba:	2300      	movle	r3, #0
   d87bc:	2301      	movgt	r3, #1
   d87be:	221c      	movs	r2, #28
   d87c0:	fb02 0003 	mla	r0, r2, r3, r0
   d87c4:	6a03      	ldr	r3, [r0, #32]
   d87c6:	f1c3 0800 	rsb	r8, r3, #0
   d87ca:	f000 fbbc 	bl	d8f46 <__tz_unlock>
   d87ce:	e001      	b.n	d87d4 <strftime+0x610>
   d87d0:	f04f 0800 	mov.w	r8, #0
   d87d4:	f8d5 e014 	ldr.w	lr, [r5, #20]
   d87d8:	4670      	mov	r0, lr
   d87da:	f1be 0245 	subs.w	r2, lr, #69	; 0x45
   d87de:	ea4f 71e0 	mov.w	r1, r0, asr #31
   d87e2:	f141 33ff 	adc.w	r3, r1, #4294967295
   d87e6:	2a00      	cmp	r2, #0
   d87e8:	f173 0b00 	sbcs.w	fp, r3, #0
   d87ec:	ebc4 0c06 	rsb	ip, r4, r6
   d87f0:	eb07 0a04 	add.w	sl, r7, r4
   d87f4:	da03      	bge.n	d87fe <strftime+0x63a>
   d87f6:	f1be 0242 	subs.w	r2, lr, #66	; 0x42
   d87fa:	f141 33ff 	adc.w	r3, r1, #4294967295
   d87fe:	0891      	lsrs	r1, r2, #2
   d8800:	ea41 7183 	orr.w	r1, r1, r3, lsl #30
   d8804:	109b      	asrs	r3, r3, #2
   d8806:	9104      	str	r1, [sp, #16]
   d8808:	9305      	str	r3, [sp, #20]
   d880a:	f10e 31ff 	add.w	r1, lr, #4294967295
   d880e:	2364      	movs	r3, #100	; 0x64
   d8810:	fb91 f1f3 	sdiv	r1, r1, r3
   d8814:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   d8818:	1a52      	subs	r2, r2, r1
   d881a:	eb63 73e1 	sbc.w	r3, r3, r1, asr #31
   d881e:	f20e 102b 	addw	r0, lr, #299	; 0x12b
   d8822:	f44f 71c8 	mov.w	r1, #400	; 0x190
   d8826:	fb90 f1f1 	sdiv	r1, r0, r1
   d882a:	1852      	adds	r2, r2, r1
   d882c:	eb43 73e1 	adc.w	r3, r3, r1, asr #31
   d8830:	f1ae 0e46 	sub.w	lr, lr, #70	; 0x46
   d8834:	f240 116d 	movw	r1, #365	; 0x16d
   d8838:	fb01 fe0e 	mul.w	lr, r1, lr
   d883c:	69e9      	ldr	r1, [r5, #28]
   d883e:	eb12 020e 	adds.w	r2, r2, lr
   d8842:	eb43 73ee 	adc.w	r3, r3, lr, asr #31
   d8846:	1852      	adds	r2, r2, r1
   d8848:	f04f 0e18 	mov.w	lr, #24
   d884c:	eb43 73e1 	adc.w	r3, r3, r1, asr #31
   d8850:	fba2 010e 	umull	r0, r1, r2, lr
   d8854:	fb0e 1103 	mla	r1, lr, r3, r1
   d8858:	68ab      	ldr	r3, [r5, #8]
   d885a:	f04f 0e3c 	mov.w	lr, #60	; 0x3c
   d885e:	18c0      	adds	r0, r0, r3
   d8860:	eb41 71e3 	adc.w	r1, r1, r3, asr #31
   d8864:	fba0 230e 	umull	r2, r3, r0, lr
   d8868:	fb0e 3301 	mla	r3, lr, r1, r3
   d886c:	6869      	ldr	r1, [r5, #4]
   d886e:	1852      	adds	r2, r2, r1
   d8870:	eb43 73e1 	adc.w	r3, r3, r1, asr #31
   d8874:	fba2 010e 	umull	r0, r1, r2, lr
   d8878:	fb0e 1103 	mla	r1, lr, r3, r1
   d887c:	682b      	ldr	r3, [r5, #0]
   d887e:	4a67      	ldr	r2, [pc, #412]	; (d8a1c <strftime+0x858>)
   d8880:	18c0      	adds	r0, r0, r3
   d8882:	eb41 71e3 	adc.w	r1, r1, r3, asr #31
   d8886:	ebb0 0008 	subs.w	r0, r0, r8
   d888a:	eb61 71e8 	sbc.w	r1, r1, r8, asr #31
   d888e:	e9cd 0100 	strd	r0, r1, [sp]
   d8892:	4661      	mov	r1, ip
   d8894:	4650      	mov	r0, sl
   d8896:	f7fd fc5d 	bl	d6154 <sniprintf>
   d889a:	e5f8      	b.n	d848e <strftime+0x2ca>
   d889c:	682b      	ldr	r3, [r5, #0]
   d889e:	e07e      	b.n	d899e <strftime+0x7da>
   d88a0:	9b02      	ldr	r3, [sp, #8]
   d88a2:	429c      	cmp	r4, r3
   d88a4:	f080 8138 	bcs.w	d8b18 <strftime+0x954>
   d88a8:	2309      	movs	r3, #9
   d88aa:	e128      	b.n	d8afe <strftime+0x93a>
   d88ac:	682b      	ldr	r3, [r5, #0]
   d88ae:	9301      	str	r3, [sp, #4]
   d88b0:	686b      	ldr	r3, [r5, #4]
   d88b2:	9300      	str	r3, [sp, #0]
   d88b4:	4a5a      	ldr	r2, [pc, #360]	; (d8a20 <strftime+0x85c>)
   d88b6:	68ab      	ldr	r3, [r5, #8]
   d88b8:	1b31      	subs	r1, r6, r4
   d88ba:	1938      	adds	r0, r7, r4
   d88bc:	e60d      	b.n	d84da <strftime+0x316>
   d88be:	9b02      	ldr	r3, [sp, #8]
   d88c0:	429c      	cmp	r4, r3
   d88c2:	f080 8129 	bcs.w	d8b18 <strftime+0x954>
   d88c6:	69ab      	ldr	r3, [r5, #24]
   d88c8:	1c62      	adds	r2, r4, #1
   d88ca:	b90b      	cbnz	r3, d88d0 <strftime+0x70c>
   d88cc:	2337      	movs	r3, #55	; 0x37
   d88ce:	e000      	b.n	d88d2 <strftime+0x70e>
   d88d0:	3330      	adds	r3, #48	; 0x30
   d88d2:	553b      	strb	r3, [r7, r4]
   d88d4:	4614      	mov	r4, r2
   d88d6:	e114      	b.n	d8b02 <strftime+0x93e>
   d88d8:	69eb      	ldr	r3, [r5, #28]
   d88da:	69aa      	ldr	r2, [r5, #24]
   d88dc:	3307      	adds	r3, #7
   d88de:	1a9b      	subs	r3, r3, r2
   d88e0:	2207      	movs	r2, #7
   d88e2:	fb93 f3f2 	sdiv	r3, r3, r2
   d88e6:	e05a      	b.n	d899e <strftime+0x7da>
   d88e8:	4628      	mov	r0, r5
   d88ea:	f7ff fc0b 	bl	d8104 <iso_year_adjust>
   d88ee:	69aa      	ldr	r2, [r5, #24]
   d88f0:	b10a      	cbz	r2, d88f6 <strftime+0x732>
   d88f2:	1e53      	subs	r3, r2, #1
   d88f4:	e000      	b.n	d88f8 <strftime+0x734>
   d88f6:	2306      	movs	r3, #6
   d88f8:	2800      	cmp	r0, #0
   d88fa:	dc2f      	bgt.n	d895c <strftime+0x798>
   d88fc:	69ea      	ldr	r2, [r5, #28]
   d88fe:	d101      	bne.n	d8904 <strftime+0x740>
   d8900:	320a      	adds	r2, #10
   d8902:	e03b      	b.n	d897c <strftime+0x7b8>
   d8904:	1a9a      	subs	r2, r3, r2
   d8906:	696b      	ldr	r3, [r5, #20]
   d8908:	f240 716b 	movw	r1, #1899	; 0x76b
   d890c:	2b00      	cmp	r3, #0
   d890e:	bfb4      	ite	lt
   d8910:	4608      	movlt	r0, r1
   d8912:	f06f 0064 	mvnge.w	r0, #100	; 0x64
   d8916:	4418      	add	r0, r3
   d8918:	0781      	lsls	r1, r0, #30
   d891a:	d107      	bne.n	d892c <strftime+0x768>
   d891c:	4601      	mov	r1, r0
   d891e:	f04f 0e64 	mov.w	lr, #100	; 0x64
   d8922:	fb90 f0fe 	sdiv	r0, r0, lr
   d8926:	fb0e 1110 	mls	r1, lr, r0, r1
   d892a:	b981      	cbnz	r1, d894e <strftime+0x78a>
   d892c:	2b00      	cmp	r3, #0
   d892e:	f240 716b 	movw	r1, #1899	; 0x76b
   d8932:	bfa8      	it	ge
   d8934:	f06f 0164 	mvnge.w	r1, #100	; 0x64
   d8938:	4419      	add	r1, r3
   d893a:	f44f 73c8 	mov.w	r3, #400	; 0x190
   d893e:	fb91 f0f3 	sdiv	r0, r1, r3
   d8942:	fb03 1110 	mls	r1, r3, r0, r1
   d8946:	fab1 f181 	clz	r1, r1
   d894a:	0949      	lsrs	r1, r1, #5
   d894c:	e000      	b.n	d8950 <strftime+0x78c>
   d894e:	2101      	movs	r1, #1
   d8950:	1a52      	subs	r2, r2, r1
   d8952:	2a05      	cmp	r2, #5
   d8954:	bfb4      	ite	lt
   d8956:	2335      	movlt	r3, #53	; 0x35
   d8958:	2334      	movge	r3, #52	; 0x34
   d895a:	e020      	b.n	d899e <strftime+0x7da>
   d895c:	2301      	movs	r3, #1
   d895e:	e01e      	b.n	d899e <strftime+0x7da>
   d8960:	9b02      	ldr	r3, [sp, #8]
   d8962:	429c      	cmp	r4, r3
   d8964:	f080 80d8 	bcs.w	d8b18 <strftime+0x954>
   d8968:	69ab      	ldr	r3, [r5, #24]
   d896a:	3330      	adds	r3, #48	; 0x30
   d896c:	e0c7      	b.n	d8afe <strftime+0x93a>
   d896e:	69aa      	ldr	r2, [r5, #24]
   d8970:	b10a      	cbz	r2, d8976 <strftime+0x7b2>
   d8972:	1e53      	subs	r3, r2, #1
   d8974:	e000      	b.n	d8978 <strftime+0x7b4>
   d8976:	2306      	movs	r3, #6
   d8978:	69ea      	ldr	r2, [r5, #28]
   d897a:	3207      	adds	r2, #7
   d897c:	1ad2      	subs	r2, r2, r3
   d897e:	2307      	movs	r3, #7
   d8980:	fb92 f3f3 	sdiv	r3, r2, r3
   d8984:	e00b      	b.n	d899e <strftime+0x7da>
   d8986:	6968      	ldr	r0, [r5, #20]
   d8988:	2800      	cmp	r0, #0
   d898a:	da03      	bge.n	d8994 <strftime+0x7d0>
   d898c:	f200 706c 	addw	r0, r0, #1900	; 0x76c
   d8990:	f000 fc60 	bl	d9254 <abs>
   d8994:	2364      	movs	r3, #100	; 0x64
   d8996:	fb90 f2f3 	sdiv	r2, r0, r3
   d899a:	fb02 0313 	mls	r3, r2, r3, r0
   d899e:	4a21      	ldr	r2, [pc, #132]	; (d8a24 <strftime+0x860>)
   d89a0:	e571      	b.n	d8486 <strftime+0x2c2>
   d89a2:	696b      	ldr	r3, [r5, #20]
   d89a4:	4a20      	ldr	r2, [pc, #128]	; (d8a28 <strftime+0x864>)
   d89a6:	4293      	cmp	r3, r2
   d89a8:	f203 7b6c 	addw	fp, r3, #1900	; 0x76c
   d89ac:	da05      	bge.n	d89ba <strftime+0x7f6>
   d89ae:	232d      	movs	r3, #45	; 0x2d
   d89b0:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
   d89b4:	f1cb 0b00 	rsb	fp, fp, #0
   d89b8:	e008      	b.n	d89cc <strftime+0x808>
   d89ba:	f1ba 0f2b 	cmp.w	sl, #43	; 0x2b
   d89be:	d10d      	bne.n	d89dc <strftime+0x818>
   d89c0:	f242 730f 	movw	r3, #9999	; 0x270f
   d89c4:	459b      	cmp	fp, r3
   d89c6:	d911      	bls.n	d89ec <strftime+0x828>
   d89c8:	f88d a028 	strb.w	sl, [sp, #40]	; 0x28
   d89cc:	f1b8 0f00 	cmp.w	r8, #0
   d89d0:	d001      	beq.n	d89d6 <strftime+0x812>
   d89d2:	f108 38ff 	add.w	r8, r8, #4294967295
   d89d6:	f10d 0329 	add.w	r3, sp, #41	; 0x29
   d89da:	e000      	b.n	d89de <strftime+0x81a>
   d89dc:	ab0a      	add	r3, sp, #40	; 0x28
   d89de:	2225      	movs	r2, #37	; 0x25
   d89e0:	701a      	strb	r2, [r3, #0]
   d89e2:	f1ba 0f00 	cmp.w	sl, #0
   d89e6:	d108      	bne.n	d89fa <strftime+0x836>
   d89e8:	1c58      	adds	r0, r3, #1
   d89ea:	e009      	b.n	d8a00 <strftime+0x83c>
   d89ec:	f1b8 0f00 	cmp.w	r8, #0
   d89f0:	d1f4      	bne.n	d89dc <strftime+0x818>
   d89f2:	2325      	movs	r3, #37	; 0x25
   d89f4:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
   d89f8:	ab0a      	add	r3, sp, #40	; 0x28
   d89fa:	2230      	movs	r2, #48	; 0x30
   d89fc:	1c98      	adds	r0, r3, #2
   d89fe:	705a      	strb	r2, [r3, #1]
   d8a00:	490a      	ldr	r1, [pc, #40]	; (d8a2c <strftime+0x868>)
   d8a02:	f7ff fb77 	bl	d80f4 <strcpy>
   d8a06:	f8cd b000 	str.w	fp, [sp]
   d8a0a:	4643      	mov	r3, r8
   d8a0c:	aa0a      	add	r2, sp, #40	; 0x28
   d8a0e:	1b31      	subs	r1, r6, r4
   d8a10:	1938      	adds	r0, r7, r4
   d8a12:	e03e      	b.n	d8a92 <strftime+0x8ce>
   d8a14:	2003498c 	.word	0x2003498c
   d8a18:	000dabe9 	.word	0x000dabe9
   d8a1c:	000dabdf 	.word	0x000dabdf
   d8a20:	000dabe4 	.word	0x000dabe4
   d8a24:	000dabc5 	.word	0x000dabc5
   d8a28:	fffff894 	.word	0xfffff894
   d8a2c:	000dabd6 	.word	0x000dabd6
   d8a30:	6a2b      	ldr	r3, [r5, #32]
   d8a32:	2b00      	cmp	r3, #0
   d8a34:	db65      	blt.n	d8b02 <strftime+0x93e>
   d8a36:	f000 fa85 	bl	d8f44 <__tz_lock>
   d8a3a:	9b06      	ldr	r3, [sp, #24]
   d8a3c:	b91b      	cbnz	r3, d8a46 <strftime+0x882>
   d8a3e:	f000 fa83 	bl	d8f48 <_tzset_unlocked>
   d8a42:	2301      	movs	r3, #1
   d8a44:	9306      	str	r3, [sp, #24]
   d8a46:	f000 fc4d 	bl	d92e4 <__gettzinfo>
   d8a4a:	6a2b      	ldr	r3, [r5, #32]
   d8a4c:	2b00      	cmp	r3, #0
   d8a4e:	bfd4      	ite	le
   d8a50:	2300      	movle	r3, #0
   d8a52:	2301      	movgt	r3, #1
   d8a54:	221c      	movs	r2, #28
   d8a56:	fb02 0003 	mla	r0, r2, r3, r0
   d8a5a:	eb07 0a04 	add.w	sl, r7, r4
   d8a5e:	6a03      	ldr	r3, [r0, #32]
   d8a60:	f1c3 0800 	rsb	r8, r3, #0
   d8a64:	f000 fa6f 	bl	d8f46 <__tz_unlock>
   d8a68:	233c      	movs	r3, #60	; 0x3c
   d8a6a:	fb98 f0f3 	sdiv	r0, r8, r3
   d8a6e:	9307      	str	r3, [sp, #28]
   d8a70:	f000 fcd4 	bl	d941c <labs>
   d8a74:	9b07      	ldr	r3, [sp, #28]
   d8a76:	fb90 f2f3 	sdiv	r2, r0, r3
   d8a7a:	ebc4 0b06 	rsb	fp, r4, r6
   d8a7e:	fb02 0013 	mls	r0, r2, r3, r0
   d8a82:	4a28      	ldr	r2, [pc, #160]	; (d8b24 <strftime+0x960>)
   d8a84:	9000      	str	r0, [sp, #0]
   d8a86:	4659      	mov	r1, fp
   d8a88:	4650      	mov	r0, sl
   d8a8a:	f44f 6361 	mov.w	r3, #3600	; 0xe10
   d8a8e:	fb98 f3f3 	sdiv	r3, r8, r3
   d8a92:	f7fd fb5f 	bl	d6154 <sniprintf>
   d8a96:	e4fa      	b.n	d848e <strftime+0x2ca>
   d8a98:	4404      	add	r4, r0
   d8a9a:	42a6      	cmp	r6, r4
   d8a9c:	d831      	bhi.n	d8b02 <strftime+0x93e>
   d8a9e:	e03b      	b.n	d8b18 <strftime+0x954>
   d8aa0:	6a2b      	ldr	r3, [r5, #32]
   d8aa2:	2b00      	cmp	r3, #0
   d8aa4:	db2d      	blt.n	d8b02 <strftime+0x93e>
   d8aa6:	f000 fa4d 	bl	d8f44 <__tz_lock>
   d8aaa:	9b06      	ldr	r3, [sp, #24]
   d8aac:	b91b      	cbnz	r3, d8ab6 <strftime+0x8f2>
   d8aae:	f000 fa4b 	bl	d8f48 <_tzset_unlocked>
   d8ab2:	2301      	movs	r3, #1
   d8ab4:	9306      	str	r3, [sp, #24]
   d8ab6:	6a2b      	ldr	r3, [r5, #32]
   d8ab8:	4a1b      	ldr	r2, [pc, #108]	; (d8b28 <strftime+0x964>)
   d8aba:	2b00      	cmp	r3, #0
   d8abc:	bfd4      	ite	le
   d8abe:	2300      	movle	r3, #0
   d8ac0:	2301      	movgt	r3, #1
   d8ac2:	f852 8023 	ldr.w	r8, [r2, r3, lsl #2]
   d8ac6:	4640      	mov	r0, r8
   d8ac8:	f000 f830 	bl	d8b2c <strlen>
   d8acc:	f108 38ff 	add.w	r8, r8, #4294967295
   d8ad0:	193b      	adds	r3, r7, r4
   d8ad2:	4420      	add	r0, r4
   d8ad4:	4284      	cmp	r4, r0
   d8ad6:	d00b      	beq.n	d8af0 <strftime+0x92c>
   d8ad8:	9a02      	ldr	r2, [sp, #8]
   d8ada:	4294      	cmp	r4, r2
   d8adc:	d205      	bcs.n	d8aea <strftime+0x926>
   d8ade:	f818 2f01 	ldrb.w	r2, [r8, #1]!
   d8ae2:	f803 2b01 	strb.w	r2, [r3], #1
   d8ae6:	3401      	adds	r4, #1
   d8ae8:	e7f4      	b.n	d8ad4 <strftime+0x910>
   d8aea:	f000 fa2c 	bl	d8f46 <__tz_unlock>
   d8aee:	e013      	b.n	d8b18 <strftime+0x954>
   d8af0:	f000 fa29 	bl	d8f46 <__tz_unlock>
   d8af4:	e005      	b.n	d8b02 <strftime+0x93e>
   d8af6:	9b02      	ldr	r3, [sp, #8]
   d8af8:	429c      	cmp	r4, r3
   d8afa:	d20d      	bcs.n	d8b18 <strftime+0x954>
   d8afc:	2325      	movs	r3, #37	; 0x25
   d8afe:	553b      	strb	r3, [r7, r4]
   d8b00:	3401      	adds	r4, #1
   d8b02:	f899 3000 	ldrb.w	r3, [r9]
   d8b06:	b11b      	cbz	r3, d8b10 <strftime+0x94c>
   d8b08:	f109 0901 	add.w	r9, r9, #1
   d8b0c:	f7ff bb69 	b.w	d81e2 <strftime+0x1e>
   d8b10:	b126      	cbz	r6, d8b1c <strftime+0x958>
   d8b12:	2300      	movs	r3, #0
   d8b14:	553b      	strb	r3, [r7, r4]
   d8b16:	e001      	b.n	d8b1c <strftime+0x958>
   d8b18:	2000      	movs	r0, #0
   d8b1a:	e000      	b.n	d8b1e <strftime+0x95a>
   d8b1c:	4620      	mov	r0, r4
   d8b1e:	b013      	add	sp, #76	; 0x4c
   d8b20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   d8b24:	000dabf3 	.word	0x000dabf3
   d8b28:	200349f4 	.word	0x200349f4

000d8b2c <strlen>:
   d8b2c:	4603      	mov	r3, r0
   d8b2e:	f813 2b01 	ldrb.w	r2, [r3], #1
   d8b32:	2a00      	cmp	r2, #0
   d8b34:	d1fb      	bne.n	d8b2e <strlen+0x2>
   d8b36:	1a18      	subs	r0, r3, r0
   d8b38:	3801      	subs	r0, #1
   d8b3a:	4770      	bx	lr

000d8b3c <strncmp>:
   d8b3c:	b530      	push	{r4, r5, lr}
   d8b3e:	b182      	cbz	r2, d8b62 <strncmp+0x26>
   d8b40:	1e45      	subs	r5, r0, #1
   d8b42:	3901      	subs	r1, #1
   d8b44:	f815 3f01 	ldrb.w	r3, [r5, #1]!
   d8b48:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   d8b4c:	42a3      	cmp	r3, r4
   d8b4e:	d106      	bne.n	d8b5e <strncmp+0x22>
   d8b50:	43ec      	mvns	r4, r5
   d8b52:	4414      	add	r4, r2
   d8b54:	42e0      	cmn	r0, r4
   d8b56:	d001      	beq.n	d8b5c <strncmp+0x20>
   d8b58:	2b00      	cmp	r3, #0
   d8b5a:	d1f3      	bne.n	d8b44 <strncmp+0x8>
   d8b5c:	461c      	mov	r4, r3
   d8b5e:	1b18      	subs	r0, r3, r4
   d8b60:	bd30      	pop	{r4, r5, pc}
   d8b62:	4610      	mov	r0, r2
   d8b64:	bd30      	pop	{r4, r5, pc}

000d8b66 <strncpy>:
   d8b66:	b510      	push	{r4, lr}
   d8b68:	4603      	mov	r3, r0
   d8b6a:	b142      	cbz	r2, d8b7e <strncpy+0x18>
   d8b6c:	f811 4b01 	ldrb.w	r4, [r1], #1
   d8b70:	f803 4b01 	strb.w	r4, [r3], #1
   d8b74:	3a01      	subs	r2, #1
   d8b76:	2c00      	cmp	r4, #0
   d8b78:	d1f7      	bne.n	d8b6a <strncpy+0x4>
   d8b7a:	441a      	add	r2, r3
   d8b7c:	e000      	b.n	d8b80 <strncpy+0x1a>
   d8b7e:	bd10      	pop	{r4, pc}
   d8b80:	4293      	cmp	r3, r2
   d8b82:	d002      	beq.n	d8b8a <strncpy+0x24>
   d8b84:	f803 4b01 	strb.w	r4, [r3], #1
   d8b88:	e7fa      	b.n	d8b80 <strncpy+0x1a>
   d8b8a:	bd10      	pop	{r4, pc}

000d8b8c <_strtol_r>:
   d8b8c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   d8b90:	4680      	mov	r8, r0
   d8b92:	4840      	ldr	r0, [pc, #256]	; (d8c94 <_strtol_r+0x108>)
   d8b94:	f8d0 9000 	ldr.w	r9, [r0]
   d8b98:	460f      	mov	r7, r1
   d8b9a:	463d      	mov	r5, r7
   d8b9c:	f815 4b01 	ldrb.w	r4, [r5], #1
   d8ba0:	eb09 0004 	add.w	r0, r9, r4
   d8ba4:	7840      	ldrb	r0, [r0, #1]
   d8ba6:	f000 0008 	and.w	r0, r0, #8
   d8baa:	f000 06ff 	and.w	r6, r0, #255	; 0xff
   d8bae:	b108      	cbz	r0, d8bb4 <_strtol_r+0x28>
   d8bb0:	462f      	mov	r7, r5
   d8bb2:	e7f2      	b.n	d8b9a <_strtol_r+0xe>
   d8bb4:	2c2d      	cmp	r4, #45	; 0x2d
   d8bb6:	d103      	bne.n	d8bc0 <_strtol_r+0x34>
   d8bb8:	1cbd      	adds	r5, r7, #2
   d8bba:	787c      	ldrb	r4, [r7, #1]
   d8bbc:	2601      	movs	r6, #1
   d8bbe:	e003      	b.n	d8bc8 <_strtol_r+0x3c>
   d8bc0:	2c2b      	cmp	r4, #43	; 0x2b
   d8bc2:	bf04      	itt	eq
   d8bc4:	787c      	ldrbeq	r4, [r7, #1]
   d8bc6:	1cbd      	addeq	r5, r7, #2
   d8bc8:	b113      	cbz	r3, d8bd0 <_strtol_r+0x44>
   d8bca:	2b10      	cmp	r3, #16
   d8bcc:	d10a      	bne.n	d8be4 <_strtol_r+0x58>
   d8bce:	e05b      	b.n	d8c88 <_strtol_r+0xfc>
   d8bd0:	2c30      	cmp	r4, #48	; 0x30
   d8bd2:	d157      	bne.n	d8c84 <_strtol_r+0xf8>
   d8bd4:	7828      	ldrb	r0, [r5, #0]
   d8bd6:	f000 00df 	and.w	r0, r0, #223	; 0xdf
   d8bda:	2858      	cmp	r0, #88	; 0x58
   d8bdc:	d14d      	bne.n	d8c7a <_strtol_r+0xee>
   d8bde:	786c      	ldrb	r4, [r5, #1]
   d8be0:	2310      	movs	r3, #16
   d8be2:	3502      	adds	r5, #2
   d8be4:	2e00      	cmp	r6, #0
   d8be6:	bf14      	ite	ne
   d8be8:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
   d8bec:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
   d8bf0:	2700      	movs	r7, #0
   d8bf2:	fbbc faf3 	udiv	sl, ip, r3
   d8bf6:	4638      	mov	r0, r7
   d8bf8:	fb03 cc1a 	mls	ip, r3, sl, ip
   d8bfc:	eb09 0e04 	add.w	lr, r9, r4
   d8c00:	f89e e001 	ldrb.w	lr, [lr, #1]
   d8c04:	f01e 0f04 	tst.w	lr, #4
   d8c08:	d001      	beq.n	d8c0e <_strtol_r+0x82>
   d8c0a:	3c30      	subs	r4, #48	; 0x30
   d8c0c:	e00b      	b.n	d8c26 <_strtol_r+0x9a>
   d8c0e:	f01e 0e03 	ands.w	lr, lr, #3
   d8c12:	d01b      	beq.n	d8c4c <_strtol_r+0xc0>
   d8c14:	f1be 0f01 	cmp.w	lr, #1
   d8c18:	bf0c      	ite	eq
   d8c1a:	f04f 0e37 	moveq.w	lr, #55	; 0x37
   d8c1e:	f04f 0e57 	movne.w	lr, #87	; 0x57
   d8c22:	ebce 0404 	rsb	r4, lr, r4
   d8c26:	42a3      	cmp	r3, r4
   d8c28:	dd10      	ble.n	d8c4c <_strtol_r+0xc0>
   d8c2a:	f1b7 3fff 	cmp.w	r7, #4294967295
   d8c2e:	d00a      	beq.n	d8c46 <_strtol_r+0xba>
   d8c30:	4550      	cmp	r0, sl
   d8c32:	d806      	bhi.n	d8c42 <_strtol_r+0xb6>
   d8c34:	d101      	bne.n	d8c3a <_strtol_r+0xae>
   d8c36:	4564      	cmp	r4, ip
   d8c38:	dc03      	bgt.n	d8c42 <_strtol_r+0xb6>
   d8c3a:	fb03 4000 	mla	r0, r3, r0, r4
   d8c3e:	2701      	movs	r7, #1
   d8c40:	e001      	b.n	d8c46 <_strtol_r+0xba>
   d8c42:	f04f 37ff 	mov.w	r7, #4294967295
   d8c46:	f815 4b01 	ldrb.w	r4, [r5], #1
   d8c4a:	e7d7      	b.n	d8bfc <_strtol_r+0x70>
   d8c4c:	1c7b      	adds	r3, r7, #1
   d8c4e:	d10c      	bne.n	d8c6a <_strtol_r+0xde>
   d8c50:	2e00      	cmp	r6, #0
   d8c52:	f04f 0322 	mov.w	r3, #34	; 0x22
   d8c56:	bf14      	ite	ne
   d8c58:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
   d8c5c:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
   d8c60:	f8c8 3000 	str.w	r3, [r8]
   d8c64:	b92a      	cbnz	r2, d8c72 <_strtol_r+0xe6>
   d8c66:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   d8c6a:	b106      	cbz	r6, d8c6e <_strtol_r+0xe2>
   d8c6c:	4240      	negs	r0, r0
   d8c6e:	b172      	cbz	r2, d8c8e <_strtol_r+0x102>
   d8c70:	b107      	cbz	r7, d8c74 <_strtol_r+0xe8>
   d8c72:	1e69      	subs	r1, r5, #1
   d8c74:	6011      	str	r1, [r2, #0]
   d8c76:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   d8c7a:	2430      	movs	r4, #48	; 0x30
   d8c7c:	2b00      	cmp	r3, #0
   d8c7e:	d1b1      	bne.n	d8be4 <_strtol_r+0x58>
   d8c80:	2308      	movs	r3, #8
   d8c82:	e7af      	b.n	d8be4 <_strtol_r+0x58>
   d8c84:	230a      	movs	r3, #10
   d8c86:	e7ad      	b.n	d8be4 <_strtol_r+0x58>
   d8c88:	2c30      	cmp	r4, #48	; 0x30
   d8c8a:	d0a3      	beq.n	d8bd4 <_strtol_r+0x48>
   d8c8c:	e7aa      	b.n	d8be4 <_strtol_r+0x58>
   d8c8e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   d8c92:	bf00      	nop
   d8c94:	2003498c 	.word	0x2003498c

000d8c98 <strtol>:
   d8c98:	4613      	mov	r3, r2
   d8c9a:	460a      	mov	r2, r1
   d8c9c:	4601      	mov	r1, r0
   d8c9e:	4802      	ldr	r0, [pc, #8]	; (d8ca8 <strtol+0x10>)
   d8ca0:	6800      	ldr	r0, [r0, #0]
   d8ca2:	f7ff bf73 	b.w	d8b8c <_strtol_r>
   d8ca6:	bf00      	nop
   d8ca8:	200349f0 	.word	0x200349f0

000d8cac <_strtoul_r>:
   d8cac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   d8cb0:	4680      	mov	r8, r0
   d8cb2:	483c      	ldr	r0, [pc, #240]	; (d8da4 <_strtoul_r+0xf8>)
   d8cb4:	f8d0 9000 	ldr.w	r9, [r0]
   d8cb8:	460e      	mov	r6, r1
   d8cba:	4635      	mov	r5, r6
   d8cbc:	f815 4b01 	ldrb.w	r4, [r5], #1
   d8cc0:	eb09 0004 	add.w	r0, r9, r4
   d8cc4:	7840      	ldrb	r0, [r0, #1]
   d8cc6:	f000 0008 	and.w	r0, r0, #8
   d8cca:	f000 07ff 	and.w	r7, r0, #255	; 0xff
   d8cce:	b108      	cbz	r0, d8cd4 <_strtoul_r+0x28>
   d8cd0:	462e      	mov	r6, r5
   d8cd2:	e7f2      	b.n	d8cba <_strtoul_r+0xe>
   d8cd4:	2c2d      	cmp	r4, #45	; 0x2d
   d8cd6:	d103      	bne.n	d8ce0 <_strtoul_r+0x34>
   d8cd8:	1cb5      	adds	r5, r6, #2
   d8cda:	7874      	ldrb	r4, [r6, #1]
   d8cdc:	2701      	movs	r7, #1
   d8cde:	e003      	b.n	d8ce8 <_strtoul_r+0x3c>
   d8ce0:	2c2b      	cmp	r4, #43	; 0x2b
   d8ce2:	bf04      	itt	eq
   d8ce4:	7874      	ldrbeq	r4, [r6, #1]
   d8ce6:	1cb5      	addeq	r5, r6, #2
   d8ce8:	b113      	cbz	r3, d8cf0 <_strtoul_r+0x44>
   d8cea:	2b10      	cmp	r3, #16
   d8cec:	d10a      	bne.n	d8d04 <_strtoul_r+0x58>
   d8cee:	e053      	b.n	d8d98 <_strtoul_r+0xec>
   d8cf0:	2c30      	cmp	r4, #48	; 0x30
   d8cf2:	d14f      	bne.n	d8d94 <_strtoul_r+0xe8>
   d8cf4:	7828      	ldrb	r0, [r5, #0]
   d8cf6:	f000 00df 	and.w	r0, r0, #223	; 0xdf
   d8cfa:	2858      	cmp	r0, #88	; 0x58
   d8cfc:	d145      	bne.n	d8d8a <_strtoul_r+0xde>
   d8cfe:	786c      	ldrb	r4, [r5, #1]
   d8d00:	2310      	movs	r3, #16
   d8d02:	3502      	adds	r5, #2
   d8d04:	f04f 3cff 	mov.w	ip, #4294967295
   d8d08:	2600      	movs	r6, #0
   d8d0a:	fbbc fcf3 	udiv	ip, ip, r3
   d8d0e:	fb03 fa0c 	mul.w	sl, r3, ip
   d8d12:	ea6f 0a0a 	mvn.w	sl, sl
   d8d16:	4630      	mov	r0, r6
   d8d18:	eb09 0e04 	add.w	lr, r9, r4
   d8d1c:	f89e e001 	ldrb.w	lr, [lr, #1]
   d8d20:	f01e 0f04 	tst.w	lr, #4
   d8d24:	d001      	beq.n	d8d2a <_strtoul_r+0x7e>
   d8d26:	3c30      	subs	r4, #48	; 0x30
   d8d28:	e00b      	b.n	d8d42 <_strtoul_r+0x96>
   d8d2a:	f01e 0e03 	ands.w	lr, lr, #3
   d8d2e:	d01a      	beq.n	d8d66 <_strtoul_r+0xba>
   d8d30:	f1be 0f01 	cmp.w	lr, #1
   d8d34:	bf0c      	ite	eq
   d8d36:	f04f 0e37 	moveq.w	lr, #55	; 0x37
   d8d3a:	f04f 0e57 	movne.w	lr, #87	; 0x57
   d8d3e:	ebce 0404 	rsb	r4, lr, r4
   d8d42:	42a3      	cmp	r3, r4
   d8d44:	dd0f      	ble.n	d8d66 <_strtoul_r+0xba>
   d8d46:	2e00      	cmp	r6, #0
   d8d48:	db08      	blt.n	d8d5c <_strtoul_r+0xb0>
   d8d4a:	4560      	cmp	r0, ip
   d8d4c:	d806      	bhi.n	d8d5c <_strtoul_r+0xb0>
   d8d4e:	d101      	bne.n	d8d54 <_strtoul_r+0xa8>
   d8d50:	4554      	cmp	r4, sl
   d8d52:	dc03      	bgt.n	d8d5c <_strtoul_r+0xb0>
   d8d54:	fb03 4000 	mla	r0, r3, r0, r4
   d8d58:	2601      	movs	r6, #1
   d8d5a:	e001      	b.n	d8d60 <_strtoul_r+0xb4>
   d8d5c:	f04f 36ff 	mov.w	r6, #4294967295
   d8d60:	f815 4b01 	ldrb.w	r4, [r5], #1
   d8d64:	e7d8      	b.n	d8d18 <_strtoul_r+0x6c>
   d8d66:	2e00      	cmp	r6, #0
   d8d68:	da07      	bge.n	d8d7a <_strtoul_r+0xce>
   d8d6a:	2322      	movs	r3, #34	; 0x22
   d8d6c:	f8c8 3000 	str.w	r3, [r8]
   d8d70:	f04f 30ff 	mov.w	r0, #4294967295
   d8d74:	b92a      	cbnz	r2, d8d82 <_strtoul_r+0xd6>
   d8d76:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   d8d7a:	b107      	cbz	r7, d8d7e <_strtoul_r+0xd2>
   d8d7c:	4240      	negs	r0, r0
   d8d7e:	b172      	cbz	r2, d8d9e <_strtoul_r+0xf2>
   d8d80:	b106      	cbz	r6, d8d84 <_strtoul_r+0xd8>
   d8d82:	1e69      	subs	r1, r5, #1
   d8d84:	6011      	str	r1, [r2, #0]
   d8d86:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   d8d8a:	2430      	movs	r4, #48	; 0x30
   d8d8c:	2b00      	cmp	r3, #0
   d8d8e:	d1b9      	bne.n	d8d04 <_strtoul_r+0x58>
   d8d90:	2308      	movs	r3, #8
   d8d92:	e7b7      	b.n	d8d04 <_strtoul_r+0x58>
   d8d94:	230a      	movs	r3, #10
   d8d96:	e7b5      	b.n	d8d04 <_strtoul_r+0x58>
   d8d98:	2c30      	cmp	r4, #48	; 0x30
   d8d9a:	d0ab      	beq.n	d8cf4 <_strtoul_r+0x48>
   d8d9c:	e7b2      	b.n	d8d04 <_strtoul_r+0x58>
   d8d9e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   d8da2:	bf00      	nop
   d8da4:	2003498c 	.word	0x2003498c

000d8da8 <strtoul>:
   d8da8:	4613      	mov	r3, r2
   d8daa:	460a      	mov	r2, r1
   d8dac:	4601      	mov	r1, r0
   d8dae:	4802      	ldr	r0, [pc, #8]	; (d8db8 <strtoul+0x10>)
   d8db0:	6800      	ldr	r0, [r0, #0]
   d8db2:	f7ff bf7b 	b.w	d8cac <_strtoul_r>
   d8db6:	bf00      	nop
   d8db8:	200349f0 	.word	0x200349f0

000d8dbc <__get_current_time_locale>:
   d8dbc:	4b04      	ldr	r3, [pc, #16]	; (d8dd0 <__get_current_time_locale+0x14>)
   d8dbe:	4a05      	ldr	r2, [pc, #20]	; (d8dd4 <__get_current_time_locale+0x18>)
   d8dc0:	6818      	ldr	r0, [r3, #0]
   d8dc2:	4b05      	ldr	r3, [pc, #20]	; (d8dd8 <__get_current_time_locale+0x1c>)
   d8dc4:	2800      	cmp	r0, #0
   d8dc6:	bf14      	ite	ne
   d8dc8:	4610      	movne	r0, r2
   d8dca:	4618      	moveq	r0, r3
   d8dcc:	4770      	bx	lr
   d8dce:	bf00      	nop
   d8dd0:	2003e6c8 	.word	0x2003e6c8
   d8dd4:	2003e6cc 	.word	0x2003e6cc
   d8dd8:	000dad30 	.word	0x000dad30

000d8ddc <tolower>:
   d8ddc:	4b04      	ldr	r3, [pc, #16]	; (d8df0 <tolower+0x14>)
   d8dde:	681b      	ldr	r3, [r3, #0]
   d8de0:	4403      	add	r3, r0
   d8de2:	785b      	ldrb	r3, [r3, #1]
   d8de4:	f003 0303 	and.w	r3, r3, #3
   d8de8:	2b01      	cmp	r3, #1
   d8dea:	bf08      	it	eq
   d8dec:	3020      	addeq	r0, #32
   d8dee:	4770      	bx	lr
   d8df0:	2003498c 	.word	0x2003498c

000d8df4 <__tzcalc_limits>:
   d8df4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   d8df8:	4604      	mov	r4, r0
   d8dfa:	f000 fa73 	bl	d92e4 <__gettzinfo>
   d8dfe:	f240 73b1 	movw	r3, #1969	; 0x7b1
   d8e02:	429c      	cmp	r4, r3
   d8e04:	f340 8096 	ble.w	d8f34 <__tzcalc_limits+0x140>
   d8e08:	f46f 63f6 	mvn.w	r3, #1968	; 0x7b0
   d8e0c:	18e3      	adds	r3, r4, r3
   d8e0e:	f2a4 72b2 	subw	r2, r4, #1970	; 0x7b2
   d8e12:	109b      	asrs	r3, r3, #2
   d8e14:	f240 156d 	movw	r5, #365	; 0x16d
   d8e18:	fb05 3502 	mla	r5, r5, r2, r3
   d8e1c:	f2a4 726d 	subw	r2, r4, #1901	; 0x76d
   d8e20:	f06f 0363 	mvn.w	r3, #99	; 0x63
   d8e24:	fb92 f3f3 	sdiv	r3, r2, r3
   d8e28:	f46f 62c8 	mvn.w	r2, #1600	; 0x640
   d8e2c:	442b      	add	r3, r5
   d8e2e:	18a5      	adds	r5, r4, r2
   d8e30:	f44f 72c8 	mov.w	r2, #400	; 0x190
   d8e34:	fb95 f5f2 	sdiv	r5, r5, r2
   d8e38:	441d      	add	r5, r3
   d8e3a:	2364      	movs	r3, #100	; 0x64
   d8e3c:	fb94 f7f2 	sdiv	r7, r4, r2
   d8e40:	fb94 f6f3 	sdiv	r6, r4, r3
   d8e44:	fb02 4717 	mls	r7, r2, r7, r4
   d8e48:	fb03 4616 	mls	r6, r3, r6, r4
   d8e4c:	f100 0338 	add.w	r3, r0, #56	; 0x38
   d8e50:	fab7 fe87 	clz	lr, r7
   d8e54:	9301      	str	r3, [sp, #4]
   d8e56:	f004 0303 	and.w	r3, r4, #3
   d8e5a:	6044      	str	r4, [r0, #4]
   d8e5c:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
   d8e60:	4601      	mov	r1, r0
   d8e62:	9300      	str	r3, [sp, #0]
   d8e64:	f04f 0c07 	mov.w	ip, #7
   d8e68:	7a0b      	ldrb	r3, [r1, #8]
   d8e6a:	2b4a      	cmp	r3, #74	; 0x4a
   d8e6c:	d10e      	bne.n	d8e8c <__tzcalc_limits+0x98>
   d8e6e:	694b      	ldr	r3, [r1, #20]
   d8e70:	9a00      	ldr	r2, [sp, #0]
   d8e72:	18ec      	adds	r4, r5, r3
   d8e74:	b902      	cbnz	r2, d8e78 <__tzcalc_limits+0x84>
   d8e76:	b906      	cbnz	r6, d8e7a <__tzcalc_limits+0x86>
   d8e78:	b927      	cbnz	r7, d8e84 <__tzcalc_limits+0x90>
   d8e7a:	2b3b      	cmp	r3, #59	; 0x3b
   d8e7c:	bfd4      	ite	le
   d8e7e:	2300      	movle	r3, #0
   d8e80:	2301      	movgt	r3, #1
   d8e82:	e000      	b.n	d8e86 <__tzcalc_limits+0x92>
   d8e84:	2300      	movs	r3, #0
   d8e86:	4423      	add	r3, r4
   d8e88:	3b01      	subs	r3, #1
   d8e8a:	e03f      	b.n	d8f0c <__tzcalc_limits+0x118>
   d8e8c:	2b44      	cmp	r3, #68	; 0x44
   d8e8e:	d102      	bne.n	d8e96 <__tzcalc_limits+0xa2>
   d8e90:	694b      	ldr	r3, [r1, #20]
   d8e92:	442b      	add	r3, r5
   d8e94:	e03a      	b.n	d8f0c <__tzcalc_limits+0x118>
   d8e96:	9b00      	ldr	r3, [sp, #0]
   d8e98:	b92b      	cbnz	r3, d8ea6 <__tzcalc_limits+0xb2>
   d8e9a:	2e00      	cmp	r6, #0
   d8e9c:	bf0c      	ite	eq
   d8e9e:	46f0      	moveq	r8, lr
   d8ea0:	f04f 0801 	movne.w	r8, #1
   d8ea4:	e000      	b.n	d8ea8 <__tzcalc_limits+0xb4>
   d8ea6:	46f0      	mov	r8, lr
   d8ea8:	4b24      	ldr	r3, [pc, #144]	; (d8f3c <__tzcalc_limits+0x148>)
   d8eaa:	68cc      	ldr	r4, [r1, #12]
   d8eac:	2230      	movs	r2, #48	; 0x30
   d8eae:	fb02 3808 	mla	r8, r2, r8, r3
   d8eb2:	f1a8 0a04 	sub.w	sl, r8, #4
   d8eb6:	46a9      	mov	r9, r5
   d8eb8:	2301      	movs	r3, #1
   d8eba:	42a3      	cmp	r3, r4
   d8ebc:	da04      	bge.n	d8ec8 <__tzcalc_limits+0xd4>
   d8ebe:	f85a bf04 	ldr.w	fp, [sl, #4]!
   d8ec2:	3301      	adds	r3, #1
   d8ec4:	44d9      	add	r9, fp
   d8ec6:	e7f8      	b.n	d8eba <__tzcalc_limits+0xc6>
   d8ec8:	f109 0304 	add.w	r3, r9, #4
   d8ecc:	fb93 fbfc 	sdiv	fp, r3, ip
   d8ed0:	ebcb 0acb 	rsb	sl, fp, fp, lsl #3
   d8ed4:	2c01      	cmp	r4, #1
   d8ed6:	ebca 0a03 	rsb	sl, sl, r3
   d8eda:	694b      	ldr	r3, [r1, #20]
   d8edc:	bfb8      	it	lt
   d8ede:	2401      	movlt	r4, #1
   d8ee0:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
   d8ee4:	ebb3 0a0a 	subs.w	sl, r3, sl
   d8ee8:	690b      	ldr	r3, [r1, #16]
   d8eea:	f104 34ff 	add.w	r4, r4, #4294967295
   d8eee:	f103 33ff 	add.w	r3, r3, #4294967295
   d8ef2:	bf48      	it	mi
   d8ef4:	f10a 0a07 	addmi.w	sl, sl, #7
   d8ef8:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   d8efc:	f858 4024 	ldr.w	r4, [r8, r4, lsl #2]
   d8f00:	4453      	add	r3, sl
   d8f02:	42a3      	cmp	r3, r4
   d8f04:	db01      	blt.n	d8f0a <__tzcalc_limits+0x116>
   d8f06:	3b07      	subs	r3, #7
   d8f08:	e7fb      	b.n	d8f02 <__tzcalc_limits+0x10e>
   d8f0a:	444b      	add	r3, r9
   d8f0c:	698c      	ldr	r4, [r1, #24]
   d8f0e:	4a0c      	ldr	r2, [pc, #48]	; (d8f40 <__tzcalc_limits+0x14c>)
   d8f10:	fb02 4303 	mla	r3, r2, r3, r4
   d8f14:	6a0c      	ldr	r4, [r1, #32]
   d8f16:	4423      	add	r3, r4
   d8f18:	f841 3f1c 	str.w	r3, [r1, #28]!
   d8f1c:	9b01      	ldr	r3, [sp, #4]
   d8f1e:	4299      	cmp	r1, r3
   d8f20:	d1a2      	bne.n	d8e68 <__tzcalc_limits+0x74>
   d8f22:	69c3      	ldr	r3, [r0, #28]
   d8f24:	6b82      	ldr	r2, [r0, #56]	; 0x38
   d8f26:	4293      	cmp	r3, r2
   d8f28:	bfac      	ite	ge
   d8f2a:	2300      	movge	r3, #0
   d8f2c:	2301      	movlt	r3, #1
   d8f2e:	6003      	str	r3, [r0, #0]
   d8f30:	2001      	movs	r0, #1
   d8f32:	e000      	b.n	d8f36 <__tzcalc_limits+0x142>
   d8f34:	2000      	movs	r0, #0
   d8f36:	b003      	add	sp, #12
   d8f38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   d8f3c:	000dab44 	.word	0x000dab44
   d8f40:	00015180 	.word	0x00015180

000d8f44 <__tz_lock>:
   d8f44:	4770      	bx	lr

000d8f46 <__tz_unlock>:
   d8f46:	4770      	bx	lr

000d8f48 <_tzset_unlocked>:
   d8f48:	4b01      	ldr	r3, [pc, #4]	; (d8f50 <_tzset_unlocked+0x8>)
   d8f4a:	6818      	ldr	r0, [r3, #0]
   d8f4c:	f000 b802 	b.w	d8f54 <_tzset_unlocked_r>
   d8f50:	200349f0 	.word	0x200349f0

000d8f54 <_tzset_unlocked_r>:
   d8f54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   d8f58:	b08d      	sub	sp, #52	; 0x34
   d8f5a:	4607      	mov	r7, r0
   d8f5c:	f000 f9c2 	bl	d92e4 <__gettzinfo>
   d8f60:	49b0      	ldr	r1, [pc, #704]	; (d9224 <_tzset_unlocked_r+0x2d0>)
   d8f62:	4eb1      	ldr	r6, [pc, #708]	; (d9228 <_tzset_unlocked_r+0x2d4>)
   d8f64:	4604      	mov	r4, r0
   d8f66:	4638      	mov	r0, r7
   d8f68:	f000 f9b4 	bl	d92d4 <_getenv_r>
   d8f6c:	4605      	mov	r5, r0
   d8f6e:	b960      	cbnz	r0, d8f8a <_tzset_unlocked_r+0x36>
   d8f70:	4bae      	ldr	r3, [pc, #696]	; (d922c <_tzset_unlocked_r+0x2d8>)
   d8f72:	4aaf      	ldr	r2, [pc, #700]	; (d9230 <_tzset_unlocked_r+0x2dc>)
   d8f74:	6018      	str	r0, [r3, #0]
   d8f76:	4baf      	ldr	r3, [pc, #700]	; (d9234 <_tzset_unlocked_r+0x2e0>)
   d8f78:	6018      	str	r0, [r3, #0]
   d8f7a:	4baf      	ldr	r3, [pc, #700]	; (d9238 <_tzset_unlocked_r+0x2e4>)
   d8f7c:	6830      	ldr	r0, [r6, #0]
   d8f7e:	601a      	str	r2, [r3, #0]
   d8f80:	605a      	str	r2, [r3, #4]
   d8f82:	f7fd f8b7 	bl	d60f4 <free>
   d8f86:	6035      	str	r5, [r6, #0]
   d8f88:	e148      	b.n	d921c <_tzset_unlocked_r+0x2c8>
   d8f8a:	6831      	ldr	r1, [r6, #0]
   d8f8c:	b979      	cbnz	r1, d8fae <_tzset_unlocked_r+0x5a>
   d8f8e:	6830      	ldr	r0, [r6, #0]
   d8f90:	f7fd f8b0 	bl	d60f4 <free>
   d8f94:	4628      	mov	r0, r5
   d8f96:	f7ff fdc9 	bl	d8b2c <strlen>
   d8f9a:	1c41      	adds	r1, r0, #1
   d8f9c:	4638      	mov	r0, r7
   d8f9e:	f7fd f8e1 	bl	d6164 <_malloc_r>
   d8fa2:	6030      	str	r0, [r6, #0]
   d8fa4:	b148      	cbz	r0, d8fba <_tzset_unlocked_r+0x66>
   d8fa6:	4629      	mov	r1, r5
   d8fa8:	f7ff f8a4 	bl	d80f4 <strcpy>
   d8fac:	e005      	b.n	d8fba <_tzset_unlocked_r+0x66>
   d8fae:	f7ff f897 	bl	d80e0 <strcmp>
   d8fb2:	2800      	cmp	r0, #0
   d8fb4:	f000 8132 	beq.w	d921c <_tzset_unlocked_r+0x2c8>
   d8fb8:	e7e9      	b.n	d8f8e <_tzset_unlocked_r+0x3a>
   d8fba:	782b      	ldrb	r3, [r5, #0]
   d8fbc:	4a9f      	ldr	r2, [pc, #636]	; (d923c <_tzset_unlocked_r+0x2e8>)
   d8fbe:	49a0      	ldr	r1, [pc, #640]	; (d9240 <_tzset_unlocked_r+0x2ec>)
   d8fc0:	2b3a      	cmp	r3, #58	; 0x3a
   d8fc2:	bf08      	it	eq
   d8fc4:	3501      	addeq	r5, #1
   d8fc6:	ae0a      	add	r6, sp, #40	; 0x28
   d8fc8:	4633      	mov	r3, r6
   d8fca:	4628      	mov	r0, r5
   d8fcc:	f7fd f8b2 	bl	d6134 <siscanf>
   d8fd0:	2800      	cmp	r0, #0
   d8fd2:	f340 8123 	ble.w	d921c <_tzset_unlocked_r+0x2c8>
   d8fd6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   d8fd8:	18ef      	adds	r7, r5, r3
   d8fda:	5ceb      	ldrb	r3, [r5, r3]
   d8fdc:	2b2d      	cmp	r3, #45	; 0x2d
   d8fde:	d103      	bne.n	d8fe8 <_tzset_unlocked_r+0x94>
   d8fe0:	3701      	adds	r7, #1
   d8fe2:	f04f 35ff 	mov.w	r5, #4294967295
   d8fe6:	e003      	b.n	d8ff0 <_tzset_unlocked_r+0x9c>
   d8fe8:	2b2b      	cmp	r3, #43	; 0x2b
   d8fea:	bf08      	it	eq
   d8fec:	3701      	addeq	r7, #1
   d8fee:	2501      	movs	r5, #1
   d8ff0:	f10d 0a20 	add.w	sl, sp, #32
   d8ff4:	f10d 0b1e 	add.w	fp, sp, #30
   d8ff8:	f04f 0800 	mov.w	r8, #0
   d8ffc:	9603      	str	r6, [sp, #12]
   d8ffe:	f8cd a008 	str.w	sl, [sp, #8]
   d9002:	9601      	str	r6, [sp, #4]
   d9004:	f8cd b000 	str.w	fp, [sp]
   d9008:	4633      	mov	r3, r6
   d900a:	aa07      	add	r2, sp, #28
   d900c:	498d      	ldr	r1, [pc, #564]	; (d9244 <_tzset_unlocked_r+0x2f0>)
   d900e:	f8ad 801e 	strh.w	r8, [sp, #30]
   d9012:	4638      	mov	r0, r7
   d9014:	f8ad 8020 	strh.w	r8, [sp, #32]
   d9018:	f7fd f88c 	bl	d6134 <siscanf>
   d901c:	4540      	cmp	r0, r8
   d901e:	f340 80fd 	ble.w	d921c <_tzset_unlocked_r+0x2c8>
   d9022:	f8bd 201e 	ldrh.w	r2, [sp, #30]
   d9026:	f8bd 3020 	ldrh.w	r3, [sp, #32]
   d902a:	f8df 9224 	ldr.w	r9, [pc, #548]	; d9250 <_tzset_unlocked_r+0x2fc>
   d902e:	213c      	movs	r1, #60	; 0x3c
   d9030:	fb01 3302 	mla	r3, r1, r2, r3
   d9034:	f8bd 201c 	ldrh.w	r2, [sp, #28]
   d9038:	f44f 6161 	mov.w	r1, #3600	; 0xe10
   d903c:	fb01 3302 	mla	r3, r1, r2, r3
   d9040:	435d      	muls	r5, r3
   d9042:	6225      	str	r5, [r4, #32]
   d9044:	4d7c      	ldr	r5, [pc, #496]	; (d9238 <_tzset_unlocked_r+0x2e4>)
   d9046:	4b7d      	ldr	r3, [pc, #500]	; (d923c <_tzset_unlocked_r+0x2e8>)
   d9048:	602b      	str	r3, [r5, #0]
   d904a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   d904c:	497c      	ldr	r1, [pc, #496]	; (d9240 <_tzset_unlocked_r+0x2ec>)
   d904e:	441f      	add	r7, r3
   d9050:	464a      	mov	r2, r9
   d9052:	4633      	mov	r3, r6
   d9054:	4638      	mov	r0, r7
   d9056:	f7fd f86d 	bl	d6134 <siscanf>
   d905a:	4540      	cmp	r0, r8
   d905c:	dc08      	bgt.n	d9070 <_tzset_unlocked_r+0x11c>
   d905e:	682b      	ldr	r3, [r5, #0]
   d9060:	606b      	str	r3, [r5, #4]
   d9062:	4b72      	ldr	r3, [pc, #456]	; (d922c <_tzset_unlocked_r+0x2d8>)
   d9064:	6a22      	ldr	r2, [r4, #32]
   d9066:	601a      	str	r2, [r3, #0]
   d9068:	4b72      	ldr	r3, [pc, #456]	; (d9234 <_tzset_unlocked_r+0x2e0>)
   d906a:	f8c3 8000 	str.w	r8, [r3]
   d906e:	e0d5      	b.n	d921c <_tzset_unlocked_r+0x2c8>
   d9070:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   d9072:	f8c5 9004 	str.w	r9, [r5, #4]
   d9076:	18fd      	adds	r5, r7, r3
   d9078:	5cfb      	ldrb	r3, [r7, r3]
   d907a:	2b2d      	cmp	r3, #45	; 0x2d
   d907c:	d103      	bne.n	d9086 <_tzset_unlocked_r+0x132>
   d907e:	3501      	adds	r5, #1
   d9080:	f04f 37ff 	mov.w	r7, #4294967295
   d9084:	e003      	b.n	d908e <_tzset_unlocked_r+0x13a>
   d9086:	2b2b      	cmp	r3, #43	; 0x2b
   d9088:	bf08      	it	eq
   d908a:	3501      	addeq	r5, #1
   d908c:	2701      	movs	r7, #1
   d908e:	2300      	movs	r3, #0
   d9090:	f8ad 301c 	strh.w	r3, [sp, #28]
   d9094:	f8ad 301e 	strh.w	r3, [sp, #30]
   d9098:	f8ad 3020 	strh.w	r3, [sp, #32]
   d909c:	930a      	str	r3, [sp, #40]	; 0x28
   d909e:	9603      	str	r6, [sp, #12]
   d90a0:	f8cd a008 	str.w	sl, [sp, #8]
   d90a4:	9601      	str	r6, [sp, #4]
   d90a6:	f8cd b000 	str.w	fp, [sp]
   d90aa:	4633      	mov	r3, r6
   d90ac:	aa07      	add	r2, sp, #28
   d90ae:	4965      	ldr	r1, [pc, #404]	; (d9244 <_tzset_unlocked_r+0x2f0>)
   d90b0:	4628      	mov	r0, r5
   d90b2:	f7fd f83f 	bl	d6134 <siscanf>
   d90b6:	2800      	cmp	r0, #0
   d90b8:	dc04      	bgt.n	d90c4 <_tzset_unlocked_r+0x170>
   d90ba:	6a23      	ldr	r3, [r4, #32]
   d90bc:	f5a3 6361 	sub.w	r3, r3, #3600	; 0xe10
   d90c0:	63e3      	str	r3, [r4, #60]	; 0x3c
   d90c2:	e00e      	b.n	d90e2 <_tzset_unlocked_r+0x18e>
   d90c4:	f8bd 201e 	ldrh.w	r2, [sp, #30]
   d90c8:	f8bd 3020 	ldrh.w	r3, [sp, #32]
   d90cc:	213c      	movs	r1, #60	; 0x3c
   d90ce:	fb01 3302 	mla	r3, r1, r2, r3
   d90d2:	f8bd 201c 	ldrh.w	r2, [sp, #28]
   d90d6:	f44f 6161 	mov.w	r1, #3600	; 0xe10
   d90da:	fb01 3302 	mla	r3, r1, r2, r3
   d90de:	435f      	muls	r7, r3
   d90e0:	63e7      	str	r7, [r4, #60]	; 0x3c
   d90e2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   d90e4:	4627      	mov	r7, r4
   d90e6:	441d      	add	r5, r3
   d90e8:	f04f 0900 	mov.w	r9, #0
   d90ec:	782b      	ldrb	r3, [r5, #0]
   d90ee:	2b2c      	cmp	r3, #44	; 0x2c
   d90f0:	bf08      	it	eq
   d90f2:	3501      	addeq	r5, #1
   d90f4:	f895 8000 	ldrb.w	r8, [r5]
   d90f8:	f1b8 0f4d 	cmp.w	r8, #77	; 0x4d
   d90fc:	d126      	bne.n	d914c <_tzset_unlocked_r+0x1f8>
   d90fe:	f10d 0326 	add.w	r3, sp, #38	; 0x26
   d9102:	9302      	str	r3, [sp, #8]
   d9104:	ab09      	add	r3, sp, #36	; 0x24
   d9106:	9300      	str	r3, [sp, #0]
   d9108:	9603      	str	r6, [sp, #12]
   d910a:	9601      	str	r6, [sp, #4]
   d910c:	4633      	mov	r3, r6
   d910e:	f10d 0222 	add.w	r2, sp, #34	; 0x22
   d9112:	494d      	ldr	r1, [pc, #308]	; (d9248 <_tzset_unlocked_r+0x2f4>)
   d9114:	4628      	mov	r0, r5
   d9116:	f7fd f80d 	bl	d6134 <siscanf>
   d911a:	2803      	cmp	r0, #3
   d911c:	d17e      	bne.n	d921c <_tzset_unlocked_r+0x2c8>
   d911e:	f8bd 1022 	ldrh.w	r1, [sp, #34]	; 0x22
   d9122:	1e4b      	subs	r3, r1, #1
   d9124:	2b0b      	cmp	r3, #11
   d9126:	d879      	bhi.n	d921c <_tzset_unlocked_r+0x2c8>
   d9128:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
   d912c:	1e53      	subs	r3, r2, #1
   d912e:	2b04      	cmp	r3, #4
   d9130:	d874      	bhi.n	d921c <_tzset_unlocked_r+0x2c8>
   d9132:	f8bd 3026 	ldrh.w	r3, [sp, #38]	; 0x26
   d9136:	2b06      	cmp	r3, #6
   d9138:	d870      	bhi.n	d921c <_tzset_unlocked_r+0x2c8>
   d913a:	f887 8008 	strb.w	r8, [r7, #8]
   d913e:	60f9      	str	r1, [r7, #12]
   d9140:	613a      	str	r2, [r7, #16]
   d9142:	617b      	str	r3, [r7, #20]
   d9144:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   d9146:	eb05 0803 	add.w	r8, r5, r3
   d914a:	e02a      	b.n	d91a2 <_tzset_unlocked_r+0x24e>
   d914c:	f1b8 0f4a 	cmp.w	r8, #74	; 0x4a
   d9150:	bf06      	itte	eq
   d9152:	3501      	addeq	r5, #1
   d9154:	4643      	moveq	r3, r8
   d9156:	2344      	movne	r3, #68	; 0x44
   d9158:	220a      	movs	r2, #10
   d915a:	a90b      	add	r1, sp, #44	; 0x2c
   d915c:	4628      	mov	r0, r5
   d915e:	9305      	str	r3, [sp, #20]
   d9160:	f7ff fe22 	bl	d8da8 <strtoul>
   d9164:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
   d9168:	f8ad 0026 	strh.w	r0, [sp, #38]	; 0x26
   d916c:	4545      	cmp	r5, r8
   d916e:	9b05      	ldr	r3, [sp, #20]
   d9170:	d114      	bne.n	d919c <_tzset_unlocked_r+0x248>
   d9172:	234d      	movs	r3, #77	; 0x4d
   d9174:	f1b9 0f00 	cmp.w	r9, #0
   d9178:	d107      	bne.n	d918a <_tzset_unlocked_r+0x236>
   d917a:	7223      	strb	r3, [r4, #8]
   d917c:	2303      	movs	r3, #3
   d917e:	60e3      	str	r3, [r4, #12]
   d9180:	2302      	movs	r3, #2
   d9182:	6123      	str	r3, [r4, #16]
   d9184:	f8c4 9014 	str.w	r9, [r4, #20]
   d9188:	e00b      	b.n	d91a2 <_tzset_unlocked_r+0x24e>
   d918a:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
   d918e:	230b      	movs	r3, #11
   d9190:	62a3      	str	r3, [r4, #40]	; 0x28
   d9192:	2301      	movs	r3, #1
   d9194:	62e3      	str	r3, [r4, #44]	; 0x2c
   d9196:	2300      	movs	r3, #0
   d9198:	6323      	str	r3, [r4, #48]	; 0x30
   d919a:	e002      	b.n	d91a2 <_tzset_unlocked_r+0x24e>
   d919c:	b280      	uxth	r0, r0
   d919e:	723b      	strb	r3, [r7, #8]
   d91a0:	6178      	str	r0, [r7, #20]
   d91a2:	2302      	movs	r3, #2
   d91a4:	f8ad 301c 	strh.w	r3, [sp, #28]
   d91a8:	2300      	movs	r3, #0
   d91aa:	f8ad 301e 	strh.w	r3, [sp, #30]
   d91ae:	f8ad 3020 	strh.w	r3, [sp, #32]
   d91b2:	930a      	str	r3, [sp, #40]	; 0x28
   d91b4:	f898 3000 	ldrb.w	r3, [r8]
   d91b8:	2b2f      	cmp	r3, #47	; 0x2f
   d91ba:	d10b      	bne.n	d91d4 <_tzset_unlocked_r+0x280>
   d91bc:	9603      	str	r6, [sp, #12]
   d91be:	f8cd a008 	str.w	sl, [sp, #8]
   d91c2:	9601      	str	r6, [sp, #4]
   d91c4:	f8cd b000 	str.w	fp, [sp]
   d91c8:	4633      	mov	r3, r6
   d91ca:	aa07      	add	r2, sp, #28
   d91cc:	491f      	ldr	r1, [pc, #124]	; (d924c <_tzset_unlocked_r+0x2f8>)
   d91ce:	4640      	mov	r0, r8
   d91d0:	f7fc ffb0 	bl	d6134 <siscanf>
   d91d4:	f8bd 201e 	ldrh.w	r2, [sp, #30]
   d91d8:	f8bd 3020 	ldrh.w	r3, [sp, #32]
   d91dc:	213c      	movs	r1, #60	; 0x3c
   d91de:	fb01 3302 	mla	r3, r1, r2, r3
   d91e2:	f8bd 201c 	ldrh.w	r2, [sp, #28]
   d91e6:	f44f 6161 	mov.w	r1, #3600	; 0xe10
   d91ea:	fb01 3302 	mla	r3, r1, r2, r3
   d91ee:	61bb      	str	r3, [r7, #24]
   d91f0:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   d91f2:	f109 0901 	add.w	r9, r9, #1
   d91f6:	f1b9 0f02 	cmp.w	r9, #2
   d91fa:	4445      	add	r5, r8
   d91fc:	f107 071c 	add.w	r7, r7, #28
   d9200:	f47f af74 	bne.w	d90ec <_tzset_unlocked_r+0x198>
   d9204:	6860      	ldr	r0, [r4, #4]
   d9206:	f7ff fdf5 	bl	d8df4 <__tzcalc_limits>
   d920a:	4b08      	ldr	r3, [pc, #32]	; (d922c <_tzset_unlocked_r+0x2d8>)
   d920c:	6a22      	ldr	r2, [r4, #32]
   d920e:	601a      	str	r2, [r3, #0]
   d9210:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   d9212:	1a9b      	subs	r3, r3, r2
   d9214:	4a07      	ldr	r2, [pc, #28]	; (d9234 <_tzset_unlocked_r+0x2e0>)
   d9216:	bf18      	it	ne
   d9218:	2301      	movne	r3, #1
   d921a:	6013      	str	r3, [r2, #0]
   d921c:	b00d      	add	sp, #52	; 0x34
   d921e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   d9222:	bf00      	nop
   d9224:	000dae2c 	.word	0x000dae2c
   d9228:	2003e7e0 	.word	0x2003e7e0
   d922c:	2003e7e8 	.word	0x2003e7e8
   d9230:	000dae2f 	.word	0x000dae2f
   d9234:	2003e7e4 	.word	0x2003e7e4
   d9238:	200349f4 	.word	0x200349f4
   d923c:	2003e7d3 	.word	0x2003e7d3
   d9240:	000dae33 	.word	0x000dae33
   d9244:	000dae56 	.word	0x000dae56
   d9248:	000dae42 	.word	0x000dae42
   d924c:	000dae55 	.word	0x000dae55
   d9250:	2003e7c8 	.word	0x2003e7c8

000d9254 <abs>:
   d9254:	2800      	cmp	r0, #0
   d9256:	bfb8      	it	lt
   d9258:	4240      	neglt	r0, r0
   d925a:	4770      	bx	lr

000d925c <_findenv_r>:
   d925c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   d9260:	4607      	mov	r7, r0
   d9262:	468b      	mov	fp, r1
   d9264:	4690      	mov	r8, r2
   d9266:	f000 f8dd 	bl	d9424 <__env_lock>
   d926a:	4b19      	ldr	r3, [pc, #100]	; (d92d0 <_findenv_r+0x74>)
   d926c:	681d      	ldr	r5, [r3, #0]
   d926e:	469a      	mov	sl, r3
   d9270:	b13d      	cbz	r5, d9282 <_findenv_r+0x26>
   d9272:	465c      	mov	r4, fp
   d9274:	4623      	mov	r3, r4
   d9276:	f813 2b01 	ldrb.w	r2, [r3], #1
   d927a:	b142      	cbz	r2, d928e <_findenv_r+0x32>
   d927c:	2a3d      	cmp	r2, #61	; 0x3d
   d927e:	461c      	mov	r4, r3
   d9280:	d1f8      	bne.n	d9274 <_findenv_r+0x18>
   d9282:	4638      	mov	r0, r7
   d9284:	f000 f8cf 	bl	d9426 <__env_unlock>
   d9288:	2000      	movs	r0, #0
   d928a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   d928e:	ebcb 0404 	rsb	r4, fp, r4
   d9292:	46a9      	mov	r9, r5
   d9294:	f859 0b04 	ldr.w	r0, [r9], #4
   d9298:	2800      	cmp	r0, #0
   d929a:	d0f2      	beq.n	d9282 <_findenv_r+0x26>
   d929c:	4622      	mov	r2, r4
   d929e:	4659      	mov	r1, fp
   d92a0:	f7ff fc4c 	bl	d8b3c <strncmp>
   d92a4:	b988      	cbnz	r0, d92ca <_findenv_r+0x6e>
   d92a6:	f859 3c04 	ldr.w	r3, [r9, #-4]
   d92aa:	191e      	adds	r6, r3, r4
   d92ac:	5d1b      	ldrb	r3, [r3, r4]
   d92ae:	2b3d      	cmp	r3, #61	; 0x3d
   d92b0:	d10b      	bne.n	d92ca <_findenv_r+0x6e>
   d92b2:	f8da 3000 	ldr.w	r3, [sl]
   d92b6:	1aed      	subs	r5, r5, r3
   d92b8:	10ad      	asrs	r5, r5, #2
   d92ba:	4638      	mov	r0, r7
   d92bc:	f8c8 5000 	str.w	r5, [r8]
   d92c0:	f000 f8b1 	bl	d9426 <__env_unlock>
   d92c4:	1c70      	adds	r0, r6, #1
   d92c6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   d92ca:	464d      	mov	r5, r9
   d92cc:	e7e1      	b.n	d9292 <_findenv_r+0x36>
   d92ce:	bf00      	nop
   d92d0:	20034a3c 	.word	0x20034a3c

000d92d4 <_getenv_r>:
   d92d4:	b507      	push	{r0, r1, r2, lr}
   d92d6:	aa01      	add	r2, sp, #4
   d92d8:	f7ff ffc0 	bl	d925c <_findenv_r>
   d92dc:	b003      	add	sp, #12
   d92de:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000d92e4 <__gettzinfo>:
   d92e4:	4800      	ldr	r0, [pc, #0]	; (d92e8 <__gettzinfo+0x4>)
   d92e6:	4770      	bx	lr
   d92e8:	200349fc 	.word	0x200349fc

000d92ec <gmtime_r>:
   d92ec:	6802      	ldr	r2, [r0, #0]
   d92ee:	4b47      	ldr	r3, [pc, #284]	; (d940c <gmtime_r+0x120>)
   d92f0:	b5f0      	push	{r4, r5, r6, r7, lr}
   d92f2:	fb92 f4f3 	sdiv	r4, r2, r3
   d92f6:	fb03 2214 	mls	r2, r3, r4, r2
   d92fa:	2a00      	cmp	r2, #0
   d92fc:	bfbc      	itt	lt
   d92fe:	f502 32a8 	addlt.w	r2, r2, #86016	; 0x15000
   d9302:	f502 72c0 	addlt.w	r2, r2, #384	; 0x180
   d9306:	f44f 6061 	mov.w	r0, #3600	; 0xe10
   d930a:	f504 242f 	add.w	r4, r4, #716800	; 0xaf000
   d930e:	fb92 f3f0 	sdiv	r3, r2, r0
   d9312:	fb00 2213 	mls	r2, r0, r3, r2
   d9316:	f04f 003c 	mov.w	r0, #60	; 0x3c
   d931a:	bfac      	ite	ge
   d931c:	f604 246c 	addwge	r4, r4, #2668	; 0xa6c
   d9320:	f604 246b 	addwlt	r4, r4, #2667	; 0xa6b
   d9324:	608b      	str	r3, [r1, #8]
   d9326:	fb92 f3f0 	sdiv	r3, r2, r0
   d932a:	fb00 2213 	mls	r2, r0, r3, r2
   d932e:	604b      	str	r3, [r1, #4]
   d9330:	600a      	str	r2, [r1, #0]
   d9332:	2307      	movs	r3, #7
   d9334:	1ce2      	adds	r2, r4, #3
   d9336:	fb92 f3f3 	sdiv	r3, r2, r3
   d933a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   d933e:	1ad3      	subs	r3, r2, r3
   d9340:	618b      	str	r3, [r1, #24]
   d9342:	4b33      	ldr	r3, [pc, #204]	; (d9410 <gmtime_r+0x124>)
   d9344:	4d33      	ldr	r5, [pc, #204]	; (d9414 <gmtime_r+0x128>)
   d9346:	fb94 f5f5 	sdiv	r5, r4, r5
   d934a:	fb03 4405 	mla	r4, r3, r5, r4
   d934e:	f648 62ac 	movw	r2, #36524	; 0x8eac
   d9352:	fbb4 f2f2 	udiv	r2, r4, r2
   d9356:	4422      	add	r2, r4
   d9358:	f240 57b4 	movw	r7, #1460	; 0x5b4
   d935c:	fbb4 f3f7 	udiv	r3, r4, r7
   d9360:	1ad2      	subs	r2, r2, r3
   d9362:	482d      	ldr	r0, [pc, #180]	; (d9418 <gmtime_r+0x12c>)
   d9364:	fbb4 f0f0 	udiv	r0, r4, r0
   d9368:	f648 6694 	movw	r6, #36500	; 0x8e94
   d936c:	1a13      	subs	r3, r2, r0
   d936e:	fbb3 f6f6 	udiv	r6, r3, r6
   d9372:	4434      	add	r4, r6
   d9374:	f240 126d 	movw	r2, #365	; 0x16d
   d9378:	fbb3 f0f2 	udiv	r0, r3, r2
   d937c:	fbb3 f3f7 	udiv	r3, r3, r7
   d9380:	1ae3      	subs	r3, r4, r3
   d9382:	fb02 3310 	mls	r3, r2, r0, r3
   d9386:	2499      	movs	r4, #153	; 0x99
   d9388:	eb03 0283 	add.w	r2, r3, r3, lsl #2
   d938c:	3202      	adds	r2, #2
   d938e:	fbb2 f2f4 	udiv	r2, r2, r4
   d9392:	2a0a      	cmp	r2, #10
   d9394:	fb04 f402 	mul.w	r4, r4, r2
   d9398:	f104 0602 	add.w	r6, r4, #2
   d939c:	f04f 0405 	mov.w	r4, #5
   d93a0:	fbb6 f4f4 	udiv	r4, r6, r4
   d93a4:	bf34      	ite	cc
   d93a6:	2602      	movcc	r6, #2
   d93a8:	f06f 0609 	mvncs.w	r6, #9
   d93ac:	4416      	add	r6, r2
   d93ae:	f44f 72c8 	mov.w	r2, #400	; 0x190
   d93b2:	fb02 0505 	mla	r5, r2, r5, r0
   d93b6:	1c5f      	adds	r7, r3, #1
   d93b8:	2e01      	cmp	r6, #1
   d93ba:	bf98      	it	ls
   d93bc:	3501      	addls	r5, #1
   d93be:	f5b3 7f99 	cmp.w	r3, #306	; 0x132
   d93c2:	eba7 0704 	sub.w	r7, r7, r4
   d93c6:	d302      	bcc.n	d93ce <gmtime_r+0xe2>
   d93c8:	f5a3 7299 	sub.w	r2, r3, #306	; 0x132
   d93cc:	e014      	b.n	d93f8 <gmtime_r+0x10c>
   d93ce:	0782      	lsls	r2, r0, #30
   d93d0:	d105      	bne.n	d93de <gmtime_r+0xf2>
   d93d2:	2464      	movs	r4, #100	; 0x64
   d93d4:	fbb0 f2f4 	udiv	r2, r0, r4
   d93d8:	fb04 0212 	mls	r2, r4, r2, r0
   d93dc:	b94a      	cbnz	r2, d93f2 <gmtime_r+0x106>
   d93de:	f44f 72c8 	mov.w	r2, #400	; 0x190
   d93e2:	fbb0 f4f2 	udiv	r4, r0, r2
   d93e6:	fb02 0014 	mls	r0, r2, r4, r0
   d93ea:	fab0 f280 	clz	r2, r0
   d93ee:	0952      	lsrs	r2, r2, #5
   d93f0:	e000      	b.n	d93f4 <gmtime_r+0x108>
   d93f2:	2201      	movs	r2, #1
   d93f4:	333b      	adds	r3, #59	; 0x3b
   d93f6:	441a      	add	r2, r3
   d93f8:	f2a5 756c 	subw	r5, r5, #1900	; 0x76c
   d93fc:	2300      	movs	r3, #0
   d93fe:	61ca      	str	r2, [r1, #28]
   d9400:	614d      	str	r5, [r1, #20]
   d9402:	610e      	str	r6, [r1, #16]
   d9404:	60cf      	str	r7, [r1, #12]
   d9406:	620b      	str	r3, [r1, #32]
   d9408:	4608      	mov	r0, r1
   d940a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   d940c:	00015180 	.word	0x00015180
   d9410:	fffdc54f 	.word	0xfffdc54f
   d9414:	00023ab1 	.word	0x00023ab1
   d9418:	00023ab0 	.word	0x00023ab0

000d941c <labs>:
   d941c:	2800      	cmp	r0, #0
   d941e:	bfb8      	it	lt
   d9420:	4240      	neglt	r0, r0
   d9422:	4770      	bx	lr

000d9424 <__env_lock>:
   d9424:	4770      	bx	lr

000d9426 <__env_unlock>:
   d9426:	4770      	bx	lr

000d9428 <dynalib_user>:
   d9428:	401d 000d 4059 000d 4085 000d 4089 000d     .@..Y@...@...@..
   d9438:	0000 0000                                   ....

000d943c <_ZL8Page_end>:
   d943c:	2f3c 6f62 7964 3c3e 682f 6d74 3e6c 4800          </body></html>.

000d944b <_ZZN9WebServer8httpFailEvE8failMsg1>:
   d944b:	5448 5054 312f 302e 3420 3030 4220 6461     HTTP/1.0 400 Bad
   d945b:	5220 7165 6575 7473 0a0d 3c00                     Request...

000d9466 <_ZL10Page_start>:
   d9466:	683c 6d74 3e6c 683c 6165 3e64 6d3c 7465     <html><head><met
   d9476:	2061 6863 7261 6573 3d74 7527 6674 382d     a charset='utf-8
   d9486:	2f27 3c3e 6974 6c74 3e65 4375 6d61 4949     '/><title>uCamII
   d9496:	2049 6544 6f6d 2f3c 6974 6c74 3e65 2f3c     I Demo</title></
   d94a6:	6568 6461 3c3e 6f62 7964 0a3e 7400               head><body>..

000d94b3 <_ZZ12takeSnapshot6StringE12__FUNCTION__>:
   d94b3:	6174 656b 6e53 7061 6873 746f 6200               takeSnapshot.

000d94c0 <_ZZ9bmpHeaderPhiiiiiiE12__FUNCTION__>:
   d94c0:	6d62 4870 6165 6564 0072                    bmpHeader.

000d94ca <_ZZN12uCamIII_Base6setCBEE11uCamIII_CBES0_S0_E12__FUNCTION__>:
   d94ca:	6573 4374 4542 0000                              setCBE.

000d94d1 <_ZZN9WebServer7faviconENS_14ConnectionTypeEE10faviconIco>:
   d94d1:	0000 0001 0001 1010 0002 0001 0001 00b0     ................
   d94e1:	0000 0016 0000 0028 0000 0010 0000 0020     ......(....... .
   d94f1:	0000 0001 0001 0000 0000 0000 0000 0000     ................
	...
   d9511:	0000 00ff 0000 ffff 0000 ffff 0000 ffff     ................
   d9521:	0000 bfcf 0000 bfc7 0000 bfc3 0000 bfc1     ................
   d9531:	0000 bfc0 0000 0000 0000 bfc0 0000 bfc1     ................
   d9541:	0000 bfc3 0000 bfc7 0000 bfcf 0000 ffff     ................
   d9551:	0000 ffff 0000 0000 0000 0000 0000 0000     ................
	...

000d9597 <_ZZ14devicesHandler6StringE12__FUNCTION__>:
   d9597:	6564 6976 6563 4873 6e61 6c64 7265 6900          devicesHandler.

000d95a6 <_ZZ8imageCmdR9WebServerNS_14ConnectionTypeEPcbE12__FUNCTION__>:
   d95a6:	6d69 6761 4365 646d 5500                         imageCmd.

000d95af <_ZZN9WebServer8noRobotsENS_14ConnectionTypeEE12allowNoneMsg>:
   d95af:	7355 7265 612d 6567 746e 203a 0d2a 440a     User-agent: *..D
   d95bf:	7369 6c61 6f6c 3a77 2f20 0a0d 4300               isallow: /...

000d95cc <_ZZN9WebServer8httpFailEvE8failMsg2>:
   d95cc:	6f43 746e 6e65 2d74 7954 6570 203a 6574     Content-Type: te
   d95dc:	7478 682f 6d74 0d6c 0d0a 3c0a 3168 453e     xt/html....<h1>E
   d95ec:	4950 2043 4146 4c49 2f3c 3168 003e          PIC FAIL</h1>.

000d95fa <_ZZN12uCamIII_Base14setPackageSizeEtE12__FUNCTION__>:
   d95fa:	6573 5074 6361 616b 6567 6953 657a 3c00          setPackageSize.

000d9609 <_ZL6script>:
   d9609:	733c 7263 7069 3e74 6f64 7563 656d 746e     <script>document
   d9619:	672e 7465 6c45 6d65 6e65 4274 4979 2864     .getElementById(
   d9629:	4327 2754 2e29 6176 756c 3d65 2527 3230     'CT').value='%02
   d9639:	2764 643b 636f 6d75 6e65 2e74 6567 4574     d';document.getE
   d9649:	656c 656d 746e 7942 6449 2728 5252 2927     lementById('RR')
   d9659:	762e 6c61 6575 273d 3025 6432 3b27 6f64     .value='%02d';do
   d9669:	7563 656d 746e 672e 7465 6c45 6d65 6e65     cument.getElemen
   d9679:	4274 4979 2864 4a27 2752 2e29 6176 756c     tById('JR').valu
   d9689:	3d65 2527 3230 2764 643b 636f 6d75 6e65     e='%02d';documen
   d9699:	2e74 6567 4574 656c 656d 746e 7942 6449     t.getElementById
   d96a9:	2728 6263 4365 2927 762e 6c61 6575 273d     ('cbeC').value='
   d96b9:	3025 6432 3b27 6f64 7563 656d 746e 672e     %02d';document.g
   d96c9:	7465 6c45 6d65 6e65 4274 4979 2864 6327     etElementById('c
   d96d9:	6562 2742 2e29 6176 756c 3d65 2527 3230     beB').value='%02
   d96e9:	2764 643b 636f 6d75 6e65 2e74 6567 4574     d';document.getE
   d96f9:	656c 656d 746e 7942 6449 2728 6263 4565     lementById('cbeE
   d9709:	2927 762e 6c61 6575 273d 3025 6432 3b27     ').value='%02d';
   d9719:	6f64 7563 656d 746e 672e 7465 6c45 6d65     document.getElem
   d9729:	6e65 4274 4979 2864 7427 6d69 7365 6174     entById('timesta
   d9739:	706d 2927 692e 6e6e 7265 5448 4c4d 273d     mp').innerHTML='
   d9749:	7325 2b25 3330 3a64 3025 6432 3b27 2f3c     %s%+03d:%02d';</
   d9759:	6373 6972 7470 003e                         script>.

000d9761 <_ZL15webServerHeader>:
   d9761:	6553 7672 7265 203a 6557 6462 6975 6f6e     Server: Webduino
   d9771:	312f 372e 0a0d 7300                              /1.7...

000d9778 <_ZZN12uCamIII_Base14setImageFormatE20uCamIII_IMAGE_FORMAT11uCamIII_RESE12__FUNCTION__>:
   d9778:	6573 4974 616d 6567 6f46 6d72 7461 6900          setImageFormat.

000d9787 <_ZZN7uCamIIII11USARTSerialE4initEiE12__FUNCTION__>:
   d9787:	6e69 7469 0000                                   init.

000d978c <_ZTV9WebServer>:
	...
   d9794:	418d 000d 41bd 000d 4131 000d 4443 000d     .A...A..1A..CD..

000d97a4 <_ZZN12uCamIII_Base12takeSnapshotE17uCamIII_SNAP_TYPEtE12__FUNCTION__>:
   d97a4:	6174 656b 6e53 7061 6873 746f 4800               takeSnapshot.

000d97b1 <_ZZN9WebServer11httpSuccessEPKcS1_E11successMsg1>:
   d97b1:	5448 5054 312f 302e 3220 3030 4f20 0d4b     HTTP/1.0 200 OK.
   d97c1:	000a                                        ..

000d97c3 <_ZZN9WebServer11httpSuccessEPKcS1_E11successMsg2>:
   d97c3:	6341 6563 7373 432d 6e6f 7274 6c6f 412d     Access-Control-A
   d97d3:	6c6c 776f 4f2d 6972 6967 3a6e 2a20 0a0d     llow-Origin: *..
   d97e3:	6f43 746e 6e65 2d74 7954 6570 203a 3c00          Content-Type: .

000d97f2 <_ZL7camBody>:
   d97f2:	663c 726f 206d 6469 273d 6573 7474 6e69     <form id='settin
   d9802:	7367 2027 6e6f 6c63 6369 3d6b 6327 696c     gs' onclick='cli
   d9812:	6b63 3e27 743c 6261 656c 7320 7974 656c     ck'><table style
   d9822:	273d 6977 7464 3a68 3120 3030 2725 3c3e     ='width: 100%'><
   d9832:	7274 3c3e 6474 7720 6469 6874 273d 3031     tr><td width='10
   d9842:	2725 3c3e 616c 6562 3e6c 6f43 6f6c 2072     %'><label>Color 
   d9852:	7954 6570 2f3c 616c 6562 3e6c 2f3c 6474     Type</label></td
   d9862:	3c3e 6474 6320 6c6f 7073 6e61 273d 2733     ><td colspan='3'
   d9872:	3c3e 6573 656c 7463 6920 3d64 4327 2754     ><select id='CT'
   d9882:	6e20 6d61 3d65 4327 2754 7320 7974 656c      name='CT' style
   d9892:	273d 6977 7464 3a68 3120 3030 2725 3e20     ='width: 100%' >
   d98a2:	6f3c 7470 6f69 206e 6176 756c 3d65 3027     <option value='0
   d98b2:	2737 4a3e 4550 3c47 6f2f 7470 6f69 3e6e     7'>JPEG</option>
   d98c2:	6f3c 7470 6f69 206e 6176 756c 3d65 3027     <option value='0
   d98d2:	2733 523e 7761 7247 7361 6163 656c 6238     3'>RawGrascale8b
   d98e2:	7469 2f3c 706f 6974 6e6f 3c3e 706f 6974     it</option><opti
   d98f2:	6e6f 7620 6c61 6575 273d 3630 3e27 6152     on value='06'>Ra
   d9902:	4377 6c6f 726f 3631 6962 5274 4247 3635     wColor16bitRGB56
   d9912:	3c35 6f2f 7470 6f69 3e6e 6f3c 7470 6f69     5</option><optio
   d9922:	206e 6176 756c 3d65 3027 2738 523e 7761     n value='08'>Raw
   d9932:	6f43 6f6c 3172 6236 7469 7243 4359 5962     Color16bitCrYCbY
   d9942:	2f3c 706f 6974 6e6f 3c3e 732f 6c65 6365     </option></selec
   d9952:	3e74 743c 2064 6977 7464 3d68 3127 2530     t><td width='10%
   d9962:	3e27 6c3c 6261 6c65 433e 6e6f 7274 7361     '><label>Contras
   d9972:	3c74 6c2f 6261 6c65 3c3e 742f 3e64 743c     t</label></td><t
   d9982:	3e64 733c 6c65 6365 2074 6469 273d 6263     d><select id='cb
   d9992:	4365 2027 616e 656d 273d 6263 4365 2027     eC' name='cbeC' 
   d99a2:	7473 6c79 3d65 7727 6469 6874 203a 3031     style='width: 10
   d99b2:	2530 2027 3c3e 706f 6974 6e6f 7620 6c61     0%' ><option val
   d99c2:	6575 273d 3030 3e27 694d 3c6e 6f2f 7470     ue='00'>Min</opt
   d99d2:	6f69 3e6e 6f3c 7470 6f69 206e 6176 756c     ion><option valu
   d99e2:	3d65 3027 2731 4c3e 776f 2f3c 706f 6974     e='01'>Low</opti
   d99f2:	6e6f 3c3e 706f 6974 6e6f 7620 6c61 6575     on><option value
   d9a02:	273d 3230 2027 6573 656c 7463 6465 273d     ='02' selected='
   d9a12:	7274 6575 3e27 6544 6166 6c75 3c74 6f2f     true'>Default</o
   d9a22:	7470 6f69 3e6e 6f3c 7470 6f69 206e 6176     ption><option va
   d9a32:	756c 3d65 3027 2733 483e 6769 3c68 6f2f     lue='03'>High</o
   d9a42:	7470 6f69 3e6e 6f3c 7470 6f69 206e 6176     ption><option va
   d9a52:	756c 3d65 3027 2734 4d3e 7861 2f3c 706f     lue='04'>Max</op
   d9a62:	6974 6e6f 3c3e 732f 6c65 6365 3e74 2f3c     tion></select></
   d9a72:	6474 3c3e 6474 7220 776f 7073 6e61 273d     td><td rowspan='
   d9a82:	2733 3c3e 6e69 7570 2074 6469 273d 6c63     3'><input id='cl
   d9a92:	6369 276b 7420 7079 3d65 7327 6275 696d     ick' type='submi
   d9aa2:	2774 7620 6c61 6575 273d 6c43 6369 216b     t' value='Click!
   d9ab2:	2027 7473 6c79 3d65 7727 6469 6874 313a     ' style='width:1
   d9ac2:	3032 7870 203b 6568 6769 7468 363a 7030     20px; height:60p
   d9ad2:	2778 2f20 3c3e 742f 3e64 2f3c 7274 3c3e     x' /></td></tr><
   d9ae2:	7274 3c3e 6474 7720 6469 6874 273d 3031     tr><td width='10
   d9af2:	2725 3c3e 616c 6562 3e6c 6152 2077 6552     %'><label>Raw Re
   d9b02:	6f73 756c 6974 6e6f 2f3c 616c 6562 3e6c     solution</label>
   d9b12:	2f3c 6474 3c3e 6474 3c3e 6573 656c 7463     </td><td><select
   d9b22:	6920 3d64 5227 2752 6e20 6d61 3d65 5227      id='RR' name='R
   d9b32:	2752 7320 7974 656c 273d 6977 7464 3a68     R' style='width:
   d9b42:	3120 3030 2725 3e20 6f3c 7470 6f69 206e      100%' ><option 
   d9b52:	6176 756c 3d65 3027 2733 313e 3036 3178     value='03'>160x1
   d9b62:	3032 2f3c 706f 6974 6e6f 3c3e 706f 6974     20</option><opti
   d9b72:	6e6f 7620 6c61 6575 273d 3930 3e27 3231     on value='09'>12
   d9b82:	7838 3231 3c38 6f2f 7470 6f69 3e6e 6f3c     8x128</option><o
   d9b92:	7470 6f69 206e 6176 756c 3d65 3027 2738     ption value='08'
   d9ba2:	313e 3832 3978 3c36 6f2f 7470 6f69 3e6e     >128x96</option>
   d9bb2:	6f3c 7470 6f69 206e 6176 756c 3d65 3027     <option value='0
   d9bc2:	2731 383e 7830 3036 2f3c 706f 6974 6e6f     1'>80x60</option
   d9bd2:	3c3e 732f 6c65 6365 3e74 2f3c 6474 3c3e     ></select></td><
   d9be2:	6474 7720 6469 6874 273d 3031 2725 3c3e     td width='10%'><
   d9bf2:	616c 6562 3e6c 504a 2047 6552 6f73 756c     label>JPG Resolu
   d9c02:	6974 6e6f 2f3c 616c 6562 3e6c 2f3c 6474     tion</label></td
   d9c12:	3c3e 6474 3c3e 6573 656c 7463 6920 3d64     ><td><select id=
   d9c22:	4a27 2752 6e20 6d61 3d65 4a27 2752 7320     'JR' name='JR' s
   d9c32:	7974 656c 273d 6977 7464 3a68 3120 3030     tyle='width: 100
   d9c42:	2725 3e20 6f3c 7470 6f69 206e 6176 756c     %' ><option valu
   d9c52:	3d65 3027 2737 363e 3034 3478 3038 2f3c     e='07'>640x480</
   d9c62:	706f 6974 6e6f 3c3e 706f 6974 6e6f 7620     option><option v
   d9c72:	6c61 6575 273d 3530 3e27 3233 7830 3432     alue='05'>320x24
   d9c82:	3c30 6f2f 7470 6f69 3e6e 6f3c 7470 6f69     0</option><optio
   d9c92:	206e 6176 756c 3d65 3027 2733 313e 3036     n value='03'>160
   d9ca2:	3178 3032 2f3c 706f 6974 6e6f 3c3e 732f     x120</option></s
   d9cb2:	6c65 6365 3e74 2f3c 6474 3c3e 6474 7720     elect></td><td w
   d9cc2:	6469 6874 273d 3031 2725 3c3e 616c 6562     idth='10%'><labe
   d9cd2:	3e6c 7242 6769 7468 656e 7373 2f3c 616c     l>Brightness</la
   d9ce2:	6562 3e6c 2f3c 6474 3c3e 6474 3c3e 6573     bel></td><td><se
   d9cf2:	656c 7463 6920 3d64 6327 6562 2742 6e20     lect id='cbeB' n
   d9d02:	6d61 3d65 6327 6562 2742 7320 7974 656c     ame='cbeB' style
   d9d12:	273d 6977 7464 3a68 3120 3030 2725 3e20     ='width: 100%' >
   d9d22:	6f3c 7470 6f69 206e 6176 756c 3d65 3027     <option value='0
   d9d32:	2730 4d3e 6e69 2f3c 706f 6974 6e6f 3c3e     0'>Min</option><
   d9d42:	706f 6974 6e6f 7620 6c61 6575 273d 3130     option value='01
   d9d52:	3e27 6f4c 3c77 6f2f 7470 6f69 3e6e 6f3c     '>Low</option><o
   d9d62:	7470 6f69 206e 6176 756c 3d65 3027 2732     ption value='02'
   d9d72:	7320 6c65 6365 6574 3d64 7427 7572 2765      selected='true'
   d9d82:	443e 6665 7561 746c 2f3c 706f 6974 6e6f     >Default</option
   d9d92:	3c3e 706f 6974 6e6f 7620 6c61 6575 273d     ><option value='
   d9da2:	3330 3e27 6948 6867 2f3c 706f 6974 6e6f     03'>High</option
   d9db2:	3c3e 706f 6974 6e6f 7620 6c61 6575 273d     ><option value='
   d9dc2:	3430 3e27 614d 3c78 6f2f 7470 6f69 3e6e     04'>Max</option>
   d9dd2:	2f3c 6573 656c 7463 3c3e 742f 3e64 2f3c     </select></td></
   d9de2:	7274 3c3e 7274 3c3e 6474 3e2f 743c 2f64     tr><tr><td/><td/
   d9df2:	3c3e 6474 3e2f 743c 2f64 3c3e 6474 7720     ><td/><td/><td w
   d9e02:	6469 6874 273d 3031 2725 3c3e 616c 6562     idth='10%'><labe
   d9e12:	3e6c 7845 6f70 7573 6572 2f3c 616c 6562     l>Exposure</labe
   d9e22:	3e6c 2f3c 6474 3c3e 6474 3c3e 6573 656c     l></td><td><sele
   d9e32:	7463 6920 3d64 6327 6562 2745 6e20 6d61     ct id='cbeE' nam
   d9e42:	3d65 6327 6562 2745 7320 7974 656c 273d     e='cbeE' style='
   d9e52:	6977 7464 3a68 3120 3030 2725 3e20 6f3c     width: 100%' ><o
   d9e62:	7470 6f69 206e 6176 756c 3d65 3027 2730     ption value='00'
   d9e72:	2d3e 3c32 6f2f 7470 6f69 3e6e 6f3c 7470     >-2</option><opt
   d9e82:	6f69 206e 6176 756c 3d65 3027 2731 2d3e     ion value='01'>-
   d9e92:	3c31 6f2f 7470 6f69 3e6e 6f3c 7470 6f69     1</option><optio
   d9ea2:	206e 6176 756c 3d65 3027 2732 7320 6c65     n value='02' sel
   d9eb2:	6365 6574 3d64 7427 7572 2765 303e 2f3c     ected='true'>0</
   d9ec2:	706f 6974 6e6f 3c3e 706f 6974 6e6f 7620     option><option v
   d9ed2:	6c61 6575 273d 3330 3e27 312b 2f3c 706f     alue='03'>+1</op
   d9ee2:	6974 6e6f 3c3e 706f 6974 6e6f 7620 6c61     tion><option val
   d9ef2:	6575 273d 3430 3e27 322b 2f3c 706f 6974     ue='04'>+2</opti
   d9f02:	6e6f 3c3e 732f 6c65 6365 3e74 2f3c 6474     on></select></td
   d9f12:	3c3e 742f 3e72 2f3c 6174 6c62 3e65 2f3c     ></tr></table></
   d9f22:	6f66 6d72 3c3e 7262 3e2f 693c 676d 7320     form><br/><img s
   d9f32:	6372 273d 6d69 6761 2e65 6164 2774 2f20     rc='image.dat' /
   d9f42:	3c3e 7262 3e2f 613c 6820 6572 3d66 6927     ><br/><a href='i
   d9f52:	616d 6567 642e 7461 3e27 6f64 6e77 6f6c     mage.dat'>downlo
   d9f62:	6461 6920 616d 6567 3c20 612f 3c3e 616c     ad image </a><la
   d9f72:	6562 206c 6469 273d 6974 656d 7473 6d61     bel id='timestam
   d9f82:	2770 3c3e 6c2f 6261 6c65 3c3e 7262 3e2f     p'></label><br/>
   d9f92:	683c 3e33 663c 6e6f 2074 6f63 6f6c 3d72     <h3><font color=
   d9fa2:	7227 6465 3e27 3631 6962 2074 6172 2077     'red'>16bit raw 
   d9fb2:	6d69 6761 7365 7720 6c69 206c 6562 6420     images will be d
   d9fc2:	7369 6c70 7961 6465 7720 7469 2068 6964     isplayed with di
   d9fd2:	7473 726f 6574 2064 6f63 6f6c 7372 2f3c     storted colors</
   d9fe2:	6f66 746e 3c3e 682f 3e33 683c 3e34 6843     font></h3><h4>Ch
   d9ff2:	6f72 656d 6420 656f 6e73 7427 6320 706f     rome doesn't cop
   da002:	2065 6577 6c6c 7720 7469 2068 6172 2077     e well with raw 
   da012:	6d69 6761 7365 6120 2074 6c61 2c6c 6220     images at all, b
   da022:	7465 6574 2072 7375 2065 746f 6568 2072     etter use other 
   da032:	7262 776f 6573 2072 6528 672e 202e 6f4d     browser (e.g. Mo
   da042:	697a 6c6c 2061 6946 6572 6f66 2978 2f3c     zilla Firefox)</
   da052:	3468 3c3e 7262 3e2f 6f54 7620 6569 2077     h4><br/>To view 
   da062:	6977 6874 6320 726f 6572 7463 6320 6c6f     with correct col
   da072:	726f 2073 7375 2065 6e61 6920 616d 6567     ors use an image
   da082:	7620 6569 6577 2072 6874 7461 7320 7075      viewer that sup
   da092:	6f70 7472 3c73 7262 3e2f 4752 3542 3536     ports<br/>RGB565
   da0a2:	6f20 2072 7243 4359 5962 552f 5659 2059      or CrYCbY/UYVY 
   da0b2:	6e65 6f63 6964 676e 2820 2e65 2e67 4720     encoding (e.g. G
   da0c2:	4d49 2950 623c 2f72 3c3e 2061 7268 6665     IMP)<br/><a href
   da0d2:	273d 7468 7074 2f3a 772f 7777 342e 7364     ='http://www.4ds
   da0e2:	7379 6574 736d 632e 6d6f 612e 2f75 7270     ystems.com.au/pr
   da0f2:	646f 6375 7074 6761 7365 752f 4143 2d4d     oductpages/uCAM-
   da102:	4949 2f49 6f64 6e77 6f6c 6461 2f73 4375     III/downloads/uC
   da112:	4d41 492d 4949 645f 7461 7361 6568 7465     AM-III_datasheet
   da122:	525f 315f 305f 702e 6664 3e27 4375 6d61     _R_1_0.pdf'>uCam
   da132:	4949 2049 6164 6174 6873 6565 3c74 612f     III datasheet</a
   da142:	3c3e 7262 3e2f 623c 2f72 003e               ><br/><br/>.

000da14e <_ZZ10defaultCmdR9WebServerNS_14ConnectionTypeEPcbE12__FUNCTION__>:
   da14e:	6564 6166 6c75 4374 646d 7400 7063 5000     defaultCmd.tcp.P
   da15e:	6361 616b 6567 2520 2064 2528 2064 7942     ackage %d (%d By
   da16e:	6574 2029 3e2d 5320 7265 6169 006c 6150     te) -> Serial.Pa
   da17e:	6b63 6761 2065 6425 2820 6425 4220 7479     ckage %d (%d Byt
   da18e:	2965 2d20 203e 4354 2050 7325 253a 0064     e) -> TCP %s:%d.
   da19e:	6564 6976 6563 4873 6e61 6c64 7265 6420     devicesHandler d
   da1ae:	7461 3d61 7325 2500 2e75 7525 252e 2e75     ata=%s.%u.%u.%u.
   da1be:	7525 253a 2c75 3325 7332 7300 7265 6576     %u:%u,%32s.serve
   da1ce:	4172 6464 3d72 7325 7320 7265 6576 5072     rAddr=%s serverP
   da1de:	726f 3d74 7525 6e20 6e6f 6563 253d 0073     ort=%u nonce=%s.
   da1ee:	6142 6973 2063 7400 7865 2f74 6c70 6961     Basic .text/plai
   da1fe:	006e 6143 6863 2d65 6f43 746e 6f72 3a6c     n.Cache-Control:
   da20e:	6d20 7861 612d 6567 333d 3531 3633 3030      max-age=3153600
   da21e:	0030 6d69 6761 2f65 2d78 6369 6e6f 4700     0.image/x-icon.G
   da22e:	5445 0020 4548 4441 0020 4f50 5453 0020     ET .HEAD .POST .
   da23e:	5550 2054 4400 4c45 5445 2045 5000 5441     PUT .DELETE .PAT
   da24e:	4843 0020 6f43 746e 6e65 2d74 654c 676e     CH .Content-Leng
   da25e:	6874 003a 7541 6874 726f 7a69 7461 6f69     th:.Authorizatio
   da26e:	3a6e 0d00 0d0a 000a 722f 626f 746f 2e73     n:....../robots.
   da27e:	7874 0074 662f 7661 6369 6e6f 692e 6f63     txt./favicon.ico
   da28e:	6300 6568 6b63 6f62 0078 6172 6964 006f     .checkbox.radio.
   da29e:	6573 5374 7265 6576 0072 6573 5474 7261     setServer.setTar
   da2ae:	6567 0074 6e73 7061 7500 4143 494d 4949     get.snap.uCAMIII
   da2be:	203a 7325 4900 0050 6e69 6564 2e78 7468     : %s.IP.index.ht
   da2ce:	6c6d 6900 616d 6567 642e 7461 7400 7865     ml.image.dat.tex
   da2de:	2f74 7468 6c6d 203b 6863 7261 6573 3d74     t/html; charset=
   da2ee:	7475 2d66 0038 5443 5200 0052 524a 6300     utf-8.CT.RR.JR.c
   da2fe:	6562 0043 6263 4265 6300 6562 0045 4625     beC.cbeB.cbeE.%F
   da30e:	2554 0054 4d42 2050 6164 6174 6f20 6666     T%T.BMP data off
   da31e:	6573 3a74 2520 2064 202b 6425 2b20 2520     set: %d + %d + %
   da32e:	2064 203d 6425 202c 4d42 2050 6966 656c     d = %d, BMP file
   da33e:	7320 7a69 3a65 2520 0064 504a 0047 504a      size: %d.JPG.JP
   da34e:	4745 5200 4247 3631 5500 5659 3159 0036     EG.RGB16.UYVY16.
   da35e:	7243 4359 5962 3631 0d00 490a 616d 6567     CrYCbY16...Image
   da36e:	6953 657a 203a 6425 6700 7465 4a20 4550     Size: %d.get JPE
   da37e:	2047 6863 6e75 736b 6700 7465 5220 5741     G chunks.get RAW
   da38e:	6920 616d 6567 6100 7466 7265 6220 706d      image.after bmp
   da39e:	6548 6461 7265 2820 6425 0029 6661 6574     Header (%d).afte
   da3ae:	2072 6567 5274 7761 6144 6174 2820 6425     r getRawData (%d
   da3be:	0029 6562 6f66 6572 7320 7265 6576 2072     ).before server 
   da3ce:	7277 7469 2065 2528 2064 202b 6425 3d20     write (%d + %d =
   da3de:	2520 2064 202f 6425 3d20 203d 6425 0029      %d / %d == %d).
   da3ee:	6661 6574 2072 6573 7672 7265 7720 6972     after server wri
   da3fe:	6574 2820 6425 2b20 2520 2064 203d 6425     te (%d + %d = %d
   da40e:	2f20 2520 2064 3d3d 2520 2964 7200 7761      / %d == %d).raw
   da41e:	7420 6f6f 6220 6769 6620 726f 6220 6675      too big for buf
   da42e:	6566 2072 6425 3c20 203d 6425 0000               fer %d <= %d.

000da43b <_ZL6PREFIX>:
	...

000da43c <_ZTV10TCPClientX>:
	...
   da444:	41d5 000d 5591 000d 7259 000d 56a1 000d     .A...U..Yr...V..
   da454:	7675 000d 73c7 000d 7399 000d 729d 000d     uv...s...s...r..
   da464:	7551 000d 744d 000d 73fb 000d 7645 000d     Qu..Mt...s..Ev..
   da474:	729f 000d 72d7 000d 7285 000d 72f9 000d     .r...r...r...r..
   da484:	7379 000d                                   ys..

000da488 <_ZZN12uCamIII_Base7sendCmdE11uCamIII_CMDhhhhE12__FUNCTION__>:
   da488:	6573 646e 6d43 0064                         sendCmd.

000da490 <_ZZN12uCamIII_Base4syncEiE12__FUNCTION__>:
   da490:	7973 636e 6500                                   sync.

000da495 <_ZZN12uCamIII_Base13expectPackageE11uCamIII_CMDhE12__FUNCTION__>:
   da495:	7865 6570 7463 6150 6b63 6761 0065          expectPackage.

000da4a3 <_ZZN12uCamIII_Base10getPictureE16uCamIII_PIC_TYPEE12__FUNCTION__>:
   da4a3:	6567 5074 6369 7574 6572 7300 6e65 4364     getPicture.sendC
   da4b3:	646d 203a 3025 5832 2520 3230 2058 3025     md: %02X %02X %0
   da4c3:	5832 2520 3230 2058 3025 5832 2520 3230     2X %02X %02X %02
   da4d3:	0058 7325 2528 3230 2c78 3025 7832 0029     X.%s(%02x,%02x).
   da4e3:	6572 6563 7669 6465 203a 3025 5832 2520     received: %02X %
   da4f3:	3230 2058 3025 5832 2520 3230 2058 3025     02X %02X %02X %0
   da503:	5832 2520 3230 0058 6974 656d 756f 3a74     2X %02X.timeout:
   da513:	2520 3230 2058 3025 5832 2520 3230 2058      %02X %02X %02X 
   da523:	3025 5832 2520 3230 2058 3025 5832 2820     %02X %02X %02X (
   da533:	6c25 2975 7300 6e79 2063 6661 6574 2072     %lu).sync after 
   da543:	6425 7420 6972 7365 6e00 206f 7973 636e     %d tries.no sync
   da553:	7500 4143 494d 4949 425f 7361 3a65 2520     .uCAMIII_Base: %
   da563:	0073                                        s.

000da565 <_ZZN12uCamIII_Base4initEvE12__FUNCTION__>:
   da565:	6e69 7469 7300                                   init.

000da56a <_ZZN12uCamIII_Base14sendCmdWithAckE11uCamIII_CMDhhhhE12__FUNCTION__>:
   da56a:	6573 646e 6d43 5764 7469 4168 6b63 7900          sendCmdWithAck.

000da579 <_ZZN12uCamIII_Base5yieldEvE12__FUNCTION__>:
   da579:	6979 6c65 0064                              yield.

000da57f <_ZZN12uCamIII_Base9hardResetEvE12__FUNCTION__>:
   da57f:	6168 6472 6552 6573 0074                    hardReset.

000da589 <_ZZN12uCamIII_Base11getJpegDataEPhiPFiS0_iiEiE12__FUNCTION__>:
   da589:	6567 4a74 6570 4467 7461 0061 0000 0000          getJpegData....

000da598 <_ZTVN5spark13EthernetClassE>:
	...
   da5a0:	61e3 000d 61d9 000d 61cf 000d 61c5 000d     .a...a...a...a..
   da5b0:	61b9 000d 61ad 000d 61a1 000d 6199 000d     .a...a...a...a..
   da5c0:	618f 000d 6185 000d 78cd 000d               .a...a...x..

000da5cc <_ZTV21StringPrintableHelper>:
	...
   da5d4:	626d 000d 626f 000d 63c1 000d 6393 000d     mb..ob...c...c..

000da5e4 <_ZTV5Print>:
	...
   da5f4:	40a5 000d 646d 000d 6162 6475 5300 7265     .@..md..baud.Ser
   da604:	6169 316c 7400 7079 0065 6170 6172 006d     ial1.type.param.
   da614:	6d63 0064 6469 6800 646e 7300 7274 006d     cmd.id.hnd.strm.
   da624:	6966 746c 6c00 6c76 6100 6464 6148 646e     filt.lvl.addHand
   da634:	656c 0072 6572 6f6d 6576 6148 646e 656c     ler.removeHandle
   da644:	0072 6e65 6d75 6148 646e 656c 7372 4a00     r.enumHandlers.J
   da654:	4f53 534e 7274 6165 4c6d 676f 6148 646e     SONStreamLogHand
   da664:	656c 0072 7061 0070 3025 3031 2075 5d00     ler.app.%010u .]
   da674:	0020 202c 2800 3a29 0020 5b20 6300 646f      ., .(): . [.cod
   da684:	2065 203d 2500 0069 6564 6174 6c69 2073     e = .%i.details 
   da694:	203d 6600 6c00 006e 6e66 6300 646f 0065     = .f.ln.fn.code.
   da6a4:	6564 6174 6c69 6e00 6e6f 0065 7274 6361     detail.none.trac
   da6b4:	0065 6e69 6f66 7700 7261 006e 7265 6f72     e.info.warn.erro
   da6c4:	0072 6170 696e 0063 6c61 006c 2b25 3330     r.panic.all.%+03
   da6d4:	3a64 3025 7532 2500 2d59 6d25 252d 5464     d:%02u.%Y-%m-%dT
   da6e4:	4825 253a 3a4d 5325 7a25 6100 6373 6974     %H:%M:%S%z.ascti
   da6f4:	656d 0000                                   me..

000da6f8 <_ZTV6Stream>:
	...
   da708:	40a5 000d 646d 000d 40a5 000d 40a5 000d     .@..md...@...@..
   da718:	40a5 000d 40a5 000d                         .@...@..

000da720 <_ZTV6Client>:
	...
   da730:	40a5 000d 40a5 000d 40a5 000d 40a5 000d     .@...@...@...@..
   da740:	40a5 000d 40a5 000d 40a5 000d 40a5 000d     .@...@...@...@..
   da750:	40a5 000d 40a5 000d 40a5 000d 40a5 000d     .@...@...@...@..

000da760 <_ZTV15TCPServerClient>:
	...
   da768:	689d 000d 68b1 000d 7259 000d 7273 000d     .h...h..Yr..sr..
   da778:	7675 000d 73c7 000d 7399 000d 729d 000d     uv...s...s...r..
   da788:	7551 000d 744d 000d 73fb 000d 7645 000d     Qu..Mt...s..Ev..
   da798:	729f 000d 72d7 000d 7285 000d 72f9 000d     .r...r...r...r..
   da7a8:	680d 000d                                   .h..

000da7ac <_ZTV9TCPServer>:
	...
   da7b4:	6a01 000d 6a21 000d 67af 000d 67c5 000d     .j..!j...g...g..
   da7c4:	6931 000d 6797 000d 67d7 000d               1i...g...g..

000da7d0 <_ZTV9IPAddress>:
	...
   da7d8:	6d1b 000d 40c9 000d 415f 000d               .m...@.._A..

000da7e4 <_ZTV9USBSerial>:
	...
   da7ec:	6e3b 000d 6e8b 000d 6e99 000d 646d 000d     ;n...n...n..md..
   da7fc:	6e77 000d 6e3d 000d 6e53 000d 6e85 000d     wn..=n..Sn...n..
   da80c:	6e69 000d 6e37 000d                         in..7n..

000da814 <_ZTV11USARTSerial>:
	...
   da81c:	6f41 000d 6f91 000d 6f9f 000d 646d 000d     Ao...o...o..md..
   da82c:	6f55 000d 6f77 000d 6f63 000d 6f8b 000d     Uo..wo..co...o..
   da83c:	6f43 000d 6f47 000d                         Co..Go..

000da844 <_ZTV7TwoWire>:
	...
   da84c:	7059 000d 70a3 000d 707b 000d 705b 000d     Yp...p..{p..[p..
   da85c:	7083 000d 708b 000d 7093 000d 709b 000d     .p...p...p...p..

000da86c <_ZTVN5spark9MeshClassE>:
	...
   da874:	713b 000d 7131 000d 7127 000d 711d 000d     ;q..1q..'q...q..
   da884:	7111 000d 7105 000d 70f9 000d 70f1 000d     .q...q...p...p..
   da894:	70e7 000d 70dd 000d 78cd 000d               .p...p...x..

000da8a0 <_ZTVSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE>:
	...
   da8a8:	72e1 000d 72e7 000d 77cf 000d 72f5 000d     .r...r...w...r..
   da8b8:	72e3 000d                                   .r..

000da8bc <_ZTV9TCPClient>:
	...
   da8c4:	416d 000d 41e9 000d 7259 000d 7273 000d     mA...A..Yr..sr..
   da8d4:	7675 000d 73c7 000d 7399 000d 729d 000d     uv...s...s...r..
   da8e4:	7551 000d 744d 000d 73fb 000d 7645 000d     Qu..Mt...s..Ev..
   da8f4:	729f 000d 72d7 000d 7285 000d 72f9 000d     .r...r...r...r..
   da904:	7379 000d 6977 6972 676e 7200 6365 2076     ys..wiring.recv 
   da914:	7265 6f72 2072 203d 6425 0000               error = %d..

000da920 <_ZTVN5spark9WiFiClassE>:
	...
   da928:	7845 000d 783b 000d 7831 000d 77e7 000d     Ex..;x..1x...w..
   da938:	7825 000d 7819 000d 780d 000d 7805 000d     %x...x...x...x..
   da948:	77fb 000d 77f1 000d 78cd 000d               .w...w...x..

000da954 <_ZTVN5spark12NetworkClassE>:
	...
   da95c:	7865 000d 786f 000d 7879 000d 7883 000d     ex..ox..yx...x..
   da96c:	788d 000d 7899 000d 78a5 000d 78b1 000d     .x...x...x...x..
   da97c:	78b9 000d 78c3 000d 78cd 000d               .x...x...x..

000da988 <_ZSt7nothrow>:
	...

000da989 <day_name.4725>:
   da989:	7553 4d6e 6e6f 7554 5765 6465 6854 4675     SunMonTueWedThuF
   da999:	6972 6153 4a74                                   riSat

000da99e <mon_name.4726>:
   da99e:	614a 466e 6265 614d 4172 7270 614d 4a79     JanFebMarAprMayJ
   da9ae:	6e75 754a 416c 6775 6553 4f70 7463 6f4e     unJulAugSepOctNo
   da9be:	4476 6365 2e25 7333 2520 332e 2573 6433     vDec%.3s %.3s%3d
   da9ce:	2520 322e 3a64 2e25 6432 253a 322e 2064      %.2d:%.2d:%.2d 
   da9de:	6425 000a                                   %d..

000da9e2 <_ctype_>:
   da9e2:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
   da9f2:	2020 2020 2020 2020 2020 2020 2020 2020                     
   daa02:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
   daa12:	0410 0404 0404 0404 0404 1004 1010 1010     ................
   daa22:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
   daa32:	0101 0101 0101 0101 0101 0101 1010 1010     ................
   daa42:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
   daa52:	0202 0202 0202 0202 0202 0202 1010 1010     ................
   daa62:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...

000daae4 <__sf_fake_stdin>:
	...

000dab04 <__sf_fake_stdout>:
	...

000dab24 <__sf_fake_stderr>:
	...

000dab44 <__month_lengths>:
   dab44:	001f 0000 001c 0000 001f 0000 001e 0000     ................
   dab54:	001f 0000 001e 0000 001f 0000 001f 0000     ................
   dab64:	001e 0000 001f 0000 001e 0000 001f 0000     ................
   dab74:	001f 0000 001d 0000 001f 0000 001e 0000     ................
   dab84:	001f 0000 001e 0000 001f 0000 001f 0000     ................
   dab94:	001e 0000 001f 0000 001e 0000 001f 0000     ................
   daba4:	7325 2e25 642a 2500 2573 2e30 642a 2b00     %s%.*d.%s%0.*d.+
   dabb4:	2d00 2500 6432 2500 322e 2f64 2e25 6432     .-.%2d.%.2d/%.2d
   dabc4:	252f 322e 0064 6c25 0075 2d59 6d25 252d     /%.2d.%lu.Y-%m-%
   dabd4:	0064 2a2e 0075 2e25 6433 2500 6c6c 0064     d..*u.%.3d.%lld.
   dabe4:	2e25 6432 253a 322e 3a64 2e25 6432 2500     %.2d:%.2d:%.2d.%
   dabf4:	302b 6c33 2564 322e 646c 4c00 5f43 4954     +03ld%.2ld.LC_TI
   dac04:	454d 4a00 6e61 4600 6265 4d00 7261 4100     ME.Jan.Feb.Mar.A
   dac14:	7270 4d00 7961 4a00 6e75 4a00 6c75 4100     pr.May.Jun.Jul.A
   dac24:	6775 5300 7065 4f00 7463 4e00 766f 4400     ug.Sep.Oct.Nov.D
   dac34:	6365 4a00 6e61 6175 7972 4600 6265 7572     ec.January.Febru
   dac44:	7261 0079 614d 6372 0068 7041 6972 006c     ary.March.April.
   dac54:	754a 656e 4a00 6c75 0079 7541 7567 7473     June.July.August
   dac64:	5300 7065 6574 626d 7265 4f00 7463 626f     .September.Octob
   dac74:	7265 4e00 766f 6d65 6562 0072 6544 6563     er.November.Dece
   dac84:	626d 7265 5300 6e75 4d00 6e6f 5400 6575     mber.Sun.Mon.Tue
   dac94:	5700 6465 5400 7568 4600 6972 5300 7461     .Wed.Thu.Fri.Sat
   daca4:	5300 6e75 6164 0079 6f4d 646e 7961 5400     .Sunday.Monday.T
   dacb4:	6575 6473 7961 5700 6465 656e 6473 7961     uesday.Wednesday
   dacc4:	5400 7568 7372 6164 0079 7246 6469 7961     .Thursday.Friday
   dacd4:	5300 7461 7275 6164 0079 4825 253a 3a4d     .Saturday.%H:%M:
   dace4:	5325 2500 2f6d 6425 252f 0079 6125 2520     %S.%m/%d/%y.%a %
   dacf4:	2062 6525 2520 3a48 4d25 253a 2053 5925     b %e %H:%M:%S %Y
   dad04:	4100 004d 4d50 2500 2061 6225 2520 2065     .AM.PM.%a %b %e 
   dad14:	4825 253a 3a4d 5325 2520 205a 5925 2500     %H:%M:%S %Z %Y.%
   dad24:	3a49 4d25 253a 2053 7025 0000               I:%M:%S %p..

000dad30 <_C_time_locale>:
   dad30:	ac07 000d ac0b 000d ac0f 000d ac13 000d     ................
   dad40:	ac17 000d ac1b 000d ac1f 000d ac23 000d     ............#...
   dad50:	ac27 000d ac2b 000d ac2f 000d ac33 000d     '...+.../...3...
   dad60:	ac37 000d ac3f 000d ac48 000d ac4e 000d     7...?...H...N...
   dad70:	ac17 000d ac54 000d ac59 000d ac5e 000d     ....T...Y...^...
   dad80:	ac65 000d ac6f 000d ac77 000d ac80 000d     e...o...w.......
   dad90:	ac89 000d ac8d 000d ac91 000d ac95 000d     ................
   dada0:	ac99 000d ac9d 000d aca1 000d aca5 000d     ................
   dadb0:	acac 000d acb3 000d acbb 000d acc5 000d     ................
   dadc0:	acce 000d acd5 000d acde 000d ace7 000d     ................
   dadd0:	acf0 000d ad05 000d ad08 000d ad0b 000d     ................
   dade0:	ac37 000d ac3f 000d ac48 000d ac4e 000d     7...?...H...N...
   dadf0:	ac17 000d ac54 000d ac59 000d ac5e 000d     ....T...Y...^...
   dae00:	ac65 000d ac6f 000d ac77 000d ac80 000d     e...o...w.......
   dae10:	a615 000d ad23 000d a275 000d a275 000d     ....#...u...u...
   dae20:	a275 000d a275 000d a275 000d 5a54 4700     u...u...u...TZ.G
   dae30:	544d 2500 3031 5e5b 2d30 2c39 2d2b 255d     MT.%10[^0-9,+-]%
   dae40:	006e 254d 7568 6e25 252e 7568 6e25 252e     n.M%hu%n.%hu%n.%
   dae50:	7568 6e25 2f00 6825 2575 3a6e 6825 2575     hu%n./%hu%n:%hu%
   dae60:	3a6e 6825 2575 006e                         n:%hu%n.

000dae68 <link_const_variable_data_end>:
   dae68:	000d55a5 	.word	0x000d55a5
   dae6c:	000d5641 	.word	0x000d5641
   dae70:	000d5645 	.word	0x000d5645
   dae74:	000d5649 	.word	0x000d5649
   dae78:	000d564d 	.word	0x000d564d
   dae7c:	000d5651 	.word	0x000d5651
   dae80:	000d5655 	.word	0x000d5655
   dae84:	000d5659 	.word	0x000d5659
   dae88:	000d567d 	.word	0x000d567d
   dae8c:	000d5681 	.word	0x000d5681
   dae90:	000d5685 	.word	0x000d5685
   dae94:	000d5689 	.word	0x000d5689
   dae98:	000d568d 	.word	0x000d568d
   dae9c:	000d5691 	.word	0x000d5691
   daea0:	000d5695 	.word	0x000d5695
   daea4:	000d5699 	.word	0x000d5699
   daea8:	000d569d 	.word	0x000d569d
   daeac:	000d5701 	.word	0x000d5701
   daeb0:	000d5ba9 	.word	0x000d5ba9
   daeb4:	000d61ed 	.word	0x000d61ed
   daeb8:	000d6239 	.word	0x000d6239
   daebc:	000d6445 	.word	0x000d6445
   daec0:	000d6541 	.word	0x000d6541
   daec4:	000d677d 	.word	0x000d677d
   daec8:	000d6b95 	.word	0x000d6b95
   daecc:	000d7209 	.word	0x000d7209
   daed0:	000d7851 	.word	0x000d7851
   daed4:	000d7999 	.word	0x000d7999
   daed8:	000d7b31 	.word	0x000d7b31
   daedc:	000d7bb5 	.word	0x000d7bb5
   daee0:	000d7c79 	.word	0x000d7c79
   daee4:	000d7d3d 	.word	0x000d7d3d

000daee8 <link_constructors_end>:
	...
